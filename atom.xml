<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wilson Blog</title>
  
  <subtitle>一名普通的搬砖工</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wilson-he.gitee.io/"/>
  <updated>2020-03-13T02:36:50.140Z</updated>
  <id>https://wilson-he.gitee.io/</id>
  
  <author>
    <name>Wilson He</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个普通程序猿的文章索引页</title>
    <link href="https://wilson-he.gitee.io/2020/03/13/hello-world/"/>
    <id>https://wilson-he.gitee.io/2020/03/13/hello-world/</id>
    <published>2020-03-13T02:36:50.140Z</published>
    <updated>2020-03-13T02:36:50.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK基础"><a href="#JDK基础" class="headerlink" title="JDK基础"></a>JDK基础</h1><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><details><summary>RocketMQ</summary><a href="https://wilson-he.gitee.io/2020/03/09/聊聊mq与如何基于spring%20boot%20RocketMQ搭建一个消息中心/">聊聊MQ与如何基于Spring Boot RocketMQ搭建一个消息中心</a></details>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDK基础&quot;&gt;&lt;a href=&quot;#JDK基础&quot; class=&quot;headerlink&quot; title=&quot;JDK基础&quot;&gt;&lt;/a&gt;JDK基础&lt;/h1&gt;&lt;h1 id=&quot;并发编程&quot;&gt;&lt;a href=&quot;#并发编程&quot; class=&quot;headerlink&quot; title=&quot;并发编程&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>谈谈个人对JDK函数式编程的认知与使用</title>
    <link href="https://wilson-he.gitee.io/2020/03/09/%E8%B0%88%E8%B0%88%E4%B8%AA%E4%BA%BA%E5%AF%B9JDK%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E8%AE%A4%E7%9F%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://wilson-he.gitee.io/2020/03/09/%E8%B0%88%E8%B0%88%E4%B8%AA%E4%BA%BA%E5%AF%B9JDK%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E8%AE%A4%E7%9F%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-09T09:22:21.000Z</published>
    <updated>2020-03-09T09:23:04.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>该文章主要介绍JDK中各种常见的函数式接口，并会附上一些个人对函数式编程的一些扩展思考与实际用法。</p><h1 id="常见的函数式接口介绍"><a href="#常见的函数式接口介绍" class="headerlink" title="常见的函数式接口介绍"></a>常见的函数式接口介绍</h1><p>jdk1.8的函数式接口都在rt.jar中<code>java.util.function</code>包下，以下以jdk集合类与个人常用的接口进行介绍：</p><ul><li><p><code>Function&lt;T,R&gt;</code>：传入类型为T的对象并执行含返回值(返回值为R-return类型)的指定方法，方法可临时实现。常见于类Optional<code>{map();flatMap();}</code>、Stream<code>{map();flatMap();}</code>、Comparator<code>{thenComparing();}</code>等，MybatisPlus 3.0版本之后的<code>SFunction</code>接口与该接口作用相同，区别在于添加了序列化，使开发者可通过传入getter Function匹配对应字段而无需再写字段名进行匹配，免除字段名写错的问题。</p></li><li><p><code>BiFunction&lt;T,U,R&gt;</code>：传入类型为T、U类型(T、U可以相同)的两个对象并执行含返回值的指定方法，方法可临时实现。常见于类Stream<code>{reduce();}</code>、Map<code>{replaceAll();computeIfPresent();compute();merge();}</code>等。</p></li><li><p><code>Consumer&lt;T&gt;</code>：传入单个对象并执行对象中无返回值的指定方法，方法可临时实现。常见于类List<code>{foreach();}</code>、Stream<code>{foreach();}</code>、Optional<code>{ifPresent();}</code>等。</p></li><li><p><code>BiConsumer&lt;T, U&gt;</code>：传入两个对象并执行对象中无返回值的指定方法，方法可临时实现。常见于类Stream<code>{collect();}</code>、Map<code>{foreach();}</code>等。</p></li><li><p><code>Supplier&lt;T&gt;</code>：供应商接口，可理解为对象的无参构造函数代理接口，每次调用其get()方法都会产生一个新的对象。常见于类Stream<code>{generate();collect();}</code>Objects<code>{requireNonNull();}</code>、ThreadLocal<code>{withInitial();}</code></p></li><li><p><code>Predicate&lt;T&gt;</code>：传入一个对象返回其指定行为方法执行结果布尔值，方法可临时实现。常见于类Optional<code>{filter();}</code>、Stream<code>{filter();anyMatch();allMatch();noneMatch();}</code>、ArrayList<code>{removeIf();}</code>等</p></li><li><p><code>BiPredicate&lt;T, U&gt;</code>：可根据前面的Bi接口与<code>Predicate</code>推断，不再多作阐述</p></li></ul><h1 id="常见的函数式接口用法"><a href="#常见的函数式接口用法" class="headerlink" title="常见的函数式接口用法"></a>常见的函数式接口用法</h1><p><strong>Stream中的函数式编程</strong></p><p>以下先以一段代码简单的介绍jdk中的函数式用法：</p><pre><code>List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);String result = list.stream()                .filter(str -&gt; !StringUtils.equals(str, &quot;c&quot;))   // ① 参数为Predicate&lt;? super String&gt;,返回值为Stream&lt;String&gt;                .map(str -&gt; str + &quot;,&quot;)   // ② 参数为Function&lt;? super String, ? extends String&gt;,返回值为Stream&lt;String&gt;                .reduce((current, next) -&gt; current + next) // ③ 参数为BinaryOperator&lt;String&gt;,返回值为Optional&lt;String&gt;                .orElse(&quot;&quot;);</code></pre><p>List转为Stream后Stream中的泛型都会对应为List元素的类型，以下为上面几个stream对象方法的简单讲解：<br>①：实现了一个<code>Predicate&lt;String&gt;</code>接口，并让Stream对象调用该接口的实现操作去过滤获取列表中元素值不为<code>&quot;c&quot;</code>的元素<br>②:  实现了一个<code>Function&lt;String,String&gt;</code>接口，在每个元素末尾添加字符串”,”，并返回添加后的结果<br>③： 实现了一个<code>BinaryOperator&lt;String&gt;</code>接口，将stream的当前元素与下一个元素进行拼接并返回拼接结果。<code>BinaryOperator&lt;T&gt;</code>是<code>BiFunction&lt;T,U,R&gt;</code>的子接口，在2个参数类型与返回类型都相同的情况下可使用BinaryOperator接口替代<code>BiFunction</code>接口，但两个接口实质上都需要实现apply()方法进行操作并返回结果，并无太大区别，可把<code>BinaryOperator</code>当<code>成BiFunction</code>的一个子集，其定义如下：</p><pre><code>@FunctionalInterfacepublic interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; {    ......}</code></pre><p>单看以上代码可能还无法体现出为什么叫函数式编程的原因，现在把以上代码还原为为函数实现显示样式：</p><pre><code>String result = list.stream()        .filter(new Predicate&lt;String&gt;() {            @Override            public boolean test(String s) {                return !StringUtils.equals(s, &quot;c&quot;);            }        })        .map(new Function&lt;String, String&gt;() {            @Override            public String apply(String s) {                return s + &quot;,&quot;;            }        })        .reduce(new BinaryOperator&lt;String&gt;() {            @Override            public String apply(String current, String next) {                return current + next;            }        })        .orElse(&quot;&quot;);</code></pre><p>两段的执行代码都可编译执行，对比可知第一段代码只是对第二段代码的简化，第二段代码中详细的显示了对列表转stream后的操作实现了哪些接口与实现的函数操作，显得十分臃肿，而第一段代码只显示了实现的函数操作，故个人认为将重点放在函数实现操作便是函数式编程的核心。<br>相信各个读者都发现了所有函数式接口所需实现的函数都有且仅有一个，个人认为目的除了更优雅的显示以外，还可以让程序知道即使我传入的是一个函数式接口实现类，程序依然会清楚它还要再去执行该类型的指定函数。</p><p><strong>List中的函数式编程</strong><br>List中含函数式接口参数的方法主要为foreach(Consumer)，遍历元素时将元素作为参数传入Consumer执行，最简单的例子为<code>list.forEach(System.out::println);</code>，调用System.out对象的println方法打印遍历的当前元素。</p><p><strong>Map中的函数式编程</strong><br>Map中个人常用的含函数式接口参数的方法主要为<code>foreach(BiConsumer&lt;? super K, ? super V&gt;)</code>和<code>compute(K,            BiFunction&lt;? super K, ? super V, ? extends V&gt;)</code>，其余的相信大家可以触类旁及。foreach为遍历当前map中的元素，前面介绍BiConsumer需要传入两个参数，而map.foreach()执行时每个key、value则作为参数传入到BiConsumer。虽然说需要传两个参数给BiConsumer，但不代表每个参数都必须用到，如下例中的BiConsumer只对每个val参数列表添加<code>“z”</code>字符串而没有用到key参数：</p><pre><code>Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();map.put(&quot;0&quot;, Lists.newArrayList(&quot;&quot;));map.put(&quot;1&quot;, Lists.newArrayList(&quot;a&quot;));map.put(&quot;2&quot;, Lists.newArrayList(&quot;a&quot;, &quot;b&quot;));map.put(&quot;3&quot;, Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));map.forEach((k,v) -&gt; v.add(&quot;z&quot;)); // ① 每个val列表末尾添加z字符串</code></pre><p>如果觉得有点难理解的可看以下函数还原代码：</p><pre><code>map.forEach(new BiConsumer&lt;String, List&lt;String&gt;&gt;() {   @Override    public void accept(String key, List&lt;String&gt; list) {        list.add(&quot;z&quot;);     }});</code></pre><p>Map的compute()方法根据名称大家也可以估到该方法是进行某些计算后再去设计key的值，可用于Map中指定key的值计算，在实际开发中个人常用于该情况：map的val为列表，map需要为指定key的val添加元素，添加前需判断val列表是否为空，为空则初始化后再添加，不为空则直接添加。</p><pre><code>map.compute(&quot;4&quot;,(key, list) -&gt; list == null ? Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) : ListUtils.add(list,&quot;z&quot;));</code></pre><p>以上代码判断map中key为4的列表是否为空，若为空则将map中key为4的val设为元素为<code>&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;</code>的列表，不为空则在原val列表中添加字符串<code>&quot;z&quot;</code>。其中ListUtils为自定义工具类，其add方法返回参数列表，便于一行代码实现目的，实现如下：</p><pre><code>public static &lt;T&gt; List&lt;T&gt; add(List&lt;T&gt; list, T t) {    list.add(t);    return list;}</code></pre><p>看了map.compute()的都知道该函数可以替代在操作map一些情况下的if判断，若把上面的<code>compute()</code>方法使用<code>if</code>执行，则将变成以下代码块：</p><pre><code>if(map.containsKey(&quot;4&quot;)){    map.get(&quot;4&quot;).add(&quot;z&quot;);}else {    map.put(&quot;4&quot;,Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));}</code></pre><p>可以看出适当的使用函数式编程可以为我们减少代码行。</p><p><strong>Optional简化if</strong><br>JDK1.8新增了Optional类使开发者可以减少if的语句块，类也含不少参数为函数式接口的方法，以下以一个简单的代码块进行介绍：</p><pre><code>Classify classify = new Classify();Optional.ofNullable(classify)        .map(Classify::getName)        .orElse(&quot;null&quot;);</code></pre><p>上例中把classify对象交给Optional代理，如果classify对象为空或classify对象中的name属性为空则返回字符串“null”，其中map的参数为Function。</p><p>看到这相信大家都了解到JDK中的函数式方法都是异曲同工，区别只在于在实际使用时泛型对应的实际类型。</p><h1 id="个人扩展用法"><a href="#个人扩展用法" class="headerlink" title="个人扩展用法"></a>个人扩展用法</h1><p>前面基本都是谈个人对函数式的认知与JDK原生类函数式参数方法的用法，而此处开始，是时候展现真正的技术了[doge]。函数式接口运用得当可以省略不少，下文将以几个个人实际开发中思考或使用过的例子进行函数式使用的思维拓展。</p><p>分类例子实体Classify：</p><pre><code>@Data@Accessors(chain = true)public class Classify {    private Long id;    private String name;    private Integer level;    private Long parentId;    private transient List&lt;Classify&gt; sonClassifies;}</code></pre><ul><li><h2 id="自定义ListUtils替代Stream的简单操作"><a href="#自定义ListUtils替代Stream的简单操作" class="headerlink" title="自定义ListUtils替代Stream的简单操作"></a>自定义ListUtils替代Stream的简单操作</h2></li></ul><p>现有一个<code>List&lt;Classify&gt;</code>的列表对象，现在需要将列表中所有分类的名字重新提取为一个列表，了解Stream会这样写：</p><pre><code>List&lt;String&gt; names = list.stream()        .map(Classify::getName)        .collect(Collectors.toList());</code></pre><p>又有一个需求需要将列表元素转化成key为id，value为name的映射，这时会写成如下：</p><pre><code>Map&lt;Long,String&gt; idNameMap =   list.stream()        .collect(Collectors.toMap(Classify::getId, Classify::getName));</code></pre><p>又又有一个需求需要将所有分类转换成key为parentId，value为子分类元素列表的映射，这时会写成如下：</p><pre><code>Map&lt;Long, List&lt;Classify&gt;&gt; parentSonsMap = list.stream()        .collect(Collectors.groupingBy(Classify::getParentId));</code></pre><p>以上写法都是比较普通的写法，应该任何人都可以接受，但我想这么简单的操作可不可以一行解决呢？也有部分开发者认为把所有stream方法调用放到同一行就可以了，但对我而言这会影响代码的可读性(虽然影响可能不大)。在开发者以上List转换的状况虽然不多，但也不算少，为了可一行代码取代Stream的简单操作，个人撸了一个List工具类放到了自己的通用框架中，通过Function作为参数取代Stream的简单操作，完整如下：</p><pre><code>public class ListUtils {    private ListUtils() {    }    public static &lt;T&gt; List&lt;T&gt; add(List&lt;T&gt; list, T t) {        list.add(t);        return list;    }    public static boolean isEmpty(Collection collection) {        return collection == null || collection.isEmpty();    }    public static boolean isNotEmpty(Collection collection) {        return !isEmpty(collection);    }    public static &lt;T&gt; ArrayList&lt;T&gt; newArrayList(T... elements) {        ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(elements.length + elements.length &gt;&gt; 1 + 5);        Collections.addAll(list, elements);        return list;    }    /**     * 条件为true时才添加元素     *     * @param condition  条件     * @param collection 集合     * @param val     * @return 添加结果     */    public static &lt;T&gt; boolean addIf(boolean condition, Collection&lt;T&gt; collection, T val) {        return condition &amp;&amp; collection.add(val);    }    /**     * 从对象列表中提取对象属性     *     * @param list      对象列表     * @param valGetter 对象属性get方法     * @param &lt;T&gt;       对象     * @param &lt;V&gt;       对象属性     * @return 对象属性列表     */    public static &lt;T, V&gt; List&lt;V&gt; collectToList(Collection&lt;T&gt; list, Function&lt;T, V&gt; valGetter) {        List&lt;V&gt; properties = new ArrayList&lt;&gt;(list.size());        list.forEach(e -&gt; properties.add(valGetter.apply(e)));        return properties;    }    /**     * 从对象列表中提取指定属性为key,当前对象为value转为map     *     * @param list     * @param keyGetter     * @param &lt;T&gt;     * @param &lt;K&gt;     * @return     */    public static &lt;T, K&gt; Map&lt;K, T&gt; collectToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter) {        Map&lt;K, T&gt; propertiesMap = new HashMap&lt;&gt;(list.size());        list.forEach(e -&gt; propertiesMap.put(keyGetter.apply(e), e));        return propertiesMap;    }    /**     * 从对象列表中提取指定属性T为key,属性V为value转为map     *     * @param list      对象列表     * @param keyGetter     * @param valGetter     * @param &lt;T&gt;     * @param &lt;K&gt;     * @param &lt;V&gt;     * @return     */    public static &lt;T, K, V&gt; Map&lt;K, V&gt; collectToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter, Function&lt;T, V&gt; valGetter) {        Map&lt;K, V&gt; propertiesMap = new HashMap&lt;&gt;(list.size());        list.forEach(e -&gt; propertiesMap.put(keyGetter.apply(e), valGetter.apply(e)));        return propertiesMap;    }    /**     * 根据列表对象中的某属性值为key划分列表,value为key的属性值相同的对象列表,     * 功能同stream().collect(Collectors.groupingBy())     *     * @param list     * @param keyGetter     * @param &lt;T&gt;     * @param &lt;K&gt;     * @return     */    public static &lt;T, K&gt; Map&lt;K, List&lt;T&gt;&gt; groupToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter) {        Map&lt;K, List&lt;T&gt;&gt; propertiesMap = new HashMap&lt;&gt;(list.size());        for (T each : list) {            propertiesMap.compute(keyGetter.apply(each),                    (key, valueList) -&gt; isEmpty(valueList) ? add(new ArrayList&lt;&gt;(list.size()), each) : add(valueList, each));        }        return propertiesMap;    }    /**     * 根据列表对象中的某属性值为key划分列表,value为key的属性值相同的对象列表,value为key的属性值相同的对象中指定属性的值列表,     * 功能同stream().collect(Collectors.groupingBy())     *     * @param list     * @param keyGetter     * @param valGetter     * @param &lt;T&gt;     * @param &lt;K&gt;     * @param &lt;V&gt;     * @return     */    public static &lt;T, K, V&gt; Map&lt;K, List&lt;V&gt;&gt; groupToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter, Function&lt;T, V&gt; valGetter) {        Map&lt;K, List&lt;V&gt;&gt; propertiesMap = new HashMap&lt;&gt;(list.size());        for (T each : list) {            K key = keyGetter.apply(each);            List&lt;V&gt; values = Optional.ofNullable(propertiesMap.get(key)).orElse(new ArrayList&lt;&gt;());            values.add(valGetter.apply(each));            propertiesMap.put(key, values);        }        return propertiesMap;    }    /**     * 获取列表中重复的值     *     * @param list     * @param &lt;T&gt;     * @return     */    public static &lt;T&gt; Set&lt;T&gt; collectRepeats(Collection&lt;T&gt; list) {        Set&lt;T&gt; set = new HashSet&lt;&gt;(list.size());        return list.stream()                .filter(e -&gt; !set.add(e))                .collect(Collectors.toSet());    }    /**     * 按指定大小，分隔集合，将集合按规定个数分为n个部分     *     * @param &lt;T&gt;     * @param list     * @param len     * @return     */    public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; splitList(List&lt;T&gt; list, int len) {        if (list == null || list.isEmpty() || len &lt; 1) {            return Collections.emptyList();        }        List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();        int size = list.size();        int count = (size + len - 1) / len;        for (int i = 0; i &lt; count; i++) {            List&lt;T&gt; subList = list.subList(i * len, ((i + 1) * len &gt; size ? size : len * (i + 1)));            result.add(subList);        }        return result;    }}</code></pre><p>看看使用该工具类替代Stream简单操作后的效果吧：</p><pre><code>List&lt;String&gt; namess = ListUtils.collectToList(list,Classify::getName);Map&lt;Long, String&gt; idMap = ListUtils.collectToMap(list,Classify::getId,Classify::getName);Map&lt;Long, List&lt;Classify&gt;&gt; parentSonsMap = ListUtils.groupToMap(list,Classify::getParentId);// 将List转化成key为parentId,value为子分类name列表的映射Map&lt;Long, List&lt;String&gt;&gt; parentSonNamesMap = ListUtils.groupToMap(list,Classify::getId,Classify::getName);</code></pre><p>可以看出通过函数式接口作为参数传递，不仅可以增加程序的可读性，还可以为我们的编码开发添加不少扩展性。</p><ul><li><h2 id="简化局部不同多处相同的代码块"><a href="#简化局部不同多处相同的代码块" class="headerlink" title="简化局部不同多处相同的代码块"></a>简化局部不同多处相同的代码块</h2></li></ul><p>局部不同多出相同的代码块重复出现的状况总会遇到，如一些业务代码前后都相同唯独中间不同，如DB连接-操作-释放、Ssh连接-操作-释放，以下将以一个ssh连接-操作-释放的代码来扩展函数式编程简化代码的用法。<br>可能会有人疑问ssh连接-操作-释放这样的实际操作业务不多吧？就在一段时间之前，上级让我去Zabbix查看各服务器的CPU、内存、磁盘使用率然后写入文档。看到机器数的我内心是拒接的，于是想出了使用java ssh连接到服务器执行相应的查看指令然后提取占用率打印到控制台上，再copy到文档中（反正得到了默许了）。以下是未优化前的两个查询方法：</p><pre><code>/** * 查询cpu占用率 */public static String cpuPercent(String ip, String username, String passw    JSch jsch = new JSch();    Session session = null;    Channel channel = null;    String cpuPercent = null;    try {        session = jsch.getSession(username, ip, 22);        Properties config = new Properties();        config.put(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);        session.setConfig(config);        session.setPassword(password);        session.connect();        String cmd = &quot;sar -u 3 1|awk &apos;{print $8}&apos;|tail -1&quot;;        channel = session.openChannel(&quot;exec&quot;);        ((ChannelExec) channel).setCommand(cmd);        ((ChannelExec) channel).setErrStream(System.err);        ((ChannelExec) channel).setPty(true);        channel.connect();        InputStream in = channel.getInputStream();        String output = IOUtils.toString(in, StandardCharsets.UTF_8);        cpuPercent = HUNDRED.subtract(BigDecimal.valueOf(Double.valueOf(                .setScale(2, RoundingMode.HALF_UP)                .toString() + &quot;%&quot;;    } catch (Exception e) {        e.printStackTrace();    } finally {        if (channel != null) {            channel.disconnect();        }        if (session != null) {            session.disconnect();        }    }    return cpuPercent;}/** * 磁盘占用率查询 */public static String diskPercent(String ip, String username, String pass    JSch jsch = new JSch();    Session session = null;    Channel channel = null;    String diskPercent = null;    try {        session = jsch.getSession(username, ip, 22);        Properties config = new Properties();        config.put(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);        session.setConfig(config);        session.setPassword(password);        session.connect();          String cmd = &quot;df -hl | grep apps|tail -1|awk &apos;{print $4}&apos;&quot;;        String cmd = &quot;df -hl | grep apps|tail -1|awk &apos;{print $5}&apos;&quot;;        channel = session.openChannel(&quot;exec&quot;);        ((ChannelExec) channel).setCommand(cmd);        ((ChannelExec) channel).setErrStream(System.err);        ((ChannelExec) channel).setPty(true);        channel.connect();        InputStream in = channel.getInputStream();        diskPercent = IOUtils.toString(in, StandardCharsets.UTF_8);    } catch (Exception e) {        e.printStackTrace();    } finally {        if (channel != null) {            channel.disconnect();        }        if (session != null) {            session.disconnect();        }    }    return diskPercent;}</code></pre><p>相信大家可以看出Ssh连接与释放的代码块是相同的，唯独操作是不同的，于是我把相同的代码块写入了一个方法中，操作的代码块作为参数，优化后的完整代码如下：</p><pre><code>public class SshClientUtils {    private static final BigDecimal HUNDRED = BigDecimal.valueOf(100);    private static final String RESULT_FORMAT = &quot;%s\t\t%s\t\t%s\t%s&quot;;    /**     * 执行查询cpu、mem、disk命令并打印各占用率     */    public static void exec(SshConfig sshConfig) {        System.err.println(&quot;cpu%\t\tmem%\t\tdisk\tip&quot;);        String username = sshConfig.getUsername();        String password = sshConfig.getPassword();        List&lt;String&gt; ipList = sshConfig.getIpList();        ipList.forEach(ip -&gt; {            String cpuPercent = cpuPercent(ip, username, password);            String memoryPercent = memoryPercent(ip, username, password);            String diskPercent = diskPercent(ip, username, password);            System.out.println(String.format(RESULT_FORMAT, cpuPercent, memoryPercent, diskPercent, ip)                    .replaceAll(&quot;\n|\r\n&quot;, &quot;&quot;));        });    }    /**     * 查询cpu占用率     */    public static String cpuPercent(String ip, String username, String password) {        String cmd = &quot;sar -u 3 1|awk &apos;{print $8}&apos;|tail -1&quot;;        return exec(ip, username, password, cmd, output -&gt; HUNDRED.subtract(BigDecimal.valueOf(Double.valueOf(output)))                .setScale(2, RoundingMode.HALF_UP)                .toString() + &quot;%&quot;);    }    /**     * 内存占用率查询     */    public static String memoryPercent(String ip, String username, String password) {        String cmd = &quot;free|grep Mem&quot;;        return exec(ip, username, password, cmd, output -&gt; {            String[] memories = output.replaceAll(&quot;\\s+&quot;, &quot;,&quot;)                    .substring(5)                    .split(&quot;,&quot;);            double total = Integer.parseInt(memories[0]);            double free = Integer.parseInt(memories[2]);            double buffers = Integer.parseInt(memories[4]);            double cache = Integer.parseInt(memories[5]);            BigDecimal freePercent = BigDecimal.valueOf((free + buffers + cache) / total)                    .setScale(6, RoundingMode.HALF_UP);            return BigDecimal.ONE.subtract(freePercent)                    .multiply(HUNDRED)                    .setScale(2, RoundingMode.HALF_UP)                    .toString() + &quot;%&quot;;        });    }    /**     * 磁盘占用率查询     */    public static String diskPercent(String ip, String username, String password) {        String cmd = &quot;df -hl | grep apps|tail -1|awk &apos;{print $5}&apos;&quot;;        return exec(ip, username, password, cmd, output -&gt; output);    }    /**     * 直接执行命令     */    public static String exec(String ip, String username, String password, String command, Function&lt;String, String&gt; execFunc) {        JSch jsch = new JSch();        Session session = null;        Channel channel = null;        try {            session = jsch.getSession(username, ip, 22);            Properties config = new Properties();            config.put(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);            session.setConfig(config);            session.setPassword(password);            session.connect();            channel = session.openChannel(&quot;exec&quot;);            ((ChannelExec) channel).setCommand(command);            ((ChannelExec) channel).setErrStream(System.err);            ((ChannelExec) channel).setPty(true);            channel.connect();            InputStream in = channel.getInputStream();            String output = IOUtils.toString(in, StandardCharsets.UTF_8);            return func.apply(execFunc);        } catch (Exception e) {            e.printStackTrace();        } finally {            if (channel != null) {                channel.disconnect();            }            if (session != null) {                session.disconnect();            }        }        return null;    }}</code></pre><p>可以看出优化的代码将Ssh的连接与操作都抽象到exec()方法中了，而实际操作则是由入参的Function实现决定，以上便是一个通过Function优化代码部分不同的例子。</p><p><strong>将if-set对象属性通过函数式接口放到对象内部执行</strong><br>话多不如实例，相信大家都遇到过类似以下这样的情况：</p><pre>if(condition1){    classify.setName("Wilson");}if(condition2){    classify.setLevel(5);}</pre><p>好麻烦，能不能再简单一点(我的简单永远没有上限)，现在先对以上代码块分析一下(简化的核心在于抽离)，相同的部分主要有if、classify，不同的部分为condition的值、set方法、set的值，既然有相同的就作为方法，不同的就作为参数吧(是不是跟ssh的例子想法差别不大吧)，于是我在Classify类中添加了以下方法：</p><pre><code>public &lt;V&gt; Classify set(boolean isSet, V value, BiFunction&lt;Classify, V, Classify&gt; setFunction) {    return isSet ? setFunction.apply(this, value) : this;}</code></pre><p>???<br>唔，这里可能有一些门槛，如果暂时不理解或觉得无法灵活运动的也不用着急，代码都是慢慢磨出来的，调用一下吧：</p><pre><code>Classify classify = new Classify();classify.set(true, &quot;Wilson&quot;, Classify::setName)        .set(false, 5, Classify::setLevel);System.out.println(classify);// 打印出Classify(id=null, name=Wilson, level=null, parentId=null, sonClassifies=null)</code></pre><p>由于Classify在类上添加了Lombok的注解<code>@Accessors(chain = true)</code>，所以每个set方法结果都会返回当前对象方便链式调用(我很喜欢链式)，所以上面的set方法可以直接返回apply(this,setFunction)的结果。BiFunction前面有提过是需要两个参数并返回一个结果的，在该例子中，由于Classify的setProperty()是返回当前对象的，所以不能用Function&lt;T,R&gt;作为set()的函数式参数(否则T与R都是Classify，无法设置属性)，Classify对象作为BiFunction的第一个参数，set()方法的value作为第二个参数，当前classify对象作为返回值，这样就可以保持我的对象可以继续链式调用各set方法。<br>也有会有人疑问set方法设置返回值不会影响程序的正常运行(如框架的调用)吗？这里个人是从反射与Java关键字void的角度思考过后就一直习惯使对象set方法返回当前对象了，这里希望大家也思考一下便不多作讲解了。</p><ul><li><h2 id="使用Supplier再提高一下copyProperties的逼格"><a href="#使用Supplier再提高一下copyProperties的逼格" class="headerlink" title="使用Supplier再提高一下copyProperties的逼格"></a>使用Supplier再提高一下copyProperties的逼格</h2><p>相信接触过Spring的都会使用过其中BeanUtils的<code>copyProperties()</code>方法，个人经常使用该方法进行VO属性到Model属性的设置，Model一般都是现场new所以内部属性都是的，反正都是空的何不再通过Supplier函数式接口扩展一下工具类提高一下逼格呢？于是便有了以下代码：</p><p>  @NoArgsConstructor<br>  public class ObjectUtils {</p><pre><code>public static &lt;S, T&gt; T copyProperties(S source, T target) {    BeanUtils.copyProperties(source, target);    return target;}public static &lt;S, T&gt; T copyProperties(S source, Supplier&lt;T&gt; targetSupplier) {    T target = targetSupplier.get();    BeanUtils.copyProperties(source, target);    return target;}</code></pre><p>  }</p></li></ul><p>再以一段Controller的伪代码演示一下:<br><code>Long id = classifyService.insert(ObjectUtils.copyProperties(classifyVO,Classify::new));</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;该文章主要介绍JDK中各种常见的函数式接口，并会附上一些个人对函数式编程的一些扩展思考与实际用法。&lt;/p&gt;
&lt;h1 id=&quot;常见的函数式接口
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://wilson-he.gitee.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ概念模型</title>
    <link href="https://wilson-he.gitee.io/2020/03/09/RocketMQ%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B/"/>
    <id>https://wilson-he.gitee.io/2020/03/09/RocketMQ%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-03-09T09:06:19.000Z</published>
    <updated>2020-03-10T06:03:14.021Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="RocketMQ主要由-Producer、Broker、Consumer、NameServer四部分组成"><a href="#RocketMQ主要由-Producer、Broker、Consumer、NameServer四部分组成" class="headerlink" title="RocketMQ主要由 Producer、Broker、Consumer、NameServer四部分组成"></a>RocketMQ主要由 Producer、Broker、Consumer、NameServer四部分组成</h5><ul><li>Producer 生产消息</li><li>Consumer 从Broker读取消费消息</li><li>Broker 存储Producer发送过来的消息</li><li>NameServer 为Producer或Consumer路由消息到Broker<br>Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。RocketMQ启动顺序为先NameServer，再Broker。</li></ul></blockquote><p><img src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/RocketMQ/Model.png" alt="Model.png"></p><ul><li><h3 id="Topic与Queue"><a href="#Topic与Queue" class="headerlink" title="Topic与Queue"></a>Topic与Queue</h3><p>Topic是一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。<br>在RocketMQ中Queue是组成Topic的更小单元，集群消费模式下一个消费者只消费该Topic中部分Queue中的消息，当一个消费者开启广播模式时则会消费该Topic下所有Queue中的消息。</p></li><li><h3 id="Broker-Server-代理服务器"><a href="#Broker-Server-代理服务器" class="headerlink" title="Broker Server(代理服务器)"></a>Broker Server(代理服务器)</h3><p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移(offset)和主题(Topic)和队列消息等。</p></li><li><h3 id="Name-Server-名字服务"><a href="#Name-Server-名字服务" class="headerlink" title="Name Server(名字服务)"></a>Name Server(名字服务)</h3><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p></li><li><h3 id="Producer-Group-生产者组"><a href="#Producer-Group-生产者组" class="headerlink" title="Producer Group(生产者组)"></a>Producer Group(生产者组)</h3><p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事物消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p></li><li><h3 id="Consumer-Group-消费者组"><a href="#Consumer-Group-消费者组" class="headerlink" title="Consumer Group(消费者组)"></a>Consumer Group(消费者组)</h3><p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：<em>集群消费（Clustering）</em> 和<em>广播消费（Broadcasting）</em>。</p></li><li><h3 id="Offset-Message-Queue下的offset"><a href="#Offset-Message-Queue下的offset" class="headerlink" title="Offset(Message Queue下的offset)"></a>Offset(Message Queue下的offset)</h3><ul><li>max offset<br>MessageQueue中的max offset在源码中表示指消息的最大offset+1，即下条消息入队的位置。</li><li>min offset<br>标识当前队列的最小offset。由于消息存储一段时间后，消费了的消息会从从磁盘物理删除，message queue的min offset也就对应增长，即比minOffset小的消息不存在broker上了。</li><li>consumer offset<br>Consumer Group在MessageQueue上的消息消费进度，其实际值为队列中消费了的消息数+1，即表示下次拉取消息的位置。<br>DefaultMQPushConsumer.setConsumeFromWhere(ConsumerFromWhere)可设置从哪开始消费消息，但该设置的优先级在offset store后，当从offset store中读取不到offset的时候，ConsumerFromWhere的设置才生效。大部分该设置在ConsumerGroup初次启动时才有效(启动会一般会存储offset)，即使Consumer正常运行时重启，依旧会接着上次的offset(从offset store中获取)开始消费，ConsumeFromWhere的设置无效。</li></ul></li><li><h3 id="Clustering-集群消费"><a href="#Clustering-集群消费" class="headerlink" title="Clustering(集群消费)"></a>Clustering(集群消费)</h3><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p></li><li><h3 id="广播消费-Broadcasting"><a href="#广播消费-Broadcasting" class="headerlink" title="广播消费(Broadcasting)"></a>广播消费(Broadcasting)</h3><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p></li><li><h3 id="Normal-Ordered-Message-普通顺序消息"><a href="#Normal-Ordered-Message-普通顺序消息" class="headerlink" title="Normal Ordered Message(普通顺序消息)"></a>Normal Ordered Message(普通顺序消息)</h3><p>普通顺序消费模式下，消费者通过同一个消费队列收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。<br>如Broker Server将消息Msg_A、Msg_B、Msg_C按顺序发送到Topic_A主题上的队列Q_A、Q_B、Q_A，Consumer_A从订阅的Topic_A拉去消息的顺序可能为下：</p><ul><li>Msg_A-&gt;Msg_B-&gt;Msg_C</li><li>Msg_B-&gt;Msg_A-&gt;Msg_C</li><li>Msg_A-&gt;Msg_C-&gt;Msg_B<br>Msg_B进入队列Q_A在Msg_A之后，所以Msg_B必然在接收到Msg_A后才被发送</li></ul></li><li><h3 id="Strictly-Ordered-Message-严格顺序消息"><a href="#Strictly-Ordered-Message-严格顺序消息" class="headerlink" title="Strictly Ordered Message(严格顺序消息)"></a>Strictly Ordered Message(严格顺序消息)</h3><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。如上例中Consumer_A收到的顺序只会是Msg_A-&gt;Msg_B-&gt;Msg_C</p></li><li><h3 id="Message-消息"><a href="#Message-消息" class="headerlink" title="Message(消息)"></a>Message(消息)</h3><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。常用属性：</p><ul><li>topic: 所属topic</li><li>tags: 消息标签，用来做服务端消息过滤。一个topic下可以有很多tags，一般都通过topic+tags来消费自己想要的结果。</li><li>keys: 消息关键词，查询消息使用</li><li>body: 消息内容</li></ul></li><li><h3 id="Tag-标签"><a href="#Tag-标签" class="headerlink" title="Tag(标签)"></a>Tag(标签)</h3><p>可理解为二级Topic，用于同一Topic下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一Topic下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子Topic的不同消费逻辑，实现更好的扩展性。</p></li><li><h2 id="各MQ产品对比（译自RocketMQ官方对比）"><a href="#各MQ产品对比（译自RocketMQ官方对比）" class="headerlink" title="各MQ产品对比（译自RocketMQ官方对比）"></a>各MQ产品对比（译自RocketMQ官方对比）</h2></li></ul><table><thead><tr><th></th><th>RocketMQ</th><th>Kafka</th><th>ActiveMQ</th></tr></thead><tbody><tr><td>客户端SDK</td><td>Java，C ++，Go</td><td>Java，Scala等</td><td>Java，.NET，C ++等</td></tr><tr><td>协议规范</td><td>拉模型，支持TCP，JMS，OpenMessaging</td><td>拉模型，支持TCP</td><td>推送模型，支持OpenWire，STOMP，AMQP，MQTT，JMS</td></tr><tr><td>消息排序</td><td>确保对消息进行严格排序，并可以正常扩展</td><td>确保分区内消息的顺序</td><td>排他消费者或排他队列可确保顺序</td></tr><tr><td>定时消息</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td>批量消息</td><td>支持，具有同步模式，可避免消息丢失</td><td>支持，带异步Producer</td><td>不支持</td></tr><tr><td>广播消息</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td>消息过滤器</td><td>支持，基于SQL92的属性过滤器表达式过滤</td><td>支持，使用kafka stream过滤</td><td>支持</td></tr><tr><td>服务器触发重新交付</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>消息存储</td><td>高性能和低延迟文件存储</td><td>高性能文件存储</td><td>使用JDBC和高性能日志（例如levelDB，kahaDB）存储支持非常快速持久性</td></tr><tr><td>消息追溯</td><td>支持时间戳和偏移量追溯</td><td>支持的偏移量追溯</td><td>支持</td></tr><tr><td>消息优先级</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>高可用与故障切换</td><td>支持主从模式</td><td>支持，需额外配置ZooKeeper服务器</td><td>支持，取决于存储，如果使用kahadb，则需要ZooKeeper服务器</td></tr><tr><td>消息追踪</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>配置特点</td><td>开箱即用，用户只需要注意一些配置</td><td>使用键值对格式进行配置，这些值可以从文件或以编程方式提供</td><td>默认配置为低级别，用户需要优化配置参数</td></tr><tr><td>操作管理工具</td><td>支持，Web控制台和终端命令都可操作管理</td><td>支持，使用终端命令管理</td><td>支持</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;RocketMQ主要由-Producer、Broker、Consumer、NameServer四部分组成&quot;&gt;&lt;a href=&quot;#RocketMQ主要由-Producer、Broker、Consumer、NameServer四部分组成&quot; c
      
    
    </summary>
    
    
      <category term="RocketMQ" scheme="https://wilson-he.gitee.io/categories/RocketMQ/"/>
    
    
      <category term="RocketMQ" scheme="https://wilson-he.gitee.io/tags/RocketMQ/"/>
    
      <category term="Spring Boot" scheme="https://wilson-he.gitee.io/tags/Spring-Boot/"/>
    
      <category term="Spring Cloud" scheme="https://wilson-he.gitee.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>聊聊MQ与如何基于Spring Boot RocketMQ搭建一个消息中心</title>
    <link href="https://wilson-he.gitee.io/2020/03/09/%E8%81%8A%E8%81%8Amq%E4%B8%8E%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Espring%20boot%20RocketMQ%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83/"/>
    <id>https://wilson-he.gitee.io/2020/03/09/%E8%81%8A%E8%81%8Amq%E4%B8%8E%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Espring%20boot%20RocketMQ%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83/</id>
    <published>2020-03-09T08:54:18.000Z</published>
    <updated>2020-03-13T05:59:21.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>在引入一项技术之前，首先必须清楚的是该技术可以为项目解决什么问题。个人在了解消息队列(Message Queue)之前，以为消息队列主是用于发送短信、邮件等消息发送(异步解耦)，但深入理解才发现自己的理解错了，MQ的作用不止体现在一些用户接收到的具体消息里，还可用于其它应用的数据发送、通用的业务处理等。<br>消息队列从字面上意思解读就是将消息存放到队列里，根据队列FIFO(先入先出)的特性进行消息消费。在实际开发中，是一种跨进程的通信机制，用于应用间的消息传递。 </p><h2 id="在引入MQ之前，需要了解的优缺点与应用场景"><a href="#在引入MQ之前，需要了解的优缺点与应用场景" class="headerlink" title="在引入MQ之前，需要了解的优缺点与应用场景"></a>在引入MQ之前，需要了解的优缺点与应用场景</h2><hr><p>MQ的主要优点为<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>，以下举一个简单的场景来反应这几个特性。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9rbm93bGVkZ2UtcGljdHVyZXMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL1JvY2tldE1RL01RJUU4JUFFJUEyJUU1JThEJTk1JUU0JUI4JTlBJUU1JThBJUExJUU2JUExJTg4JUU0JUJFJThCLnBuZw?x-oss-process=image/format,png" alt="MQ%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1%E6%A1%88%E4%BE%8B.png"></p><p>在微服务项目中，一般会根据核心业务进行系统的垂直拆分再进行单独部署。在上图中，各系统在下单业务里主要负责的内容如下：</p><ul><li>订单系统：创建订单，将下单消息(如订单id、用户数据)发送到MQ</li><li>MQ：限制每秒的订单请求处理数(如每秒接收2000个请求但数据库只能处理1000个则只处理1000个，处理不过来的先在消息队列里堆积)</li><li>物流系统：创建订单物流信息</li><li>积分系统：用户购物积分信息更新</li></ul><p>想象下以上场景没有MQ的的存在时创建订单流程中存在的问题：</p><ul><li>订单系统创建完订单信息后要去调用物流系统、积分系统上的业务接口，系统严重的<strong>耦合</strong>在一起(解耦)</li><li>订单系统若非通过线程去调用其它系统的接口，还需同步等待返回浪费不少时间(异步，避免创建线程调用的麻烦)</li><li>用户高峰期请求过多数据库处理不过来进而导致应用崩溃(削峰)</li></ul><p>任何事物都有两面性，虽然MQ可以给系统解决不少问题，但也会引入一些问题，如：</p><ul><li>系统复杂度提高，需要考虑消息重复消费、消息丢失等问题</li><li>数据一致性问题，如上例中的物流或库存系统写库出现异常如何回滚补偿</li></ul><p>了解了MQ的一些特性后，再讨论下几个适合使用MQ的场景：</p><ul><li>上游系统不关心下游的执行结果(如用户注册成功后用户系统通过MQ向用户发送邮件，但发送成不成功用户系统根本不在意)</li><li>依赖于数据的定时任务(如下单后24小时内不支付则取消订单，申请退款72小时内商家不处理则自动退款)</li></ul><h2 id="引入MQ后的一些问题解决思路"><a href="#引入MQ后的一些问题解决思路" class="headerlink" title="引入MQ后的一些问题解决思路"></a>引入MQ后的一些问题解决思路</h2><hr><ul><li><h3 id="消息重复消费-保证消息的幂等性"><a href="#消息重复消费-保证消息的幂等性" class="headerlink" title="消息重复消费(保证消息的幂等性)"></a>消息重复消费(保证消息的幂等性)</h3><blockquote><p>幂等性：对于同一操作的请求无论请求多少次结果都是一致的，在MQ中的具体体现为同一条消息无论发送都少次都会被消费一次。</p></blockquote><p>  由于网络抖动(延迟)的原因消息重复发送的问题是不可避免的，如果在消费端消费时没有做好消息的幂等性保证就有可能出现重复消费，导致同一条消息被多次消费、写库多次的情况。比较常见的做法是为消息添加一个唯一标识(ID)，在消费时根据ID查询数据库是否存在该消息记录，如果不存在再插入消息，存在则不进行插入消费。当生成与消费时间间隔不长时，可使用Redis提高消息幂等性的效率，如：</p><ol><li><p>消费者消费前根据ID去查询redis是否存在该消息</p></li><li><p>不存在该消息则消费并写入redis，存在该消息则不消费返回</p><p>关于消息ID：</p></li><li><p>RocketMQ的每条消息都会配有全局唯一的ID</p></li><li><p>如果消息中间件不会生成ID，可考虑一些ID服务(如雪花算法)生成全局唯一ID</p></li><li><p>建议ID不与实际业务关联</p></li></ol></li></ul><p>如目前个人工作中负责的消息中心应用是基于MongoDB+RocketMQ的技术架构，MongoDB负责存储各个应用发送过来的消息(主要为Sms、Email等)，每次消费前通过RocketMQ的Message ID查询Mongo保证消息幂等性避免重复消费，消费成功后更新DB中的消息状态。</p><ul><li><h3 id="消息丢失-消息的可靠性"><a href="#消息丢失-消息的可靠性" class="headerlink" title="消息丢失(消息的可靠性)"></a>消息丢失(消息的可靠性)</h3>  MQ各组件的消息丢失含义都有所不同，导致与解决方案也不一定相同，以kafka、rocket的消息传递模型(Producer-&gt;Broker-&gt;Consumer)为例：<ul><li>Producer：消息未持久化到Broker中，或消费者未能成功消费到消息。Kafka可通过更改ack配置解决，rocketMQ中会返回消息发送状态码。</li><li>Broker：消息成功传到到我这里了，可我因为某些原因(不同的MQ可能因机制问题有不同原因)弄丢了，如果是硬件原因(如宕机、磁盘损坏)建议你copy(集群部署)几个我</li><li>Consumer：我拿到了消息，但消费失败了或中途挂掉了没告诉Broker。可通过各MQ中间件的ACK机制解决。</li></ul></li></ul><h2 id="基于RocketMQ的简单例子技术框架与业务模型"><a href="#基于RocketMQ的简单例子技术框架与业务模型" class="headerlink" title="基于RocketMQ的简单例子技术框架与业务模型"></a>基于RocketMQ的简单例子技术框架与业务模型</h2><hr><p>以下便以一个基于MongoDB+RocketMQ+Eureka+Spring Cloud Config的技术框架并结合使用MQ中的问题搭建一个简单的消息中心项目案例，其中各组件在项目中的主要作用如下：</p><ul><li>Spring Cloud Config：消息配置(如topic、ConsumerGroup、ProducerGroup)中心。</li><li>Eureka：应用服务注册中心，负责项目中各服务的发现与提供调用。</li><li>MongoDB：由于消息的事务关系不强且Mongodb格式文档自由(json存储，随意增删字段)，所以使用Mongodb存储各个应用发送过来的消息(主要为Sms、Email等)，每次消费前通过RocketMQ的Message ID查询Mongo保证消息幂等性避免重复消费，消费成功后保存消息。</li><li>RocketMQ：消息接收、存储、发送。</li></ul><p>下图为该项目的应用关系模型：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9rbm93bGVkZ2UtcGljdHVyZXMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL1JvY2tldE1RL01RJUU2JUI2JTg4JUU2JTgxJUFGJUU1JUJBJTk0JUU3JTk0JUE4JUU2JUExJTg4JUU0JUJFJThCLnBuZw?x-oss-process=image/format,png" alt="MQ%E6%B6%88%E6%81%AF%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B.png"></p><p>消息中心应用：统一通用消息的业务处理应用，如短信发送、邮件发送、员工服务号推送等消息的处理<br>问卷应用：负责员工调查问卷的分发，在该例子中只是一个简单的消息发送测试应用<br>common：存放各应用通用类，如短信消息类(SmsMessage)、消息常量类<br>config-server-properties：配置中心的配置存放目录<br>由于该项目主要用于演示一些MQ的功能与使用中的问题解决方式，所以编码部分比较简单。</p><h2 id="应用例子编码"><a href="#应用例子编码" class="headerlink" title="应用例子编码"></a>应用例子编码</h2><ul><li><h3 id="通用模块编码-common"><a href="#通用模块编码-common" class="headerlink" title="通用模块编码(common)"></a>通用模块编码(common)</h3><p>通用模块主要存放各应用通用类(如实体、常量、配置、功能等)。<br>  <strong>MessageConstant：维护消息常量</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageConstant &#123;</span><br><span class="line"></span><br><span class="line">    interface System &#123;</span><br><span class="line">        String QUESTION &#x3D; &quot;QUESTION&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Topic &#123;</span><br><span class="line">        String SMS_TOPIC &#x3D; &quot;rocketmq.topic.sms&quot;;</span><br><span class="line">        String SMS_TOPIC_TEMPLATE &#x3D; &quot;$&#123;rocketmq.topic.sms&#125;&quot;;</span><br><span class="line">        String MAIL_TOPIC &#x3D; &quot;rocketmq.topic.mail&quot;;</span><br><span class="line">        String MAIL_TOPIC_TEMPLATE &#x3D; &quot;$&#123;rocketmq.topic.mail&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Producer &#123;</span><br><span class="line">        String SMS_GROUP_TEMPLATE &#x3D; &quot;$&#123;rocketmq.producer.group.sms&#125;&quot;;</span><br><span class="line">        String MAIL_GROUP_TEMPLATE &#x3D; &quot;$&#123;rocketmq.producer.group.mail&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Consumer &#123;</span><br><span class="line">        String SMS_GROUP_TEMPLATE &#x3D; &quot;$&#123;rocketmq.consumer.group.sms&#125;&quot;;</span><br><span class="line">        String MAIL_GROUP_TEMPLATE &#x3D; &quot;$&#123;rocketmq.consumer.group.mail&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>BaseMessage：基础消息类，所用的通用消息都需继承此类方便统一信息的管理</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Accessors(chain &#x3D; true)</span><br><span class="line">public abstract class BaseMessage implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 消息源系统:&#123;@link io.wilson.common.message.constant.MessageConstant.System&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String system;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>SmsMessage：通用短信消息类，短信内容数据载体</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@EqualsAndHashCode(callSuper &#x3D; true)</span><br><span class="line">@Data</span><br><span class="line">@Accessors(chain &#x3D; true)</span><br><span class="line">@ToString(callSuper &#x3D; true)</span><br><span class="line">public class SmsMessage extends BaseMessage &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 短信创建用户</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String createUserId;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 接收短信用户</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String toUserId;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 手机号码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String mobile;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 短信内容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="消息中心应用-message-center"><a href="#消息中心应用-message-center" class="headerlink" title="消息中心应用(message-center)"></a>消息中心应用(message-center)</h3><p>  消息中心在进行编码之前，需确认消息中心该如何进行消息的处理。该项目所处的业务环境是各应用可能都需要发送一些短信消息、邮件、服务号消息等，相同消息的业务处理是一致的，所以消息中心对消息接收消费的主要流程如下：</p><ul><li>保证消息幂等性(查询数据库使用已有消息记录避免重复消费)</li><li>消息业务处理</li><li>消息日志入库</li></ul><p>在该项目中，不同的消息类型存储在不同的Mongodb collection(同Mysql table概念)，但共用一个消息日志类MessageLog：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Accessors(chain &#x3D; true)</span><br><span class="line">public class MessageLog implements Serializable &#123;</span><br><span class="line">    private String msgId;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送方系统名称 &#123;@link io.wilson.common.message.constant.MessageConstant&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String system;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 消息对象json字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String msgContent;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 业务执行结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Boolean success;</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 初始化消息记录</span><br><span class="line">     *</span><br><span class="line">     * @param message       消息</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T extends BaseMessage&gt; MessageLog convertFromMessage(T message) &#123;</span><br><span class="line">        LocalDateTime now &#x3D; LocalDateTime.now();</span><br><span class="line">        return new MessageLog()</span><br><span class="line">                .setSystem(message.getSystem())</span><br><span class="line">                .setSuccess(false)</span><br><span class="line">                .setCreateTime(now)</span><br><span class="line">                .setUpdateTime(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在该消费流程设计与开发编码过程中个人考虑的核心点如下：</p><ol><li>如果使用普通消息类(如SmsMessage)作为db存储的映射对象，会导致消息类掺杂不必要的属性(如createTime、updateTime、success)，且作为一个通用的消息数据载体，普通消息类更适于作为一个VO而非DO使用，所以消息的处理结果、消息的创建更新时间这些作为原消息上的附加内容，更适合放到其它数据库映射对象中维护，所以定义了MessageLog作为消息记录的实体类</li><li>既然是作为各应用都可使用的通用消息所以肯定都会有一定数据量，虽然映射实体都一样，但存放到不同的collection可以提高操作的便捷性和获得更好的性能，系统编码可以更好地根据系统进行消息筛选</li><li>在消息消费流程中，保证消息幂等性和消息日志入库这两步只有数据库名是不同的，所以可定义一个父Listener进行消息监听消费的方法抽象，不同消息的业务处理交给不同的消息Service，同一类消息的消费可能会再细分调用不同的消息业务方法消费(如发送单条短信、批量发送短信)，所以可以对各service抽象出一个consume()方法根据参数调用具体的service业务方法进行消息消费</li></ol><ul><li><h4 id="消息中心类图与消费流程图"><a href="#消息中心类图与消费流程图" class="headerlink" title="消息中心类图与消费流程图"></a>消息中心类图与消费流程图</h4><p>为了更好地展示消息中心中类之间的关系，描绘以下类图：<br> <img src="https://img-blog.csdnimg.cn/20200309131427286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oyODEyNjMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">      </p><p>当一条短信消息发送到消息中心时，其消费流程如下图：<br><img src="https://img-blog.csdnimg.cn/20200309131600757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oyODEyNjMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><h4 id="消息业务处理编码"><a href="#消息业务处理编码" class="headerlink" title="消息业务处理编码"></a>消息业务处理编码</h4><p>  <strong>BaseMessageService：消息业务消费抽象接口，抽象每个消费者(Listener)调用的业务消费方法</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface BaseMessageService&lt;T extends BaseMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 消费消息</span><br><span class="line">     *</span><br><span class="line">     * @param message         消息</span><br><span class="line">     * @param consumeFunction 消费方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    default boolean consume(T message, Function&lt;T, Boolean&gt; consumeFunction) &#123;</span><br><span class="line">        return consumeFunction.apply(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>BaseMessageService：短信消息业务抽象接口</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public interface SmsMessageService extends BaseMessageService&lt;SmsMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送单条短信消息</span><br><span class="line">     *</span><br><span class="line">     * @param smsMessage</span><br><span class="line">     * @return 业务处理结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean sendSingle(SmsMessage smsMessage);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>SmsMessageServiceImpl：短信消息业务实现类</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class SmsMessageServiceImpl implements SmsMessageService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean sendSingle(SmsMessage smsMessage) &#123;</span><br><span class="line">        &#x2F;&#x2F; 短信业务操作结果</span><br><span class="line">        boolean isSuccess &#x3D; true;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 短信业务操作并把操作结果设到isSuccess中</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (Objects.equals(smsMessage.getToUserId(), &quot;Wilson&quot;)) &#123;</span><br><span class="line">            isSuccess &#x3D; false;</span><br><span class="line">            log.info(&quot;短信发送失败,消息内容:&#123;&#125;&quot;, smsMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        return isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="消息业务处理编码-1"><a href="#消息业务处理编码-1" class="headerlink" title="消息业务处理编码"></a>消息业务处理编码</h4><p>  <strong>MessageLogConstant：维护MessageLog的相关常量(如不同消息的collection名)</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageLogConstant &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 各消息日志Mongo集合名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    interface CollectionName &#123;</span><br><span class="line">        String SMS &#x3D; &quot;sms_message_log&quot;;</span><br><span class="line">        String MAIL &#x3D; &quot;mail_message_log&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>AbstractMQStoreListener：保证消息幂等性、消息日志入库操作的抽象Listener类方法中</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public abstract class AbstractMQStoreListener &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    protected MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断消息是否已被消费</span><br><span class="line">     *</span><br><span class="line">     * @param msgId</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean isConsumed(String msgId) &#123;</span><br><span class="line">        long count &#x3D; mongoTemplate.count(new Query(Criteria.where(&quot;msg_id&quot;).is(msgId)), collection());</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            log.info(&quot;消息&#123;&#125;已成功消费过，请勿重复投递!&quot;, msgId);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前消息的mongo collection名:&#123;@link io.wilson.message.domain.constant.MessageLogConstant.CollectionName&#125;</span><br><span class="line">     *</span><br><span class="line">     * @return 当前消息存储的collection名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected abstract String collection();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 保存消息消费记录</span><br><span class="line">     *</span><br><span class="line">     * @param success 业务执行结果</span><br><span class="line">     * @param msgId   消息id</span><br><span class="line">     * @param message</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void store(boolean success, String msgId, BaseMessage message) &#123;</span><br><span class="line">        MessageLog messageLog &#x3D; MessageLog.convertFromMessage(message)</span><br><span class="line">                .setMsgId(msgId)</span><br><span class="line">                .setMsgContent(JSONObject.toJSONString(message))</span><br><span class="line">                .setSuccess(success);</span><br><span class="line">        mongoTemplate.insert(messageLog, collection());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>SmsMessageListener:短信消息监听器(消费者)，如在消费过程中抛出异常，RocketMQ会以一定的时间间隔进行重新投递消费</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">@ConditionalOnProperty(MessageConstant.Topic.SMS_TOPIC)</span><br><span class="line">@RocketMQMessageListener(topic &#x3D; MessageConstant.Topic.SMS_TOPIC_TEMPLATE, consumerGroup &#x3D; MessageConstant.Consumer.SMS_GROUP_TEMPLATE)</span><br><span class="line">public class SmsMessageListener extends AbstractMQStoreListener implements RocketMQListener&lt;MessageExt&gt; &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private SmsMessageService smsMessageService;</span><br><span class="line">    private static final String EXCEPTION_FORMAT &#x3D; &quot;短信消息消费失败，消息内容：%s&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(MessageExt message) &#123;</span><br><span class="line">        String msgId &#x3D; message.getMsgId();</span><br><span class="line">        if (isConsumed(msgId)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        SmsMessage smsMessage &#x3D; JSONObject.parseObject(message.getBody(), SmsMessage.class);</span><br><span class="line">        log.info(&quot;接收到短信消息&#123;&#125;：&#123;&#125;&quot;, msgId, smsMessage);</span><br><span class="line">        &#x2F;*if (Objects.equals(smsMessage.getToUserId(), &quot;2020&quot;)) &#123;</span><br><span class="line">            log.error(&quot;消息&#123;&#125;消费失败&quot;, message.getMsgId());</span><br><span class="line">            &#x2F;&#x2F; 抛出异常让RocketMQ重新投递消息重新消费</span><br><span class="line">            throw new MQConsumeException(String.format(EXCEPTION_FORMAT, smsMessage));</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line">        boolean isSuccess &#x3D; smsMessageService.consume(smsMessage, smsMessageService::sendSingle);</span><br><span class="line">        if (!isSuccess) &#123;</span><br><span class="line">            log.info(&quot;短信消息业务操作失败,消息id: &#123;&#125;&quot;, msgId);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 保存消息消费记录</span><br><span class="line">        store(isSuccess, msgId, smsMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String collection() &#123;</span><br><span class="line">        return MessageLogConstant.CollectionName.SMS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>MessageCenterApplication:主程序</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class MessageCenterApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MessageCenterApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>Spring Cloud配置文件bootstrap.yml</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8000&#x2F;eureka</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: config-center</span><br><span class="line">      #     资源文件名</span><br><span class="line">      profile: dev</span><br><span class="line">      name: rocketmq</span><br></pre></td></tr></table></figure><p>  <strong>SmsSendTest：单元测试类</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(classes &#x3D; MessageCenterApplication.class)</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">public class SmsSendTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line">    @Value(MessageConstant.Topic.SMS_TOPIC_TEMPLATE)</span><br><span class="line">    private String smsTopic;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void sendSms() &#123;</span><br><span class="line">        SmsMessage smsMessage &#x3D; new SmsMessage();</span><br><span class="line">        smsMessage.setToUserId(&quot;13211&quot;)</span><br><span class="line">                .setMobile(&quot;173333222&quot;)</span><br><span class="line">                .setContent(&quot;测试短信消息&quot;)</span><br><span class="line">                .setSystem(MessageConstant.System.QUESTION);</span><br><span class="line">        rocketMQTemplate.send(smsTopic, MessageBuilder.withPayload(smsMessage).build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h3 id="配置中心-config-server"><a href="#配置中心-config-server" class="headerlink" title="配置中心(config-server)"></a>配置中心(config-server)</h3><p>主程序ConfigServerApplication</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableConfigServer</span><br><span class="line">public class ConfigServerApplication &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Cloud配置文件bootstrap.yml:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:&#x2F;&#x2F;gitee.com&#x2F;Wilson-He&#x2F;rocketmq-message-center-demo.git</span><br><span class="line">          username: Wilson-He</span><br><span class="line">          force-pull: true</span><br><span class="line">          password:</span><br><span class="line">          # 配置文件在uri下的目录</span><br><span class="line">          search-paths: &#x2F;config-server-properties</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8000&#x2F;eureka</span><br></pre></td></tr></table></figure><p>配置文件configs-server-properties/rocketmq-dev.properties:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.name-server&#x3D;127.0.0.1:9876</span><br><span class="line">rocketmq.topic.sms&#x3D;sms-topic</span><br><span class="line">rocketmq.producer.group.sms&#x3D;sms-group</span><br><span class="line">rocketmq.consumer.group.sms&#x3D;sms-group</span><br><span class="line">rocketmq.topic.mail&#x3D;mail-topic</span><br><span class="line">rocketmq.producer.group.mail&#x3D;mail-group</span><br><span class="line">rocketmq.consumer.group.mail&#x3D;mail-group</span><br></pre></td></tr></table></figure></li></ul><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><ol><li>运行RocketMQ name-server与broker,如<code>mqnamesrv -n 127.0.0.1:9876</code>,<code>mqbroker -n 127.0.0.1:9876</code></li><li>运行eureka应用</li><li>运行配置中心config-server</li><li>运行消息中心message-center</li><li>运行message-center单元测试类(SmsSendTest)或运行question-app访问<code>localhost:8080/question/toUser?userId=xxx</code>进行消费测试，消息中心控制台打印出日志信息与Mongo sms_message_log成功新增了数据即项目搭建完成<br><img src="https://img-blog.csdnimg.cn/20200309131857721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oyODEyNjMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200309131930100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oyODEyNjMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><p><strong>(待)扩展点：</strong></p><ol><li>RocketMQ的发送者应用可在配置文件中设置rocketmq.producer.retry-times-when-send-failed/retry-times-when-send-async-failed属性配置rocketmq同步/异步发送消息失败后的重试次数，不设置则默认都为2</li><li>当业务执行操作结果失败时仍然入库的原因是有时业务执行过程中可能会包含调用第三方的操作，当第三方报错时会导致业务操作结果失败，而第三方的操作是不可控的，所以先把报错结果保存便于追溯，且有业务需要时也可通过定时任务查库重新执行业务</li><li>该例子中只用了一个消息配置文件，实际开发中消息配置需根据项目所需配置到对应的项目配置文件，如question-app的消息配置(如topc、producerGroup)应在其项目中的配置文件(如application.yml、apollo的namespace)中配置</li><li>该项目中的NameServer、Broker并没有集群部署，Broker集群部署后配置同步双写避免主机写入后尚未同步到从机就宕机导致消息丢失的情况(有意向的自行百度：RocketMQ 同步双写)</li></ol><h2 id="末"><a href="#末" class="headerlink" title="末"></a>末</h2><p>该文章通过一个简单的项目例子演示了使用Spring Boot RocketMQ处理MQ常见问题的一些方式：</p><ul><li>消息重复消费问题可通过数据库存储来保证幂等性</li><li>若消息消费业务操作失败时可通过Listener抛出异常让RocketMQ重新投递消息进行消费</li></ul><p><a href="https://github.com/Wilson-He/rocketmq-message-center-demo" target="_blank" rel="noopener">项目源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在引入一项技术之前，首先必须清楚的是该技术可以为项目解决什么问题。个人在了解消息队列(Message Queue)之前，以为消息队
      
    
    </summary>
    
    
      <category term="RocketMQ" scheme="https://wilson-he.gitee.io/categories/RocketMQ/"/>
    
      <category term="Spring Boot" scheme="https://wilson-he.gitee.io/categories/RocketMQ/Spring-Boot/"/>
    
    
      <category term="RocketMQ" scheme="https://wilson-he.gitee.io/tags/RocketMQ/"/>
    
      <category term="Spring Boot" scheme="https://wilson-he.gitee.io/tags/Spring-Boot/"/>
    
  </entry>
  
</feed>
