<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wilson Blog</title>
  
  <subtitle>一名普通的搬砖工</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wilson-he.gitee.io/"/>
  <updated>2020-06-04T02:23:06.892Z</updated>
  <id>https://wilson-he.gitee.io/</id>
  
  <author>
    <name>Wilson He</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础</title>
    <link href="https://wilson-he.gitee.io/basic-java/"/>
    <id>https://wilson-he.gitee.io/basic-java/</id>
    <published>2020-06-04T02:23:06.890Z</published>
    <updated>2020-06-04T02:23:06.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象编程的三大特性"><a href="#面向对象编程的三大特性" class="headerlink" title="面向对象编程的三大特性"></a>面向对象编程的三大特性</h2><hr><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>将对象不需要让外界访问的成员变量和方法私有化，只提供符合开发者意愿的公有方法来访问这些数据和逻辑，保证了数据的安全和程序的稳定。<br>java通过权限修饰符来控制类成员的访问权限，各修饰符的访问权限如下：</p><table><thead><tr><th>修饰符</th><th>当前类</th><th>同一个包</th><th>子类</th><th>其它</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是指从已有的类中派生出新的类，新的类拥有父类非私有的属性与方法。继承的类叫做子类（派生类），被继承的类叫做父类（超类或者基类）。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。多态的优点：</p><ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul><p>在Java中多态的两种主要形式：<strong>继承(多个子类对同一方法的重写)</strong>和<strong>实现(接口实现)</strong></p><h2 id="Java的基本数据类型"><a href="#Java的基本数据类型" class="headerlink" title="Java的基本数据类型"></a>Java的基本数据类型</h2><hr><table><thead><tr><th>数据类型</th><th>boolean</th><th>byte</th><th>char</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>bit</td><td>32</td><td>8</td><td>16</td><td>16</td><td>32</td><td>64</td><td>64</td><td>64</td></tr><tr><td>最小值</td><td>-</td><td>-2^7</td><td>-2^15</td><td>-2^15</td><td>-2^31</td><td>-2^63</td><td>-2^63</td><td>-2^63</td></tr><tr><td>最大值</td><td>-</td><td>2^7-1</td><td>2^15-1</td><td>2^15-1</td><td>2^31-1</td><td>2^63-1</td><td>2^63-1</td><td>2^63-1</td></tr><tr><td>包装类型</td><td>Boolean</td><td>Byte</td><td>Character</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td></tr></tbody></table><p>基本类型的两条准则：</p><ul><li>对整型数据不指定类型默认为int类型，浮点数默认为double类型</li><li>基本数据类型从小(字节)到大可以自动转换，从大到小需要进行类型强制转换(cast)</li></ul><blockquote><p>boolean类型会在编译时期被JVM转换为int,true为常量值1,false为0,如<code>boolean a = true;</code>查看字节码(javap -verbose xxx.class)会发现iconst_1指令，是指把int常量值1压入栈中，因此boolean需要4个字节进行存储。使用int的原因是对于当下32位的处理器（CPU）来说，一次处理数据是32位。而boolean数组会被编译为byte数组，故作为数组时，数组中的每个boolean元素只占一个字节。</p></blockquote><p>基本类型都有对应的包装类型，且对应的包装类型都被final标识，不可被继承。基本类型与包装类型之间的转换自动装箱与拆箱完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; 5; &#x2F;&#x2F; 装箱调用Integer.valueOf(2)</span><br><span class="line">int b &#x3D; a; &#x2F;&#x2F; 拆箱调用Integer.intValue()</span><br></pre></td></tr></table></figure><p>在 Java 8 中，大部分基本类型都有缓存值，如Integer通过其内部类IntegerCache的cache[]缓存了-128~127范围值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Cache to support the object identity semantics of autoboxing for values between</span><br><span class="line"> * -128 and 127 (inclusive) as required by JLS.</span><br><span class="line"> *</span><br><span class="line"> * The cache is initialized on first usage.  The size of the cache</span><br><span class="line"> * may be controlled by the &#123;@code -XX:AutoBoxCacheMax&#x3D;&lt;size&gt;&#125; option.</span><br><span class="line"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="line"> * may be set and saved in the private system properties in the</span><br><span class="line"> * sun.misc.VM class.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low &#x3D; -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用装箱方式初始化Integer时，若初始值是在缓存范围内，则会引用缓存范围内的对象。从上源码注释可以看出，Integer可以通过在启动jvm时添加<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>设置其缓存大小，但其它基本类型是没有相应的设置方式的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; 5;</span><br><span class="line">Integer b &#x3D; 5;</span><br><span class="line">System.out.println(a&#x3D;&#x3D;b); &#x2F;&#x2F;true</span><br><span class="line">b &#x3D; new Integer(5); &#x2F;&#x2F; 为5分配了新的空间，所以与缓存5的空间地址不同</span><br><span class="line">System.out.println(a&#x3D;&#x3D;b); &#x2F;&#x2F;false</span><br><span class="line">a &#x3D; 255;</span><br><span class="line">b &#x3D; 255;</span><br><span class="line">System.out.println(a&#x3D;&#x3D;b); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>各基本类型对应包装类型的缓存池值(Double、Float没有缓存)如下：</p><ul><li>Boolean: 通过字段缓存true，false</li><li>Byte：内部类ByteCache缓存所有字节(-127-128)</li><li>Short：内部类ShortCache缓存-127-128</li><li>Integer：内部类IntegerCache缓存-127-128</li><li>Long：内部类LongCache缓存-127-128</li><li>Character:内部类CharacterCache缓存0~127对应的ASCII码字符值</li></ul><p><strong>运算小题目</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a &#x3D; &#39;a&#39;; &#x2F;&#x2F; &#39;a&#39;的ASCII码为97</span><br><span class="line">int b &#x3D; 13;</span><br><span class="line">long e &#x3D; a + d;</span><br></pre></td></tr></table></figure><p>那么问题来了，e是多少呢？运算过程中类型是怎么转换的呢？请务必让我根据下图一一讲解：<br><img src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/hexo-blog/Java%E5%9F%BA%E7%A1%80/%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="%E5%AD%97%E8%8A%82%E7%A0%81.png"><br>(上图为在类编译结果目录target/pagkage执行javap -verbose Test显示的字节码)</p><ol><li>bipush将a转换为int值(‘a’对应的ASCII码值)入栈,istore_1取出栈顶int值(即a值)保存到局部变量1中</li><li>bipush将b(b本身为int，无需转换)入栈,istore_2取出栈顶int值(即b值)保存到局部变量2中</li><li>iload_1、iload_2将局部变量1、2的int类型值入栈,iadd将栈顶的2个int值相加，并将结果压栈,i2l将int转long(不是i2十一哦)，然后lstore_3将栈顶long值保存到局部变量3中</li></ol><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><hr><p>java的引用类型只有三种，分别是<strong>类(class)</strong>、<strong>接口(interface)</strong>、<strong>数组</strong>。当某一引用数据内容在其中一个作用域被改变时，其它作用域中该引用数据内容也会发生改变。<br>JVM内存区域主要为堆和栈，栈可以说是方法执行的内存模型，当在方法里定义一个变量时，栈就会为该变量分配内存空间，当超出变量的作用域时，其分配的栈空间就会被释放。栈的存取速度比堆要快，仅次于寄存器，但存在栈中的数据大小与生存期必须是确定的，故Java的8种基本数据类型和对象引用变量都是存放在栈中(设想下若对象存放到栈中，那么传对象参数时每传递到一个方法就会导致上一个方法对对象的回收，导致含一定大小的内存回收频繁降低程序性能，故使用堆存放对象)。<br>堆是所有的对象实例以及数组分配内存的运行时数据区域，即使对象已经没有在任何地方被引用了占用的空间也不会马上被释放，而是等到触发某些条件(如手动调用System.gc()、新生代空间不足、老年代空间不足等)才会被回收器回收。</p><p>引用测试例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array &#x3D; new int[]&#123;1, 2, 3&#125;;</span><br><span class="line">        changeArray(array);</span><br><span class="line">        System.out.println(array[0]); &#x2F;&#x2F; 输出：11</span><br><span class="line">        Integer integer &#x3D; new Integer(5);</span><br><span class="line">        changeInteger(integer);</span><br><span class="line">        System.out.println(integer); &#x2F;&#x2F; 输出：5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void changeArray(int[] array) &#123;</span><br><span class="line">        array[0] &#x3D; 11;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void changeInteger(Integer integer) &#123;</span><br><span class="line">        integer &#x3D; 10; &#x2F;&#x2F; integer &#x3D; Integer.valueOf(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void changeStr(String str) &#123;</span><br><span class="line">        str &#x3D; &quot;xxx&quot;; &#x2F;&#x2F; str &#x3D; String.valueOf(&quot;xxx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><hr><h3 id="final：常量关键字"><a href="#final：常量关键字" class="headerlink" title="final：常量关键字"></a>final：常量关键字</h3><ul><li>数据：声明数据为常量，可以是编译时常量，也可以是在运行被初始化后不能被改变的常量。<ul><li>对于基本类型，final使数值不变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final a &#x3D; 1;</span><br><span class="line">a &#x3D; 2; &#x2F;&#x2F; cannot assign value to final variable &#39;a&#39;</span><br></pre></td></tr></table></figure></li><li>对于引用类型，final使引用不变，即不能引用其它对象，但是被引用的对象本身内容是可以被修改的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final String str &#x3D; &quot;b&quot;;</span><br><span class="line">str &#x3D; &quot;c&quot;; &#x2F;&#x2F; cannot assign value to final variable &#39;str&#39;</span><br></pre></td></tr></table></figure></li></ul></li><li>方法：声明方法不能被子类重写，private方法隐式地被指定为final。</li><li>类：声明类不允许被继承。</li></ul><h3 id="static：静态关键字"><a href="#static：静态关键字" class="headerlink" title="static：静态关键字"></a>static：静态关键字</h3><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>又称类变量，表示变量属于类(Class对象)的。静态变量在内存中只存在一份，在类的所有实例对象都共享静态变量，可以直接通过类名来访问它，静态变量在内存中只存在一份。</p><ul><li>实例变量：实例对象内非static标识的的属性变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line"></span><br><span class="line">    private int x;         &#x2F;&#x2F; 实例变量</span><br><span class="line">    private static int y;  &#x2F;&#x2F; 静态变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法在类加载阶段初始化，不依赖于任何实例对象，所以静态方法不能是抽象方法，也不能通过this调用静态方法。</p><h4 id="标识代码块：静态语句块"><a href="#标识代码块：静态语句块" class="headerlink" title="标识代码块：静态语句块"></a>标识代码块：静态语句块</h4><p>静态语句块只会在类(Class)初始化时运行一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;123&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a1 &#x3D; new A();</span><br><span class="line">        A a2 &#x3D; new A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>非静态内部类依赖于外部类的实例，即需先创建外部类实例，才能用这个实例去创建非静态内部类，而静态内部类不需创建外部类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line"></span><br><span class="line">    class InnerClass&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OuterClass outerClass &#x3D; new OuterClass();</span><br><span class="line">        &#x2F;&#x2F; InnerClass innerClass &#x3D; new InnerClass(); &#x2F;&#x2F; cannot be referenced  from a static context</span><br><span class="line">        InnerClass ic &#x3D; outerClass.new InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类初始化顺序"><a href="#类初始化顺序" class="headerlink" title="类初始化顺序"></a>类初始化顺序</h4><ol><li>父类静态变量-&gt;静态代码块</li><li>子类静态变量-&gt;静态代码块</li><li>父类实例变量-&gt;普通代码块-&gt;父类构造函数</li><li>子类实例变量-&gt;子类代码块-&gt;子类构造函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon &#123;</span><br><span class="line">    public static int count1;  &#x2F;&#x2F; 连接-准备阶段-1.1 count1 &#x3D; 0</span><br><span class="line">    public static int count2 &#x3D; 1; &#x2F;&#x2F; 连接-准备阶段-1.2 count2 &#x3D; 1</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.4 连接-准备阶段 count1 &#x3D; 2</span><br><span class="line">        System.out.println(&quot;static block count2:&quot; + count2); &#x2F;&#x2F; 1.4 count2&#x3D;2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SingleTon() &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.3.1 连接-准备阶段 count1 &#x3D; 1</span><br><span class="line">        count1++;</span><br><span class="line">        &#x2F;&#x2F; 1.3.2 连接-准备阶段 count1 &#x3D; 2</span><br><span class="line">        count2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(count1);</span><br><span class="line">        System.out.println(count2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><hr><p>Object是所有类(包括数组)的基类，是唯一没有父类的类。<br><img src="http://www.plantuml.com/plantuml/png/bOz1JeL038RtSuecRY1w1ACO3k324nGeK5BQo7GmQhox0HmNnZpoTas_R_v_MaN7nTCieHMC4PwRYLg7pm00S0EApYlbRIkcL9J_ifuLXJyolZqMK6-fzuyFC93lyozlp8HGWLuJIYn-OgoPil3Y2-i0RiUG7-PULeSHurXRzwSq6wjn1shE_Vkfy2HomNb3zZCijdsMPxBaLwXt-o6AQh4CNw4YxT8itm00" alt="Object类图"></p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>作用域是protected，若不重写该方法并声明为public则非类作用域中的对象则无法调用该方法。Cloneable接口只规定如果类没有实现该接口又调用了clone()，就会抛出CloneNotSupportedException。</p><ul><li>浅拷贝:拷贝对象和原始对象的引用类型引用同一个对象。</li><li>深拷贝：拷贝对象和原始对象的引用类型引用不同对象。</li></ul><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>返回对象的哈希值，equals()返回true则两个对象hashCode一定相同，但hashCode相同的两个对象不一定equals。AbstractList、AbstractSet和HashMap.Node等集合类使用了<code>hashCode()</code>方法来计算对象的存储位置，因此要将对象添加到这些集合类中，需要让对应的类实现 <code>hashCode()</code> 方法。hashCode的特点如下：</p><ul><li>hashCode是用来在散列存储结构中确定对象的存储地址(如集合中的HashMap、AbstractList及子类、AbstractSet及子类)</li><li>如果两个对象equals()返回true，则这两个对象的hashCode必须要相同</li><li>如果重写了类的equals()方法，hashCode()方法也必须要重写</li><li>两个对象的hashCode相同不代表两个对象相同，只能说明这两个对象在散列存储结构中<blockquote><p>散列存储:又称hash存储，是一种将数据元素的存储位置与关键码之间建立确定对应关系的查找技术。<br>综上，hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。以<code>HashMap.get(Object key)</code>调用的<code>getNode(int hash, Object key)</code>为例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    &#x2F;&#x2F; 1.判断Node数组table是否为空并数组长度大于0，且通过hashCode获取的数组下标位置元素不为空</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 2. A：判断hash获取的下标位置起的第一个Node元素hash值是否与参数的hash值相同、Node.key是否与Node参数key地址相同，B:或Node.key是否与参数key内容相同且参数key不为空，满足A或B其中一个条件则返回hash获取的下标位置起的第一个元素</span><br><span class="line">        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        &#x2F;&#x2F; 如果hash获取指定下标的第一个Node并非所需要的Node，则根据Node元素的实例是否为TreeNode来确定查找方式</span><br><span class="line">        if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; TreeNode查找方式获取指定key元素Node</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                &#x2F;&#x2F; 链表方式查找指定key元素Node</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>HashMap通过hashCode确认了查找对象的大概位置，再根据hashCode与key确定对象的实际位置。可以理解为HashMap根据hashCode划分成一个个桶，每个桶里含相同hashCode的对象，通过hashCode确认对象的大概位置后，再通过等值判断(<code>==</code>或<code>equals()</code>)获取所需元素Node，所以集合类的对象都要主要重写hashCode方法。</li></ul><h3 id="equals-判断两个对象是否具有等价关系"><a href="#equals-判断两个对象是否具有等价关系" class="headerlink" title="equals():判断两个对象是否具有等价关系"></a>equals():判断两个对象是否具有等价关系</h3><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><hr><p>String被声明为final，因此是不可被继承的(Integer 等包装类也不能被继承）。在 Java 8 中，String 内部使用<code>char</code>数组存储数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final char value[];</span><br></pre></td></tr></table></figure><p><code>value[]</code>被声明为 final，意味着<code>value[]</code>初始化之后就不能再引用其它数组。并且 String 内部没有改变<code>value[]</code>的方法，因此可以保证String不可变。不可变的特性可以使得 hash 值也不可变，使String十分适合作为集合类(如HashMap、HashSet)的哈希运算。<br>String有以下两种赋值方式</p><ul><li>字面量赋值(“Hello”字符串存到常量池中):<code>String str = &quot;Hello&quot;;</code></li><li><code>new</code>创建新对象()：<code>String str = new String(&quot;Hello&quot;);</code>,new方式会在编译时期在String Pool中创建一个字符串对象指向字面量”Hello”(即字符串引用),在运行时会在堆中创建一个字符串对象，该字符串对象intern()返回该字符串字面量的引用。<br>字符串常量池（String Pool）保存着所有字符串常量，这些字面量在编译时期就确定，也可以使用 String的<code>intern()</code>方法在运行过程将字符串添加到String Pool中。在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中，字符串常量池中存放的是字符串的引用。<br>如下例，通过字面量赋值时，加载阶段会在堆区中创建一个字符串对象”Hello”，同时在字符串池(String Pool)中存放一个它的引用，当赋值变量str时，虚拟机会去字符串池中查找是否含equals(“Hello”)的字符串，如为true则返回字符串池中的引用，如果找不到equals的字符串，就会在堆中新建一个对象，同时把引用驻留在字符串池，再把引用赋给str。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str &#x3D; &quot;Hello&quot;;</span><br><span class="line">        String str2 &#x3D; “Hello”;</span><br><span class="line">        String str3 &#x3D; new String(&quot;Hello&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/hexo-blog/Java%E5%9F%BA%E7%A1%80/String.png" alt="String.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;Hello&quot;;</span><br><span class="line">String s2 &#x3D; &quot;Hello&quot;;</span><br><span class="line">String s3 &#x3D; &quot;Hel&quot; + &quot;lo&quot;;</span><br><span class="line">String s4 &#x3D; &quot;Hel&quot; + new String(&quot;lo&quot;);</span><br><span class="line">String s5 &#x3D; new String(&quot;Hello&quot;);</span><br><span class="line">String s6 &#x3D; s5.intern();</span><br><span class="line">String s7 &#x3D; &quot;H&quot;;</span><br><span class="line">String s8 &#x3D; &quot;ello&quot;;</span><br><span class="line">String s9 &#x3D; s7 + s8;</span><br><span class="line">          </span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s2);  &#x2F;&#x2F; true</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s3);  &#x2F;&#x2F; true   参与拼接的部分都是字面量，编译器会进行优化，在编译时s3就变成“Hello”了</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s4);  &#x2F;&#x2F; false  &quot;lo&quot;通过new创建，所以无法在编译期知道它的地址，所以编译器无法进行优化</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s9);  &#x2F;&#x2F; false  s9由两个变量拼接，编译期无法知道变量的具体地址</span><br><span class="line">System.out.println(s4 &#x3D;&#x3D; s5);  &#x2F;&#x2F; false   s5是new出来的，在堆中的地址肯定和s4不同</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s6);  &#x2F;&#x2F; true    s6是s5字符串值&quot;Hello&quot;在常量池的引用，该引用与s1都指向同一个&quot;Hello&quot;对象，所以true</span><br></pre></td></tr></table></figure><ul><li>intern():如果字符串常量池中已经含与当前对象equals(object)为true的字符串，则返回池中的字符串引用；否则将当前String对象添加到字符串常量池中，并返回对当前String对象的引用。</li></ul><h3 id="String-StringBuffer和StringBuilder"><a href="#String-StringBuffer和StringBuilder" class="headerlink" title="String, StringBuffer和StringBuilder"></a>String, StringBuffer和StringBuilder</h3><ul><li>String、StringBuffer和StringBuilder都是通过char数组存储数据，不过StringBuffer和StringBuilder的char数组可变的，没有被final修饰</li><li>StringBuffer线程不安全，String由于其不可变所以是线程安全的，StringBuffer的方法都使用了synchronized同步所以是线程安全的</li><li>String相加编译为字节码后都会新建StringBuilder来进行字符串拼接</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><hr><p>编译器在编译期间将类文件编译为字节码.class文件，在类运行的加载步骤中的加载阶段会根据<code>.class</code>文件生成对应的Class对象并存放到堆中，而字节流的静态存储结构则转化为方法区的运行时数据结构(存储如类的字段、方法等信息)。<br>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的<code>.class</code>不存在也可以加载进来。java反射相关类主要都在包java.lang.reflect下，反射相关常用类如下：</p><ul><li>Class：Class对象代表运行的Java应用中的类和接口(枚举enum是一种类,注解annotation是一种接口)，可以通过Class对象获取类和接口的信息(如类名、所在包、属性、方法、注解等)</li><li>Field：提供有关类或接口的单个字段及对它们动态访问的信息(注解、类型)，可通过Class对象获取</li><li>Method：提供有关类或接口上的单个方法的信息(参数、注解)，以及对单个方法的访问调用。反射获取的方法可以是类方法或实例的方法，调用<code>invoke()</code>方法调用。</li><li>Constructor:提供类的构造函数信息(参数、注解)，并提供对此类的访问，通过调用该对象的<code>newInstance()</code>可以创建声明类的实例。</li><li>Parameter：提供方法参数的信息(类型、注解)，可通过Method、Constructor对象获取。</li></ul><p>虽然反射的功能很强大，但也不该滥用，反射的缺点如下：</p><ul><li>增加性能开销：反射涉及了动态类型的解析，JVM无法对这些代码进行优化，因此反射效率比直接操作的效率是慢很多的</li><li>安全性降低：由于反射可以执行一些正常情况下不被允许的操作(如访问私有属性和方法)，破坏了封装性</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><hr><p>Throwable 是所有异常类的基类，java根据异常是否虚拟机异常将异常分为Error与Exception，Throwable的一级子类只有Error与Exception。</p><ul><li>Error：合理的应用程序不应尝试捕获的严重问题，一般是虚拟机的异常，如栈溢出(StackOverFlowError)、内存溢出(OutOfMemoryError)</li><li>Exception：合理的应用程序可能需要捕获的异常，常见的Exception子类有SQLException、RuntimeException、IOException等<br><a href="http://www.plantuml.com/plantuml/uml/XOvDQe0m48Ntdi8BU8Ckx491gAO_fNGRuwXf9vaodLGBFNnB8mO4SHCUx_ioC-MdQ9RWC5Fz6nZ9RtwA8d-UcHRT8-JP7YEfc8cp_pSMB_RlkyPMczbwYFZG9Vb9j7bNNy0ZqbAj1Zx4aZ_tLH0rjk28lvDzk2Y1FMtB7kvEsMFmOXsSyaObjEK4QulGaTGK_92quyZeTW7ndgmNu2krGOH9uorFmO6NA_rrNPDIWX-2mry0" target="_blank" rel="noopener">PlantUML Web Server</a><br>Exception异常有两种处理方式：</li><li>捕获处理：<code>try{} catch{}</code>捕捉处理且不抛出<code>throw</code>使程序正常运行</li><li>抛出异常：通过<code>throw/throws</code>抛出异常将结束当前程序代码块的运行将异常抛给上游(方法调用方)，由上游进行处理，常见的业务异常可以通过Spring Boot的<code>@ControllerAdvice</code>定义全局异常拦截器</li></ul><h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解-Annotation"></a>注解-Annotation</h2><hr><p>Annontation是JDK5引入的特性，用于将一些信息或元数据标注到程序元素（类、方法、成员变量、参数等），可以理解成程序元素的标签。注解标注的元数据可用于编译、类加载、运行时使用，元素的注解相关类都包含在<code>java.lang.annotation</code>包中。<br>注解本质是一个继承了 <code>java.lang.annotation.Annotation</code> 的特殊接口(注解即接口)，其具体实现类是Java 运行时生成的动态代理类。通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，最终会调用 <code>AnnotationInvocationHandler</code> 的invoke 方法，该方法会从memberValues 这个Map 中索引出对应的值，而memberValues 的来源是Java 常量池。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><code>java.lang.annotation</code>提供了四种元注解，用于注解其他的注解(常用于自定义注解)：</p><ul><li><p>@Documented：注解是否将包含在JavaDoc中</p></li><li><p>@Retention：注解的保留时间，默认保留策略为<code>RetentionPolicy.CLASS</code>，注释可选的保留策略<code>RetentionPolicy</code>如下：</p><ul><li><code>SOURCE</code>：注解只在源文件中.java保留，编译后丢失(即编译后的.class文件将不包含注解)</li><li><code>CLASS</code>：注解保留到编译文件，但VM不会在运行时保留这些注解</li><li><code>RUNTIME</code>：注解由VM保留到程序运行期间，因此程序运行时可以通过反射获取这些注解信息</li></ul></li><li><p>@Target：声明注解适用的范围，参数为<code>ElementType</code>注解范围枚举数组，<code>ElementType</code>常用枚举如下：</p><ul><li><code>TYPE</code>：类，接口（包括注解）或枚举</li><li><code>FIELD</code>：字段</li><li><code>METHOD</code>：方法</li><li><code>PARAMETER</code>：参数</li><li><code>CONSTRUCTOR</code>：构造函数</li><li><code>LOCAL_VARIABLE</code>：本地变量</li><li><code>ANNOTATION_TYPE</code>：注解</li><li><code>PACKAGE</code>：包</li></ul></li><li><p>@Inherited：声明注解是可继承的，如A类被可继承的注解B标注了，AA集成了A，则B注解也对A有效</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象编程的三大特性&quot;&gt;&lt;a href=&quot;#面向对象编程的三大特性&quot; class=&quot;headerlink&quot; title=&quot;面向对象编程的三大特性&quot;&gt;&lt;/a&gt;面向对象编程的三大特性&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wilson-he.gitee.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://wilson-he.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>一个普通程序猿的文章索引页</title>
    <link href="https://wilson-he.gitee.io/undefined/"/>
    <id>https://wilson-he.gitee.io/undefined/</id>
    <published>2020-06-04T02:20:29.302Z</published>
    <updated>2020-06-04T02:20:29.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK基础"><a href="#JDK基础" class="headerlink" title="JDK基础"></a>JDK基础</h1><ul><li><a href="/Java基础">Java基础</a></li><li>Java常用集合<ul><li><a href="/list">ArrayList与LinkedList区别与源码分析</a></li><li><a href="/HashMap">透析HashMap</a></li></ul></li><li>Java并发<ul><li>volatile关键字</li><li>synchronized关键字(CPU原语级别)</li><li>无锁、偏向锁、轻量级锁、重量级锁有什么差别，升级过程如何？</li><li>Lock</li><li>ReentrantLock</li><li>CountDownLatch计时器</li><li>线程池<ul><li>CachedPool</li><li>FixedThreadPool</li><li>ScheduledPool</li><li>WorkStealingPool</li><li>ForkJoinPool</li></ul></li><li>下列三种业务，应该如何使用线程池：<ul><li>高并发、任务执行时间短的业务</li><li>并发不高、任务执行时间长的业务</li><li>并发高、业务执行时间长的业务<h1 id="RocketMQ专栏"><a href="#RocketMQ专栏" class="headerlink" title="RocketMQ专栏"></a>RocketMQ专栏</h1></li></ul></li></ul></li><li><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2></li><li><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul><li><a href="/rocketmq/message-center">聊聊MQ与如何基于Spring Boot RocketMQ搭建一个消息中心</a></li><li><a href="/rocketmq/clap-peak">RocketMQ削峰，这一篇就够了</a></li></ul></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul><li>MySQL<ul><li><a href="https://dev.mysql.com/downloads/workbench/" target="_blank" rel="noopener">数据库设计工具MysqlWorkbench</a></li></ul></li><li>MongoDB<ul><li><a href="/MongoDB/basic-operate">基础操作指令</a></li><li><a href="https://docs.mongodb.com/manual/crud/" target="_blank" rel="noopener">官方操作文档</a></li><li>GUI工具：<a href="https://robomongo.org/" target="_blank" rel="noopener">Robo 3T</a></li></ul></li><li>Redis</li></ul><h1 id="框架文档"><a href="#框架文档" class="headerlink" title="框架文档"></a>框架文档</h1><ul><li><a href="https://mybatis.plus/guide/" target="_blank" rel="noopener">Mybatis Plus</a></li><li><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">携程apollo</a></li><li><a href="https://github.com/apache/rocketmq-spring/wiki" target="_blank" rel="noopener">rocketmq-spring</a></li><li><a href="http://kafka.apachecn.org/" target="_blank" rel="noopener">Kafka</a></li><li><a href="https://github.com/spring-projects/spring-boot/wiki" target="_blank" rel="noopener">Spring Boot Release Notes-了解新版特性</a></li><li><a href="https://github.com/Wilson-He/swagger2-spring-boot-starter" target="_blank" rel="noopener">个人开源swagger2-spring-boot-starter框架</a></li><li><a href="https://gitee.com/Wilson-He/generator-maven-plugin" target="_blank" rel="noopener">个人开源mybatis plus maven代码生成器插件</a></li></ul><h1 id="常用软件文档"><a href="#常用软件文档" class="headerlink" title="常用软件文档"></a>常用软件文档</h1><ul><li><a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">MySQL</a></li><li><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx</a></li><li><a href="https://docs.docker.com/" target="_blank" rel="noopener">docker</a></li><li><a href="https://hub.docker.com/u/library" target="_blank" rel="noopener">docker hub</a></li><li><a href="https://jenkins.io/zh/doc/" target="_blank" rel="noopener">Jenkins</a></li><li><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker</a><ul><li><a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="noopener">Docker Compose</a></li><li><a href="https://www.docker.com/products/docker-hub" target="_blank" rel="noopener">Docker Hub</a></li></ul></li></ul><h1 id="个人常用工具"><a href="#个人常用工具" class="headerlink" title="个人常用工具"></a>个人常用工具</h1><ul><li><a href="https://linuxize.com/" target="_blank" rel="noopener">linuxize-linux各软件安装文档网站</a></li><li><a href="http://www.baidu.com/link?url=HQhRL3UQ03YHc7-rGfijpY8aBYbgMOFkLCIiz2rVGwjAi3zwLviXMR3SgfoCMM2w&wd=&eqid=d2eb5eff0001257f000000065e85a396" target="_blank" rel="noopener">Postman</a></li><li><a href="https://plugins.jetbrains.com/" target="_blank" rel="noopener">Intellij插件</a><ul><li><a href="https://plugins.jetbrains.com/plugin/9837-mybatiscodehelperpro" target="_blank" rel="noopener">MyBatisCodeHelperPro</a></li><li><a href="https://plugins.jetbrains.com/plugin/8579-translation" target="_blank" rel="noopener">Translation</a></li><li><a href="https://plugins.jetbrains.com/plugin/6317-lombok" target="_blank" rel="noopener">Lombok</a></li><li>MyBatis Log Plugin:打印log.debug.{mapperPackage}下的sql</li><li>RestfulToolkit:提供了项目中的接口概览信息,可提取参数json</li><li><a href="https://plugins.jetbrains.com/plugin/7179-maven-helper" target="_blank" rel="noopener">Maven Helper</a></li><li><a href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines" target="_blank" rel="noopener">Alibaba Java Coding Guidelines</a></li></ul></li><li><a href="https://boostnote.io/" target="_blank" rel="noopener">Markdown编辑器Boostnote</a><ul><li><a href="https://github.com/BoostIO/Boostnote/wiki" target="_blank" rel="noopener">Wiki文档</a></li><li><a href="http://plantuml.com/" target="_blank" rel="noopener">plantuml语法绘制UML文档</a></li><li><a href="http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000" target="_blank" rel="noopener">plantuml语法绘制UML网站</a></li></ul></li></ul><h1 id="在线工具网站"><a href="#在线工具网站" class="headerlink" title="在线工具网站"></a>在线工具网站</h1><ul><li><a href="https://linuxize.com/" target="_blank" rel="noopener">linux各软件安装教程</a></li><li><a href="https://www.json.cn/" target="_blank" rel="noopener">json格式化</a></li><li><a href="https://www.toyaml.com/index.html" target="_blank" rel="noopener">yaml与properties配置互转</a></li></ul><h1 id="Chrome-免配置版-插件"><a href="#Chrome-免配置版-插件" class="headerlink" title="Chrome(免配置版)插件"></a>Chrome(<a href="https://www.baiduyun.wiki/download.html" target="_blank" rel="noopener">免配置版</a>)插件</h1><blockquote><p>国内插件资源站点：<a href="https://chrome.zzzmh.cn/index#index" target="_blank" rel="noopener">https://chrome.zzzmh.cn/index#index</a></p></blockquote><ul><li>油猴Tampermonkey(<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">油猴脚本搜索网站</a>)<ul><li><a href="https://www.baiduyun.wiki/install-darkmode.html" target="_blank" rel="noopener">夜间模式助手</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/381682-html5视频播放器增强脚本" target="_blank" rel="noopener">百度云盘HTML5视频倍速播放</a></li><li><a href="https://www.baiduyun.wiki/zh-cn/" target="_blank" rel="noopener">网盘直链下载助手</a></li></ul></li><li>掘金</li><li>IDM(Internet Download Manager)：使用IDM下载资源</li><li>Modify Header：请求添加header</li><li>OneTab - 保留当前页面缓存关闭其他标签页</li><li>Image Downloader - 保存图片为png</li><li>Allow Copy - 解除禁用复制</li><li><a href="https://greasyfork.org/zh-CN/scripts?q=Axure" target="_blank" rel="noopener">Axure</a></li></ul><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><ul><li><a href="https://lingcoder.gitee.io/onjava8/#/" target="_blank" rel="noopener">《Java编程思想》Java 8</a></li><li><a href="https://www.bookstack.cn/" target="_blank" rel="noopener">书栈网 - 开源编程书籍</a></li><li><a href="http://sjsdfg.gitee.io/effective-java-3rd-chinese/#/README" target="_blank" rel="noopener">《Effective Java》第三版</a></li><li><a href="https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html#_%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC_%E7%89%88%E6%9D%83%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">Reactor 3 参考文档</a></li></ul><h1 id="其它链接"><a href="#其它链接" class="headerlink" title="其它链接"></a>其它链接</h1><ul><li><a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">Next主题文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JDK基础&quot;&gt;&lt;a href=&quot;#JDK基础&quot; class=&quot;headerlink&quot; title=&quot;JDK基础&quot;&gt;&lt;/a&gt;JDK基础&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/Java基础&quot;&gt;Java基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java常用集合&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="https://wilson-he.gitee.io/UML/"/>
    <id>https://wilson-he.gitee.io/UML/</id>
    <published>2020-06-03T08:03:05.441Z</published>
    <updated>2020-06-03T08:03:05.449Z</updated>
    
    <content type="html"><![CDATA[<p>绘图url:<a href="http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000" target="_blank" rel="noopener">http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000</a></p><p>Object</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class Object &#123;</span><br><span class="line">    # native Object clone()</span><br><span class="line">    # native Object finalize()</span><br><span class="line">    + final Class&lt;?&gt; getClass()</span><br><span class="line">    + boolean equals(Object obj)</span><br><span class="line">    + String toString()</span><br><span class="line">    + native int hashCode()</span><br><span class="line">    + final native void notify()</span><br><span class="line">    + final native void notifyAll()</span><br><span class="line">    + final native void wait()</span><br><span class="line">    + final native void wait(long timeout)</span><br><span class="line">    + final native void wait(long timeout, int nanos)</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>Exception:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Object &lt;|-- Throwable </span><br><span class="line">Throwable &lt;|-- Error</span><br><span class="line">Error &lt;|-- VirtualMachineError</span><br><span class="line">VirtualMachineError &lt;|-- StackOverflowException</span><br><span class="line">VirtualMachineError &lt;|-- OutOfMemoryException</span><br><span class="line">Throwable &lt;|-- Exception</span><br><span class="line">Exception &lt;|-- RuntimeException</span><br><span class="line">Exception &lt;|-- IOException</span><br><span class="line">IOException &lt;|-- FileNotFoundException</span><br><span class="line">RuntimeException &lt;|-- IOException</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>ArrayList:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">interface List&#123;&#125;</span><br><span class="line">interface RandomAccess&#123;&#125;</span><br><span class="line">interface Cloneable&#123;&#125;</span><br><span class="line">interface Collection&#123;&#125;</span><br><span class="line">interface Serializable&#123;&#125;</span><br><span class="line">class AbstractCollection&#123;&#125;</span><br><span class="line">class AbstractList&#123;</span><br><span class="line">    # transient int modCount</span><br><span class="line">&#125;</span><br><span class="line">class ArrayList&#123;</span><br><span class="line">    - static final int DEFAULT_CAPACITY</span><br><span class="line">    - static final Object[] EMPTY_ELEMENTDATA</span><br><span class="line">    - static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">    - static final int MAX_ARRAY_SIZE</span><br><span class="line">    - int size</span><br><span class="line">    # transient Object[] elementData</span><br><span class="line">    + boolean add(E e)</span><br><span class="line">    + boolean addAll(Collection&lt;? extends E&gt; c)</span><br><span class="line">    + boolean remove(E e)</span><br><span class="line">    + boolean remove(int index)</span><br><span class="line">    + E get(int index)</span><br><span class="line">    + int indexOf(Object o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collection &lt;|.. AbstractCollection</span><br><span class="line">AbstractCollection &lt;|-- AbstractList</span><br><span class="line">List &lt;|.. ArrayList</span><br><span class="line">List &lt;|.. AbstractList</span><br><span class="line">RandomAccess &lt;|..ArrayList</span><br><span class="line">AbstractList &lt;|.. ArrayList</span><br><span class="line">Cloneable &lt;|.. ArrayList</span><br><span class="line">Serializable &lt;|.. ArrayList</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>CopyOnWriteArrayList:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">interface List&#123;&#125;</span><br><span class="line">interface RandomAccess&#123;&#125;</span><br><span class="line">interface Cloneable&#123;&#125;</span><br><span class="line">interface Serializable&#123;&#125;</span><br><span class="line">interface Collection&#123;&#125;</span><br><span class="line">class CopyOnWriteArrayList&#123;</span><br><span class="line">    # final transient ReentrantLock lock : default new ReentrantLock()</span><br><span class="line">    - transient volatile Object[] array</span><br><span class="line">    - static final sun.misc.Unsafe UNSAFE</span><br><span class="line">    - static final long lockOffset</span><br><span class="line">    + boolean add(E e)</span><br><span class="line">    + boolean remove(E e)</span><br><span class="line">    + boolean remove(int index)</span><br><span class="line">    + E get(int index)</span><br><span class="line">    + int indexOf(Object o)</span><br><span class="line">&#125;</span><br><span class="line">List &lt;|.. CopyOnWriteArrayList</span><br><span class="line">Collection &lt;|-- List </span><br><span class="line">RandomAccess &lt;|..CopyOnWriteArrayList</span><br><span class="line">Cloneable &lt;|.. CopyOnWriteArrayList</span><br><span class="line">Serializable &lt;|.. CopyOnWriteArrayList</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>LinkedList:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">interface List&#123;&#125;</span><br><span class="line">interface Cloneable&#123;&#125;</span><br><span class="line">interface Serializable&#123;&#125;</span><br><span class="line">class Node&#123;</span><br><span class="line">  E item</span><br><span class="line">  Node&lt;E&gt; next</span><br><span class="line">  Node&lt;E&gt; prev</span><br><span class="line">&#125;</span><br><span class="line">interface Deque&#123;</span><br><span class="line">  void addFirst(E e)</span><br><span class="line">  void addLast(E e)</span><br><span class="line">  E removeFirst()</span><br><span class="line">  E removeLast()</span><br><span class="line">  ...()</span><br><span class="line">&#125;</span><br><span class="line">interface Queue&#123;&#125;</span><br><span class="line">interface Collection&#123;&#125;</span><br><span class="line">Queue &lt;|-- Deque</span><br><span class="line">Collection &lt;|-- Queue</span><br><span class="line">class LinkedList&#123;</span><br><span class="line">    - transient int size</span><br><span class="line">    - transient Node&lt;E&gt; first</span><br><span class="line">    - transient Node&lt;E&gt; last</span><br><span class="line">    + boolean add(E e)</span><br><span class="line">    + boolean addAll(Collection&lt;? extends E&gt; c)</span><br><span class="line">    + boolean remove(E e)</span><br><span class="line">    + boolean remove(int index)</span><br><span class="line">    + E get(int index)</span><br><span class="line">    + int indexOf(Object o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Deque &lt;|.. LinkedList</span><br><span class="line">Collection &lt;|-- List</span><br><span class="line">List &lt;|.. LinkedList</span><br><span class="line">AbstractSequentialList &lt;|-- LinkedList</span><br><span class="line">AbstractList &lt;|-- AbstractSequentialList </span><br><span class="line">AbstractCollection&lt;|-- AbstractList</span><br><span class="line">List &lt;|.. AbstractCollection</span><br><span class="line">Cloneable &lt;|.. LinkedList</span><br><span class="line">Serializable &lt;|.. LinkedList</span><br><span class="line">LinkedList +-- Node</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>HashMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">interface Map&#123;&#125;</span><br><span class="line">interface Cloneable&#123;&#125;</span><br><span class="line">interface Serializable&#123;&#125;</span><br><span class="line">abstract class AbstractMap&lt;K,V&gt;&#123;&#125;</span><br><span class="line">class LinkedHashMap&lt;K,V&gt;&#123;&#125;</span><br><span class="line">class HashMap&lt;K,V&gt;&#123;</span><br><span class="line">  static final int DEFAULT_INITIAL_CAPACITY</span><br><span class="line">  static final int MAXIMUM_CAPACITY</span><br><span class="line">  static final float DEFAULT_LOAD_FACTOR</span><br><span class="line">  static final int TREEIFY_THRESHOLD</span><br><span class="line">  static final int UNTREEIFY_THRESHOLD</span><br><span class="line">  static final int MIN_TREEIFY_CAPACITY</span><br><span class="line">  final float loadFactor</span><br><span class="line">  int threshold</span><br><span class="line">  transient int size</span><br><span class="line">  transient int modCount</span><br><span class="line">  transient Node&lt;K,V&gt;[] table</span><br><span class="line">  transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet</span><br><span class="line">&#125;</span><br><span class="line">Map &lt;|.. AbstractMap  </span><br><span class="line">Serializable &lt;|.. HashMap</span><br><span class="line">Cloneable &lt;|.. HashMap</span><br><span class="line">AbstractMap &lt;|-- HashMap</span><br><span class="line">HashMap &lt;|-- LinkedHashMap</span><br><span class="line">Map &lt;|.. LinkedHashMap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Map.Entry&lt;K,V&gt;&#123;</span><br><span class="line">  K getKey()</span><br><span class="line">  V getValue()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HashMap.Node&lt;K,V&gt; implements Map.Entry &#123;</span><br><span class="line">  final int hash</span><br><span class="line">  final K key</span><br><span class="line">  V value</span><br><span class="line">  Node&lt;K,V&gt; next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LinkedHashMap.Entry&lt;K,V&gt; extends HashMap.Node&#123;</span><br><span class="line"> Entry&lt;K,V&gt; before, after</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HashMap.TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry &#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; parent</span><br><span class="line">  TreeNode&lt;K,V&gt; left</span><br><span class="line">  TreeNode&lt;K,V&gt; right</span><br><span class="line">  TreeNode&lt;K,V&gt; prev</span><br><span class="line">  boolean red</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;绘图url:&lt;a href=&quot;http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.plantuml.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>个人导航页</title>
    <link href="https://wilson-he.gitee.io/private-nav/"/>
    <id>https://wilson-he.gitee.io/private-nav/</id>
    <published>2020-06-03T07:41:06.060Z</published>
    <updated>2020-06-03T07:41:06.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h1><table><thead><tr><th>版本控制</th><th><a href="https://github.com/Wilson-He" target="_blank" rel="noopener">github</a></th><th><a href="https://gitee.com/Wilson-He" target="_blank" rel="noopener">gitee</a></th><th></th></tr></thead><tbody><tr><td>画图</td><td><a href="http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000" target="_blank" rel="noopener">UML绘制</a></td><td><a href="https://www.processon.com/diagrams" target="_blank" rel="noopener">ProcessOn</a></td><td></td></tr><tr><td>其它</td><td><a href="https://www.toyaml.com/index1.html" target="_blank" rel="noopener">properties、yaml互转</a></td><td><a href="http://111.229.4.194/tools/swagger-ui.html" target="_blank" rel="noopener">字符串操作</a></td><td><a href="https://linuxize.com/" target="_blank" rel="noopener">linux软件安装教程</a></td></tr></tbody></table><h1 id="Chrome-简洁版"><a href="#Chrome-简洁版" class="headerlink" title="Chrome(简洁版)"></a>Chrome(<a href="https://chrome.zzzmh.cn/index#index" target="_blank" rel="noopener">简洁版</a>)</h1><blockquote><p>国内插件资源站点：<a href="https://chrome.zzzmh.cn/index#index" target="_blank" rel="noopener">https://chrome.zzzmh.cn/index#index</a></p></blockquote><p>插件：油猴Tampermonkey、掘金、IDM、ModifyHeader、OneTab、Image Downloader、Allow Copy、Axure<br><a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">油猴脚本搜索</a>：百度云盘HTML5视频倍速播放、网盘直链下载助手</p><h1 id="动漫电影"><a href="#动漫电影" class="headerlink" title="动漫电影"></a>动漫电影</h1><table><thead><tr><th>动漫</th><th><a href="http://www.milimili.tv/" target="_blank" rel="noopener">咪哩咪哩</a></th><th><a href="http://www.bimibimi.me/" target="_blank" rel="noopener">哔咪哔咪</a></th></tr></thead><tbody><tr><td>电影</td><td></td><td></td></tr></tbody></table><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><table><thead><tr><th>框架</th><th>软件</th></tr></thead><tbody><tr><td><a href="https://spring.io/" target="_blank" rel="noopener">Spring</a></td><td><a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">MySQL</a></td></tr><tr><td><a href="https://mybatis.plus/guide/" target="_blank" rel="noopener">Mybatis Plus</a></td><td><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx</a></td></tr><tr><td><a href="https://github.com/spring-projects/spring-boot/wiki" target="_blank" rel="noopener">Spring Boot Release Notes-了解新版特性</a></td><td><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx</a></td></tr><tr><td><a href="https://github.com/apache/rocketmq-spring/wiki" target="_blank" rel="noopener">rocketmq-spring</a></td><td><a href="https://docs.docker.com/" target="_blank" rel="noopener">docker</a></td></tr><tr><td><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">携程apollo</a></td><td><a href="https://hub.docker.com/u/library" target="_blank" rel="noopener">docker hub</a></td></tr><tr><td><a href="http://kafka.apachecn.org/" target="_blank" rel="noopener">Kafka</a></td><td><a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="noopener">Docker Compose</a></td></tr><tr><td></td><td><a href="https://jenkins.io/zh/doc/" target="_blank" rel="noopener">Jenkins</a></td></tr><tr><td></td><td><a href="https://docs.mongodb.com/manual/crud/" target="_blank" rel="noopener">MongoDB指令</a></td></tr><tr><td></td><td><a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">Next主题文档</a></td></tr></tbody></table><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p><a href="http://cv.ftqq.com/#" target="_blank" rel="noopener">Markdown简历</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在线工具&quot;&gt;&lt;a href=&quot;#在线工具&quot; class=&quot;headerlink&quot; title=&quot;在线工具&quot;&gt;&lt;/a&gt;在线工具&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;版本控制&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;https://github.co
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>透析HashMap</title>
    <link href="https://wilson-he.gitee.io/HashMap/"/>
    <id>https://wilson-he.gitee.io/HashMap/</id>
    <published>2020-06-02T12:24:04.986Z</published>
    <updated>2020-06-02T12:24:04.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>HashMap在1.8之后通过数组(table)属性使用单向链表 + 红黑树的结构组合提高查找效率，于是我大致的画了下图：<br><img src="https://user-gold-cdn.xitu.io/2020/5/26/1724ecb73148242e?w=1090&h=610&f=png&s=53123" alt="faker-hashmap-tree.png"><br>后来写着写着发现我还是太年轻了，有什么比亲手实践更值得让人信服呢？</p><h1 id="类图分析-只标注主要属性方法"><a href="#类图分析-只标注主要属性方法" class="headerlink" title="类图分析(只标注主要属性方法)"></a>类图分析(只标注主要属性方法)</h1><p><img src="https://user-gold-cdn.xitu.io/2020/5/26/1724ecb7bd7d7b52?w=700&h=685&f=png&s=53359" alt="HashMap类图"></p><ul><li><code>Map&lt;K,V&gt;</code>:键值映射的基础接口，提供常用的键值映射操作方法的抽象</li><li><code>Map.Entry&lt;K,V&gt;</code>:键值对条目(单个键值)抽象接口</li><li><code>AbstractMap&lt;K,V&gt;</code>: 简单实现了<code>Map</code>接口的部分方法</li><li><code>HashMap&lt;K,V&gt;</code>: 基于<code>Map</code>接口的哈希实现</li><li><code>HashMap.Node&lt;K,V&gt;</code>:<code>HashMap</code>键值对条目链表结构的实现类</li><li><code>HashMap.TreeNode&lt;K,V&gt;</code>:<code>HashMap</code>键值对条目红黑树结构的实现类</li><li><code>LinkedHashMap&lt;K,V&gt;</code>:基于<code>Map</code>接口的哈希表和链表结构实现，与<code>HashMap</code>的主要区别在于键值对都是有序的</li><li><code>LinkedHashMap.Entry&lt;K,V&gt;</code>:<code>LinkedHashMap</code>键值条目链表结构的实现类</li></ul><h1 id="属性解析"><a href="#属性解析" class="headerlink" title="属性解析"></a>属性解析</h1><ul><li><code>DEFAULT_INITIAL_CAPACITY</code>：默认16，默认初始容量，必须为2的幂值</li><li><code>MAXIMUM_CAPACITY</code>：默认1&lt;&lt;30(即2^29)，最大容量值，如果有参构造函数容量值比该值高，则使用该值作为容量值</li><li><code>DEFAULT_LOAD_FACTOR</code>：默认0.75f，构造函数中未指定时使用的负载因子</li><li><code>TREEIFY_THRESHOLD</code>：默认8，容器树化阈值，达到阈值(8)后容器将使用红黑树结果存储数据</li><li><code>UNTREEIFY_THRESHOLD</code>：默认6，非树化阈值，应小于<code>TREEIFY_THRESHOLD</code>。</li><li><code>MIN_TREEIFY_CAPACITY</code>：默认64，表中节点链表结构被树化的最小表容量值，实际会根据容器大小判断是只进行扩容还是进行树化。</li><li><code>loadFactor</code>：哈希表的负载因子</li><li><code>threshold</code>：下一次调整大小的容量阈值(capacity * load factor)</li><li><code>modCount</code>：对该HashMap进行结构修改的次数。结构修改是指更改HashMap中的映射数目或以其他方式修改其内部结构的修改（如重新哈希）。</li><li><code>size</code>：包含的键-值映射数</li><li><code>table</code>：该表(节点Node数组)在首次使用时初始化，并根据需要调整大小，分配后的长度始终是2的幂。</li><li><code>entrySet</code>：用于获取key-value映射集合<code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code>，在首次调用<code>entrySet()</code>方法时被初始化</li></ul><p>文章使用的术语掺杂了一些个人根据源码与文档的理解，需了解注意的如下：</p><ul><li>表(table数组) = 容器</li><li>table.length = 容量 != 映射数目</li><li>table中的节点Node元素 = 桶bin</li><li>table中的键值对节点Node以外的元素都以null填充</li></ul><h1 id="方法解析，窥遍HashMap"><a href="#方法解析，窥遍HashMap" class="headerlink" title="方法解析，窥遍HashMap"></a>方法解析，窥遍<code>HashMap</code></h1><h2 id="HashMap的三个构造函数"><a href="#HashMap的三个构造函数" class="headerlink" title="HashMap的三个构造函数"></a><code>HashMap</code>的三个构造函数</h2><ol><li>无参构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用默认的初始容量（16）和默认的加载因子（0.75）构造一个空的HashMap。</span><br><span class="line"> * 注：该方法没有初始化阈值threshold</span><br><span class="line"> *&#x2F;</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>带初始容量的构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化容量initialCapacity、负载因子loadFactor&#x3D;DEFAULT_LOAD_FACTOR(0.75)、阈值threshold</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>带初始容量与f负载因子的构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 以特定的容量与负载系数构建一个空的HashMap</span><br><span class="line"> *</span><br><span class="line"> * @param  initialCapacity 初始容量</span><br><span class="line"> * @param  loadFactor      负载因子</span><br><span class="line"> * @throws IllegalArgumentException initialCapacity为负数、负载因子为负数或非数字时抛错</span><br><span class="line"> *&#x2F;</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;   &#x2F;&#x2F; MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 该方法主要用于设置阈值threshold，返回大于或等于参数容量cap的的2次幂，如cap&#x3D;9、11、12、15、16时都会返回16，cap&#x3D;5、6、7、8时返回8</span><br><span class="line"> * @param cap 容量参数</span><br><span class="line"> * @return 返回大于或等于参数容量cap的的2次幂</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n &#x3D; cap - 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="put-K-V-添加键值"><a href="#put-K-V-添加键值" class="headerlink" title="put(K, V)添加键值"></a>put(K, V)添加键值</h2><p>由<code>HashMap</code>的三个构造函数可以看出构造<code>HashMap</code>时主要初始化了负载因子loadFactor、table扩容阈值threshold,若是无参构造函数则只初始化阈值，所以一般table的初始化都是在put第一个键值对时初始化的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  获取键的哈希值</span><br><span class="line"> * </span><br><span class="line"> *  @param key</span><br><span class="line"> *  @return key的哈希值</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  创建链表节点并设置该节点指向的下一节点</span><br><span class="line"> * </span><br><span class="line"> *  @param hash  键哈希值</span><br><span class="line"> *  @param key   键</span><br><span class="line"> *  @param value 值</span><br><span class="line"> *  @param next  新建节点指向的下一节点</span><br><span class="line"> *  @return      链表节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 实现Map.put和相关的方法</span><br><span class="line"> *</span><br><span class="line"> * @param hash key的哈希值</span><br><span class="line"> * @param key</span><br><span class="line"> * @param value </span><br><span class="line"> * @param onlyIfAbsent true则不替换已存在的key值</span><br><span class="line"> * @param evict 标志表是否处于创建模式</span><br><span class="line"> * @return 返回key之前的值，之前值不存在则返回true</span><br><span class="line"> *&#x2F;</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;</span><br><span class="line">    &#x2F;&#x2F; 引用属性table的临时变量</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    &#x2F;&#x2F; table上的节点引用(p &#x3D; pointer &#x3D; 链表指针)</span><br><span class="line">    Node&lt;K,V&gt; p; </span><br><span class="line">    &#x2F;&#x2F; n用于记录Node&lt;K,V&gt;[] table长度的临时变量，i为key哈希与table.length相与后的table索引index</span><br><span class="line">    int n, i;</span><br><span class="line">    &#x2F;&#x2F; 1. 若table为空则初始化键值对数组table</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    &#x2F;&#x2F; 2 </span><br><span class="line">    &#x2F;&#x2F; 2.1 判断key哈希值与长度相与运算获取相应的数组索引值i，判断table数组i节点是否空，空则直接在该索引放置新节点，跳到&#96;3&#96;；不为空则该位置上的节点将会形成桶(链表|红黑树结构)链接多个节点</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    &#x2F;&#x2F; 2.2 table[i]上的元素节点p不为空        </span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; e可看作遍历table的结果节点(e &#x3D; end)，k用于引用p节点的key值</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        &#x2F;&#x2F; 2.2.1 判断节点p与参数的key是否相同，相同即只需执行替换value，e不为null，跳到&#96;2.2&#96;</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        &#x2F;&#x2F; 2.2.2 参数key与table[i]上的key不匹配，若table[i]的节点为TreeNode，则以TreeNode结构存放新节点，e为null,跳到&#96;2&#96;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        &#x2F;&#x2F; 2.2.3 参数key与table[i]上的key不匹配，且该节点并非TreeNode，则以链式节点存储</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; binCount：桶中的元素数目，即Node&lt;K,V&gt;[] table中的Node节点元素内的key-value键值对数目</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F; p下一节点e为空节点，则新建节点赋到当前节点的next</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    &#x2F;&#x2F; 根据桶中节点数目与容量大小判断是进行扩容还是进行树化，若桶中已有的节点数&gt;&#x3D;8且容量&gt;&#x3D;64则进行树化；e为null,跳到&#96;3&#96;</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; p下一节点e不为空</span><br><span class="line">                &#x2F;&#x2F; p下一节点e的key与参数key相同,e不为null，跳到&#96;2.2&#96;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; p下一节点e的hash或key属性与新增的key不同，则把下一节点赋给p继续进行链表遍历，直到遇到空的节点或hash、key相同的节点</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 2.2.4 e不为空，即Node[] table中已含键为参数key的节点，则替换key的旧值</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">           &#x2F;&#x2F; 获取参数key对应节点的旧映射值</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            &#x2F;&#x2F; 设置key新的映射值</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            afterNodeAccess(e); &#x2F;&#x2F; HashMap中为空实现，主要应用在LinkedHashMap中</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 3. 节点新增成功后的容器相关属性更改</span><br><span class="line">    &#x2F;&#x2F; e为空，则有新的键值对节点添加，结构发生改变，结构修改次数自增</span><br><span class="line">    ++modCount;</span><br><span class="line">    &#x2F;&#x2F; 键值对数目自增，并判断自增后若大于扩容阈值，则调整容量大小</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict); &#x2F;&#x2F; HashMap中为空实现，主要应用在LinkedHashMap中</span><br><span class="line">    &#x2F;&#x2F; 不存在旧节点，返回空</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 若表太小，则resize调整表大小；否则将替换bin(桶)中给定哈希值的索引中所有链接的节点Node为TreeNode。</span><br><span class="line"> *&#x2F;</span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    &#x2F;&#x2F; tab为空或tab数组长度 &lt; MIN_TREEIFY_CAPACITY(64)，即元素数量不多，只重新调整tab长度(容量)，节点维持链表结构而无需更改为红黑树结构</span><br><span class="line">    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    &#x2F;&#x2F; 判断参数hash值在tab数组中相应位置的节点是否不为空</span><br><span class="line">    else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 将e与e链表上链接的所有Node节点转换为TreeNode节点</span><br><span class="line">        do &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);</span><br><span class="line">            if (tl &#x3D;&#x3D; null)</span><br><span class="line">                hd &#x3D; p;</span><br><span class="line">            else &#123;</span><br><span class="line">                p.prev &#x3D; tl;</span><br><span class="line">                tl.next &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl &#x3D; p;</span><br><span class="line">        &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        if ((tab[index] &#x3D; hd) !&#x3D; null)</span><br><span class="line">            &#x2F;&#x2F; 将table转为红黑树结构</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br></pre></td></tr></table></figure><p>综上，HashMap添加键值对的流程如下：</p><ol><li>判断table是否为空，空则调用resize()初始化table数组，一般发生在初次添加键值对</li><li>参数key哈希值hash与数组table长度相与获取到索引值i，根据table[i]节点是否为空执行不同的操作<ul><li>2.1 table[i]节点p为空：在table[i]创建新节点，跳到步骤3</li><li>2.2 table[i]节点p不为空，根据以下不同的情况执行相应的操作<ul><li>2.2.1 节点p的key、hash与参数的key、hash匹配：即最终操作只需替换原有key的值，将最终节点e设为p，跳到2.2.4</li><li>2.2.2 节点p是一个红黑树节点(TreeNode)类型：根据参数创建新的红黑树节点TreeNode，根据红黑树规则把新节点插入到p节点所在的红黑树上</li><li>2.2.3 其它情况(即链表结构，头节点key与参数key不同)：创建新节点并链接到链表末尾，若链表节点数大于8个，则调用treeifyBin()根据table.length长度进行不同的操作<ul><li>table.length &gt;= 64，将所有的Node链表节点转为TreeNode红黑树节点</li><li>table.length &lt; 64,调用resize()将table.length左移一位(原lengh乘2)，即使链表节点数&gt;8依旧保持链表结构</li></ul></li><li>2.2.4 设置e节点key新值，返回key旧值</li></ul></li></ul></li><li>节点新增成功后的HashMap相关操作属性更新</li></ol><h3 id="实力-例-验证"><a href="#实力-例-验证" class="headerlink" title="实力(例)验证"></a>实力(例)验证</h3><blockquote><p>为了简单直接的显示<code>HashMap</code>结构，这个博主直接的把<code>HashMap</code>实例里的核心属性都print出来了。</p></blockquote><ol><li><p>table容量&lt;64时，key hashCode相同的节点数&gt;8依旧会保持链表结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void stringKey() throws NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;(32);</span><br><span class="line">    &#x2F;&#x2F; 9个hashKey相同的字符串集合，map容量&lt;64时会在添加第9个&quot;20kf&quot;进行扩容而不会树化，即32则左移一位为64,集合删除&quot;20kf&quot;则不会扩容仍为32</span><br><span class="line">    Set&lt;String&gt; sameHashKeys &#x3D; Sets.newHashSet(&quot;30lG&quot;, &quot;31MG&quot;, &quot;31Lf&quot;, &quot;30kf&quot;, &quot;1nlG&quot;, &quot;2PLf&quot;, &quot;1oLf&quot;, &quot;2OlG&quot;, &quot;2Okf&quot;);</span><br><span class="line">    Field thresholdField &#x3D; HashMap.class.getDeclaredField(&quot;threshold&quot;);</span><br><span class="line">    Field tableField &#x3D; HashMap.class.getDeclaredField(&quot;table&quot;);</span><br><span class="line">    thresholdField.setAccessible(true);</span><br><span class="line">    tableField.setAccessible(true);</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    IntStream.range(0, 10).forEach(i -&gt; map.put(String.valueOf(i), i));</span><br><span class="line">    sameHashKeys.forEach(key -&gt; map.put(key, random.nextInt(25)));</span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; sets &#x3D; map.entrySet();</span><br><span class="line">    Map.Entry&lt;String, Integer&gt;[] table &#x3D; (Map.Entry&lt;String, Integer&gt;[]) tableField.get(map);</span><br><span class="line">    long notNullCount &#x3D; Arrays.stream(table)</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .count();</span><br><span class="line">    Set&lt;Class&gt; nodeClasses &#x3D; Arrays.stream(table)</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .map(Object::getClass)</span><br><span class="line">            .collect(Collectors.toSet());</span><br><span class="line">    &#x2F;&#x2F; 输出格式化</span><br><span class="line">    String tableString &#x3D; JSONObject.toJSONString(table)</span><br><span class="line">            .replaceAll(&quot;,null&quot;, &quot;&quot;)</span><br><span class="line">            .replaceAll(&quot;null,&quot;, &quot;&quot;)</span><br><span class="line">            .replaceAll(&quot;\\&#123;|&#125;|\&quot;&quot;, &quot;&quot;)</span><br><span class="line">            .replaceAll(&quot;:&quot;, &quot;&#x3D;&quot;)</span><br><span class="line">            .replaceAll(&quot;,&quot;, &quot;, &quot;);</span><br><span class="line">    System.out.println(&quot;map.size():&quot; + map.size() + &quot;, table.length: &quot; + table.length</span><br><span class="line">            + &quot;, table node count: &quot; + notNullCount + &quot;, entrySet size: &quot; + sets.size());</span><br><span class="line">    System.err.println(&quot;node classes: &quot; + nodeClasses);</span><br><span class="line">    map.remove(&quot;30lG&quot;);</span><br><span class="line">    System.out.println(&quot;table:  &quot; + JSONObject.toJSONString(table));</span><br><span class="line">    System.out.println(&quot;evict null table: &quot; + tableString);</span><br><span class="line">    System.out.println(&quot;entrySet: &quot; + sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.size():19, table.length: 64, table node count: 11, entrySet size: 19</span><br><span class="line">node classes: [class java.util.HashMap$Node]</span><br><span class="line">table:  [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,&#123;&quot;31MG&quot;:22&#125;,&#123;&quot;0&quot;:0&#125;,&#123;&quot;1&quot;:1&#125;,&#123;&quot;2&quot;:2&#125;,&#123;&quot;3&quot;:3&#125;,&#123;&quot;4&quot;:4&#125;,&#123;&quot;5&quot;:5&#125;,&#123;&quot;6&quot;:6&#125;,&#123;&quot;7&quot;:7&#125;,&#123;&quot;8&quot;:8&#125;,&#123;&quot;9&quot;:9&#125;,null,null,null,null,null,null]</span><br><span class="line">evict null table: [30lG&#x3D;13, 0&#x3D;0, 1&#x3D;1, 2&#x3D;2, 3&#x3D;3, 4&#x3D;4, 5&#x3D;5, 6&#x3D;6, 7&#x3D;7, 8&#x3D;8, 9&#x3D;9]</span><br><span class="line">entrySet: [31MG&#x3D;22, 31Lf&#x3D;1, 30kf&#x3D;14, 1nlG&#x3D;7, 2PLf&#x3D;13, 1oLf&#x3D;13, 2OlG&#x3D;21, 2Okf&#x3D;16, 0&#x3D;0, 1&#x3D;1, 2&#x3D;2, 3&#x3D;3, 4&#x3D;4, 5&#x3D;5, 6&#x3D;6, 7&#x3D;7, 8&#x3D;8, 9&#x3D;9]</span><br></pre></td></tr></table></figure></li><li><p>table容量&gt;=64时，key hashCode相同的节点数&gt;8后HashMap会树化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;(33); &#x2F;&#x2F; 有参容量自动调整为64</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.size():19, table.length: 64, table node count: 11, entrySet size: 19</span><br><span class="line">node classes: [class java.util.HashMap$TreeNode, class java.util.HashMap$Node]</span><br><span class="line">table:  [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,&#123;&quot;30kf&quot;:19&#125;,&#123;&quot;0&quot;:0&#125;,&#123;&quot;1&quot;:1&#125;,&#123;&quot;2&quot;:2&#125;,&#123;&quot;3&quot;:3&#125;,&#123;&quot;4&quot;:4&#125;,&#123;&quot;5&quot;:5&#125;,&#123;&quot;6&quot;:6&#125;,&#123;&quot;7&quot;:7&#125;,&#123;&quot;8&quot;:8&#125;,&#123;&quot;9&quot;:9&#125;,null,null,null,null,null,null]</span><br><span class="line">evict null table: [30kf&#x3D;19, 0&#x3D;0, 1&#x3D;1, 2&#x3D;2, 3&#x3D;3, 4&#x3D;4, 5&#x3D;5, 6&#x3D;6, 7&#x3D;7, 8&#x3D;8, 9&#x3D;9]</span><br><span class="line">entrySet: [30kf&#x3D;19, 31MG&#x3D;8, 31Lf&#x3D;16, 1nlG&#x3D;3, 2PLf&#x3D;19, 1oLf&#x3D;20, 2OlG&#x3D;12, 2Okf&#x3D;15, 0&#x3D;0, 1&#x3D;1, 2&#x3D;2, 3&#x3D;3, 4&#x3D;4, 5&#x3D;5, 6&#x3D;6, 7&#x3D;7, 8&#x3D;8, 9&#x3D;9]</span><br></pre></td></tr></table></figure><p>可以看到”30kf”是该红黑树上的root。</p></li></ol><p>那么问题来了，添加映射会调整结构(即更改节点Node类型)，那么删除呢？这个博主有点懒，所以不讲源码给答案：<br><code>HashMap</code>删除节点的过程十分简单，获取节点类型-&gt;根据节点类型进行相应的删除操作，若节点是树节点结构，则判断该树的节点数是否较少(源码文档标注一般为2~6)，较少则把树节点TreeNode转换为普通节点Node，如上例中删除最后4个hashCode相同的节点后(即只剩下5个Node)再打印会发现没有TreeNode了。<br>调用链：<code>hashmap.remove() -&gt; hashmap.removeNode() -&gt; treeNode.removeTreeNode() -&gt; treeNode.untreeify(map)</code></p><h2 id="reszie-调整table容量"><a href="#reszie-调整table容量" class="headerlink" title="reszie()调整table容量"></a>reszie()调整table容量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    &#x2F;&#x2F; table未初始化则设旧容量为0，构造函数并没有初始化table,即首次put添加元素时oldCap都为0</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; oldCap &gt; 0意味着并未首次添加元素时调用方法，而是键值对数量&gt;阈值(即size&gt;threshold)时需要扩容调用该方法，可能发生在上文put(K,V)步骤3</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 容量大于默认最大容量，一般可忽略该情况</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 将新容量设为旧容量的一倍，新阈值设为旧阈值的一倍</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; oldCap&#x3D;0 &amp; oldThr&gt;0，该条件可能发生在调用了有参构造函数初始化threshold、loadFactor后通过put首次添加键值对,并把此时的threshold赋给newCap(有参构造函数处提及有参初始化后threshold是2的幂值)</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    &#x2F;&#x2F; oldCap&#x3D;0 &amp; oldThr&#x3D;0,该条件发生在调用了&#96;HashMap&#96;的无参构造函数情况下，容量与阈值皆设为默认值</span><br><span class="line">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;  &#x2F;&#x2F; default cap 16</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#x2F;&#x2F; default threshold 12</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; float threshold，计算后的浮点型阈值</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置调整后的阈值</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    &#x2F;&#x2F; 创建新的数组进行键值对迁移，所以建议预估好键值对数量调用有参构造函数初始化&#96;HashMap&#96;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F; Node单节点迁移到新的数组</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    &#x2F;&#x2F; 重新哈希</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F; TreeNode拆分为较高树与较低树，若拆分后的树桶节点数&lt; UNTREEIFY_THRESHOLD &#x3D; 6，则取消树化</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    &#x2F;&#x2F; 类似树节点，链表拆分为较高链与较低链</span><br><span class="line">                    &#x2F;&#x2F; loHead &#x3D; Low Head, Lo Tail &#x3D; Low Tail</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F; hiHead &#x3D; High Head, hiTail &#x3D; High Tail</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，<code>HashMap.put(K,V)</code>调用resize()调整大小主要分以下几种情况：</p><ul><li>扩容：<code>oldCap = table.length &gt; 0</code>，resize()结果：<ul><li><code>table.length = oldCap * 2;</code></li><li><code>threshold = table.length * loadFactor</code></li></ul></li><li>有参函数初始化：<code>oldCap = table.length = 0 &amp; oldThr = threshold &gt; 0</code>，resize()结果：<ul><li><code>table.length = threshold;</code>，此处threshold值为跟有参构造函数运算后的threshold值，运算后的threshold值是比构造函数参数threshold大的最小一个2的幂值</li><li><code>threshold = table.length * loadFactor</code></li></ul></li><li>无参函数初始化：<code>oldCap = table.length = 0 &amp; oldThr = threshold = 0</code><ul><li><code>table.length = 16;</code></li><li><code>threshold = 12</code></li></ul></li></ul><p>容量调整后会再根据table中的节点结构进行相应的操作：</p><ul><li>单节点Node无链接：重新哈希</li><li>树节点TreeNode：将树箱中的节点拆分为较高和较低的树箱，如果拆分后的树箱容量&lt;6，则取消树化；拆分后较低的树箱放在新table[旧table原索引]，较高的树箱迁移到新table[原索引+原table.length],详细可看<code>TreeNode.split()</code>源码</li><li>链表结构Node：拆分规则迁移与TreeNode类似，低位链表head node放在新table[原索引]，高位链表迁移到新table[原索引+原table.length]</li></ul><blockquote><p><code>table.length=newCap</code>和<code>threshold</code>调整后会创建新的节点数组进行键值对迁移，所以一般建议初始化时配置好容量避免扩容时的迁移损失。</p></blockquote><h2 id="clear-清空映射"><a href="#clear-清空映射" class="headerlink" title="clear()清空映射"></a>clear()清空映射</h2><p>clear()只是简单的把table数组的所有元素置为null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">        size &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="疑问record-amp-总结"><a href="#疑问record-amp-总结" class="headerlink" title="疑问record &amp; 总结"></a>疑问record &amp; 总结</h1><ol><li><p><code>entrySet()</code>方法返回的明明是一个<code>new EntrySet()</code>，为什么却打印出了完整的<code>HashMap</code>映射?<br><code>EntrySet</code>继承了<code>AbstractSet</code>类并实现了<code>iterator()</code>方法，<code>AbstractSet</code>类<code>toString()</code>方法会调用<code>iterator()</code>方法获取迭代器，再通过<code>Iterator.next()</code>进行元素的字符串拼接。<code>EntrySet。iterator()</code>返回一个实现了<code>Iterator</code>接口的类<code>EntryIterator</code>，通过<code>EntryIterator.next()</code>可以遍历获取<code>HasMap</code>中的所有<code>Node</code>，所以即使<code>HashMap</code>的entrySet属性没有初始化但通过<code>entrySet()</code>方法依旧可以获取<code>HashMap</code>的完整映射。</p></li><li><p>hashCode相同的key映射数超过8个并不一定就会转为红黑树结构<br><code>HashMap</code>当同hashCode的节点Node超过8个且table数组容量&gt;=64才会转为红黑树结构，否则容量&lt;64时只会进行扩容保存链表结构，Result.png:<br><img src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/hexo-blog/Java%E5%9F%BA%E7%A1%80/HashMap-tree.png" alt="HashMap-tree.png"></p></li><li><p>resize()进行容量调整并不一定会使每个节点进行重新哈希(rehash),重新哈希只会出现在无链接的单节点上</p></li></ol><blockquote><p>如有笔误，还请指出</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;HashMap在1.8之后通过数组(table)属性使用单向链表 + 红黑树的结构组合提高查找效率，于是我大致的画了下图：&lt;br&gt;&lt;img 
      
    
    </summary>
    
    
      <category term="Java" scheme="https://wilson-he.gitee.io/categories/Java/"/>
    
    
      <category term="Java集合" scheme="https://wilson-he.gitee.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>谈谈个人对JDK函数式编程的认知与使用</title>
    <link href="https://wilson-he.gitee.io/function-programming/"/>
    <id>https://wilson-he.gitee.io/function-programming/</id>
    <published>2020-06-02T12:23:05.883Z</published>
    <updated>2020-06-02T12:23:05.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>该文章主要介绍JDK中各种常见的函数式接口，并会附上一些个人对函数式编程的一些扩展思考与实际用法。</p><h1 id="常见的函数式接口介绍"><a href="#常见的函数式接口介绍" class="headerlink" title="常见的函数式接口介绍"></a>常见的函数式接口介绍</h1><p>jdk1.8的函数式接口都在rt.jar中<code>java.util.function</code>包下，以下以jdk集合类与个人常用的接口进行介绍：</p><ul><li><p><code>Function&lt;T,R&gt;</code>：传入类型为T的对象并执行含返回值(返回值为R-return类型)的指定方法，方法可临时实现。常见于类Optional<code>{map();flatMap();}</code>、Stream<code>{map();flatMap();}</code>、Comparator<code>{thenComparing();}</code>等，MybatisPlus 3.0版本之后的<code>SFunction</code>接口与该接口作用相同，区别在于添加了序列化，使开发者可通过传入getter Function匹配对应字段而无需再写字段名进行匹配，免除字段名写错的问题。</p></li><li><p><code>BiFunction&lt;T,U,R&gt;</code>：传入类型为T、U类型(T、U可以相同)的两个对象并执行含返回值的指定方法，方法可临时实现。常见于类Stream<code>{reduce();}</code>、Map<code>{replaceAll();computeIfPresent();compute();merge();}</code>等。</p></li><li><p><code>Consumer&lt;T&gt;</code>：传入单个对象并执行对象中无返回值的指定方法，方法可临时实现。常见于类List<code>{foreach();}</code>、Stream<code>{foreach();}</code>、Optional<code>{ifPresent();}</code>等。</p></li><li><p><code>BiConsumer&lt;T, U&gt;</code>：传入两个对象并执行对象中无返回值的指定方法，方法可临时实现。常见于类Stream<code>{collect();}</code>、Map<code>{foreach();}</code>等。</p></li><li><p><code>Supplier&lt;T&gt;</code>：供应商接口，可理解为对象的无参构造函数代理接口，每次调用其get()方法都会产生一个新的对象。常见于类Stream<code>{generate();collect();}</code>Objects<code>{requireNonNull();}</code>、ThreadLocal<code>{withInitial();}</code></p></li><li><p><code>Predicate&lt;T&gt;</code>：传入一个对象返回其指定行为方法执行结果布尔值，方法可临时实现。常见于类Optional<code>{filter();}</code>、Stream<code>{filter();anyMatch();allMatch();noneMatch();}</code>、ArrayList<code>{removeIf();}</code>等</p></li><li><p><code>BiPredicate&lt;T, U&gt;</code>：可根据前面的Bi接口与<code>Predicate</code>推断，不再多作阐述</p></li></ul><h1 id="常见的函数式接口用法"><a href="#常见的函数式接口用法" class="headerlink" title="常见的函数式接口用法"></a>常见的函数式接口用法</h1><p><strong>Stream中的函数式编程</strong></p><p>以下先以一段代码简单的介绍jdk中的函数式用法：</p><pre><code>List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);String result = list.stream()                .filter(str -&gt; !StringUtils.equals(str, &quot;c&quot;))   // ① 参数为Predicate&lt;? super String&gt;,返回值为Stream&lt;String&gt;                .map(str -&gt; str + &quot;,&quot;)   // ② 参数为Function&lt;? super String, ? extends String&gt;,返回值为Stream&lt;String&gt;                .reduce((current, next) -&gt; current + next) // ③ 参数为BinaryOperator&lt;String&gt;,返回值为Optional&lt;String&gt;                .orElse(&quot;&quot;);</code></pre><p>List转为Stream后Stream中的泛型都会对应为List元素的类型，以下为上面几个stream对象方法的简单讲解：<br>①：实现了一个<code>Predicate&lt;String&gt;</code>接口，并让Stream对象调用该接口的实现操作去过滤获取列表中元素值不为<code>&quot;c&quot;</code>的元素<br>②:  实现了一个<code>Function&lt;String,String&gt;</code>接口，在每个元素末尾添加字符串”,”，并返回添加后的结果<br>③： 实现了一个<code>BinaryOperator&lt;String&gt;</code>接口，将stream的当前元素与下一个元素进行拼接并返回拼接结果。<code>BinaryOperator&lt;T&gt;</code>是<code>BiFunction&lt;T,U,R&gt;</code>的子接口，在2个参数类型与返回类型都相同的情况下可使用BinaryOperator接口替代<code>BiFunction</code>接口，但两个接口实质上都需要实现apply()方法进行操作并返回结果，并无太大区别，可把<code>BinaryOperator</code>当<code>成BiFunction</code>的一个子集，其定义如下：</p><pre><code>@FunctionalInterfacepublic interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; {    ......}</code></pre><p>单看以上代码可能还无法体现出为什么叫函数式编程的原因，现在把以上代码还原为为函数实现显示样式：</p><pre><code>String result = list.stream()        .filter(new Predicate&lt;String&gt;() {            @Override            public boolean test(String s) {                return !StringUtils.equals(s, &quot;c&quot;);            }        })        .map(new Function&lt;String, String&gt;() {            @Override            public String apply(String s) {                return s + &quot;,&quot;;            }        })        .reduce(new BinaryOperator&lt;String&gt;() {            @Override            public String apply(String current, String next) {                return current + next;            }        })        .orElse(&quot;&quot;);</code></pre><p>两段的执行代码都可编译执行，对比可知第一段代码只是对第二段代码的简化，第二段代码中详细的显示了对列表转stream后的操作实现了哪些接口与实现的函数操作，显得十分臃肿，而第一段代码只显示了实现的函数操作，故个人认为将重点放在函数实现操作便是函数式编程的核心。<br>相信各个读者都发现了所有函数式接口所需实现的函数都有且仅有一个，个人认为目的除了更优雅的显示以外，还可以让程序知道即使我传入的是一个函数式接口实现类，程序依然会清楚它还要再去执行该类型的指定函数。</p><p><strong>List中的函数式编程</strong><br>List中含函数式接口参数的方法主要为foreach(Consumer)，遍历元素时将元素作为参数传入Consumer执行，最简单的例子为<code>list.forEach(System.out::println);</code>，调用System.out对象的println方法打印遍历的当前元素。</p><p><strong>Map中的函数式编程</strong><br>Map中个人常用的含函数式接口参数的方法主要为<code>foreach(BiConsumer&lt;? super K, ? super V&gt;)</code>和<code>compute(K,            BiFunction&lt;? super K, ? super V, ? extends V&gt;)</code>，其余的相信大家可以触类旁及。foreach为遍历当前map中的元素，前面介绍BiConsumer需要传入两个参数，而map.foreach()执行时每个key、value则作为参数传入到BiConsumer。虽然说需要传两个参数给BiConsumer，但不代表每个参数都必须用到，如下例中的BiConsumer只对每个val参数列表添加<code>“z”</code>字符串而没有用到key参数：</p><pre><code>Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();map.put(&quot;0&quot;, Lists.newArrayList(&quot;&quot;));map.put(&quot;1&quot;, Lists.newArrayList(&quot;a&quot;));map.put(&quot;2&quot;, Lists.newArrayList(&quot;a&quot;, &quot;b&quot;));map.put(&quot;3&quot;, Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));map.forEach((k,v) -&gt; v.add(&quot;z&quot;)); // ① 每个val列表末尾添加z字符串</code></pre><p>如果觉得有点难理解的可看以下函数还原代码：</p><pre><code>map.forEach(new BiConsumer&lt;String, List&lt;String&gt;&gt;() {   @Override    public void accept(String key, List&lt;String&gt; list) {        list.add(&quot;z&quot;);     }});</code></pre><p>Map的compute()方法根据名称大家也可以估到该方法是进行某些计算后再去设计key的值，可用于Map中指定key的值计算，在实际开发中个人常用于该情况：map的val为列表，map需要为指定key的val添加元素，添加前需判断val列表是否为空，为空则初始化后再添加，不为空则直接添加。</p><pre><code>map.compute(&quot;4&quot;,(key, list) -&gt; list == null ? Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) : ListUtils.add(list,&quot;z&quot;));</code></pre><p>以上代码判断map中key为4的列表是否为空，若为空则将map中key为4的val设为元素为<code>&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;</code>的列表，不为空则在原val列表中添加字符串<code>&quot;z&quot;</code>。其中ListUtils为自定义工具类，其add方法返回参数列表，便于一行代码实现目的，实现如下：</p><pre><code>public static &lt;T&gt; List&lt;T&gt; add(List&lt;T&gt; list, T t) {    list.add(t);    return list;}</code></pre><p>看了map.compute()的都知道该函数可以替代在操作map一些情况下的if判断，若把上面的<code>compute()</code>方法使用<code>if</code>执行，则将变成以下代码块：</p><pre><code>if(map.containsKey(&quot;4&quot;)){    map.get(&quot;4&quot;).add(&quot;z&quot;);}else {    map.put(&quot;4&quot;,Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));}</code></pre><p>可以看出适当的使用函数式编程可以为我们减少代码行。</p><p><strong>Optional简化if</strong><br>JDK1.8新增了Optional类使开发者可以减少if的语句块，类也含不少参数为函数式接口的方法，以下以一个简单的代码块进行介绍：</p><pre><code>Classify classify = new Classify();Optional.ofNullable(classify)        .map(Classify::getName)        .orElse(&quot;null&quot;);</code></pre><p>上例中把classify对象交给Optional代理，如果classify对象为空或classify对象中的name属性为空则返回字符串“null”，其中map的参数为Function。</p><p>看到这相信大家都了解到JDK中的函数式方法都是异曲同工，区别只在于在实际使用时泛型对应的实际类型。</p><h1 id="个人扩展用法"><a href="#个人扩展用法" class="headerlink" title="个人扩展用法"></a>个人扩展用法</h1><p>前面基本都是谈个人对函数式的认知与JDK原生类函数式参数方法的用法，而此处开始，是时候展现真正的技术了[doge]。函数式接口运用得当可以省略不少，下文将以几个个人实际开发中思考或使用过的例子进行函数式使用的思维拓展。</p><p>分类例子实体Classify：</p><pre><code>@Data@Accessors(chain = true)public class Classify {    private Long id;    private String name;    private Integer level;    private Long parentId;    private transient List&lt;Classify&gt; sonClassifies;}</code></pre><ul><li><h2 id="自定义ListUtils替代Stream的简单操作"><a href="#自定义ListUtils替代Stream的简单操作" class="headerlink" title="自定义ListUtils替代Stream的简单操作"></a>自定义ListUtils替代Stream的简单操作</h2></li></ul><p>现有一个<code>List&lt;Classify&gt;</code>的列表对象，现在需要将列表中所有分类的名字重新提取为一个列表，了解Stream会这样写：</p><pre><code>List&lt;String&gt; names = list.stream()        .map(Classify::getName)        .collect(Collectors.toList());</code></pre><p>又有一个需求需要将列表元素转化成key为id，value为name的映射，这时会写成如下：</p><pre><code>Map&lt;Long,String&gt; idNameMap =   list.stream()        .collect(Collectors.toMap(Classify::getId, Classify::getName));</code></pre><p>又又有一个需求需要将所有分类转换成key为parentId，value为子分类元素列表的映射，这时会写成如下：</p><pre><code>Map&lt;Long, List&lt;Classify&gt;&gt; parentSonsMap = list.stream()        .collect(Collectors.groupingBy(Classify::getParentId));</code></pre><p>以上写法都是比较普通的写法，应该任何人都可以接受，但我想这么简单的操作可不可以一行解决呢？也有部分开发者认为把所有stream方法调用放到同一行就可以了，但对我而言这会影响代码的可读性(虽然影响可能不大)。在开发者以上List转换的状况虽然不多，但也不算少，为了可一行代码取代Stream的简单操作，个人撸了一个List工具类放到了自己的通用框架中，通过Function作为参数取代Stream的简单操作，完整如下：</p><pre><code>public class ListUtils {    private ListUtils() {    }    public static &lt;T&gt; List&lt;T&gt; add(List&lt;T&gt; list, T t) {        list.add(t);        return list;    }    public static boolean isEmpty(Collection collection) {        return collection == null || collection.isEmpty();    }    public static boolean isNotEmpty(Collection collection) {        return !isEmpty(collection);    }    public static &lt;T&gt; ArrayList&lt;T&gt; newArrayList(T... elements) {        ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(elements.length + elements.length &gt;&gt; 1 + 5);        Collections.addAll(list, elements);        return list;    }    /**     * 条件为true时才添加元素     *     * @param condition  条件     * @param collection 集合     * @param val     * @return 添加结果     */    public static &lt;T&gt; boolean addIf(boolean condition, Collection&lt;T&gt; collection, T val) {        return condition &amp;&amp; collection.add(val);    }    /**     * 从对象列表中提取对象属性     *     * @param list      对象列表     * @param valGetter 对象属性get方法     * @param &lt;T&gt;       对象     * @param &lt;V&gt;       对象属性     * @return 对象属性列表     */    public static &lt;T, V&gt; List&lt;V&gt; collectToList(Collection&lt;T&gt; list, Function&lt;T, V&gt; valGetter) {        List&lt;V&gt; properties = new ArrayList&lt;&gt;(list.size());        list.forEach(e -&gt; properties.add(valGetter.apply(e)));        return properties;    }    /**     * 从对象列表中提取指定属性为key,当前对象为value转为map     *     * @param list     * @param keyGetter     * @param &lt;T&gt;     * @param &lt;K&gt;     * @return     */    public static &lt;T, K&gt; Map&lt;K, T&gt; collectToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter) {        Map&lt;K, T&gt; propertiesMap = new HashMap&lt;&gt;(list.size());        list.forEach(e -&gt; propertiesMap.put(keyGetter.apply(e), e));        return propertiesMap;    }    /**     * 从对象列表中提取指定属性T为key,属性V为value转为map     *     * @param list      对象列表     * @param keyGetter     * @param valGetter     * @param &lt;T&gt;     * @param &lt;K&gt;     * @param &lt;V&gt;     * @return     */    public static &lt;T, K, V&gt; Map&lt;K, V&gt; collectToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter, Function&lt;T, V&gt; valGetter) {        Map&lt;K, V&gt; propertiesMap = new HashMap&lt;&gt;(list.size());        list.forEach(e -&gt; propertiesMap.put(keyGetter.apply(e), valGetter.apply(e)));        return propertiesMap;    }    /**     * 根据列表对象中的某属性值为key划分列表,value为key的属性值相同的对象列表,     * 功能同stream().collect(Collectors.groupingBy())     *     * @param list     * @param keyGetter     * @param &lt;T&gt;     * @param &lt;K&gt;     * @return     */    public static &lt;T, K&gt; Map&lt;K, List&lt;T&gt;&gt; groupToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter) {        Map&lt;K, List&lt;T&gt;&gt; propertiesMap = new HashMap&lt;&gt;(list.size());        for (T each : list) {            propertiesMap.compute(keyGetter.apply(each),                    (key, valueList) -&gt; isEmpty(valueList) ? add(new ArrayList&lt;&gt;(list.size()), each) : add(valueList, each));        }        return propertiesMap;    }    /**     * 根据列表对象中的某属性值为key划分列表,value为key的属性值相同的对象列表,value为key的属性值相同的对象中指定属性的值列表,     * 功能同stream().collect(Collectors.groupingBy())     *     * @param list     * @param keyGetter     * @param valGetter     * @param &lt;T&gt;     * @param &lt;K&gt;     * @param &lt;V&gt;     * @return     */    public static &lt;T, K, V&gt; Map&lt;K, List&lt;V&gt;&gt; groupToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter, Function&lt;T, V&gt; valGetter) {        Map&lt;K, List&lt;V&gt;&gt; propertiesMap = new HashMap&lt;&gt;(list.size());        for (T each : list) {            K key = keyGetter.apply(each);            List&lt;V&gt; values = Optional.ofNullable(propertiesMap.get(key)).orElse(new ArrayList&lt;&gt;());            values.add(valGetter.apply(each));            propertiesMap.put(key, values);        }        return propertiesMap;    }    /**     * 获取列表中重复的值     *     * @param list     * @param &lt;T&gt;     * @return     */    public static &lt;T&gt; Set&lt;T&gt; collectRepeats(Collection&lt;T&gt; list) {        Set&lt;T&gt; set = new HashSet&lt;&gt;(list.size());        return list.stream()                .filter(e -&gt; !set.add(e))                .collect(Collectors.toSet());    }    /**     * 按指定大小，分隔集合，将集合按规定个数分为n个部分     *     * @param &lt;T&gt;     * @param list     * @param len     * @return     */    public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; splitList(List&lt;T&gt; list, int len) {        if (list == null || list.isEmpty() || len &lt; 1) {            return Collections.emptyList();        }        List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();        int size = list.size();        int count = (size + len - 1) / len;        for (int i = 0; i &lt; count; i++) {            List&lt;T&gt; subList = list.subList(i * len, ((i + 1) * len &gt; size ? size : len * (i + 1)));            result.add(subList);        }        return result;    }}</code></pre><p>看看使用该工具类替代Stream简单操作后的效果吧：</p><pre><code>List&lt;String&gt; namess = ListUtils.collectToList(list,Classify::getName);Map&lt;Long, String&gt; idMap = ListUtils.collectToMap(list,Classify::getId,Classify::getName);Map&lt;Long, List&lt;Classify&gt;&gt; parentSonsMap = ListUtils.groupToMap(list,Classify::getParentId);// 将List转化成key为parentId,value为子分类name列表的映射Map&lt;Long, List&lt;String&gt;&gt; parentSonNamesMap = ListUtils.groupToMap(list,Classify::getId,Classify::getName);</code></pre><p>可以看出通过函数式接口作为参数传递，不仅可以增加程序的可读性，还可以为我们的编码开发添加不少扩展性。</p><ul><li><h2 id="简化局部不同多处相同的代码块"><a href="#简化局部不同多处相同的代码块" class="headerlink" title="简化局部不同多处相同的代码块"></a>简化局部不同多处相同的代码块</h2></li></ul><p>局部不同多出相同的代码块重复出现的状况总会遇到，如一些业务代码前后都相同唯独中间不同，如DB连接-操作-释放、Ssh连接-操作-释放，以下将以一个ssh连接-操作-释放的代码来扩展函数式编程简化代码的用法。<br>可能会有人疑问ssh连接-操作-释放这样的实际操作业务不多吧？就在一段时间之前，上级让我去Zabbix查看各服务器的CPU、内存、磁盘使用率然后写入文档。看到机器数的我内心是拒接的，于是想出了使用java ssh连接到服务器执行相应的查看指令然后提取占用率打印到控制台上，再copy到文档中（反正得到了默许了）。以下是未优化前的两个查询方法：</p><pre><code>/** * 查询cpu占用率 */public static String cpuPercent(String ip, String username, String passw    JSch jsch = new JSch();    Session session = null;    Channel channel = null;    String cpuPercent = null;    try {        session = jsch.getSession(username, ip, 22);        Properties config = new Properties();        config.put(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);        session.setConfig(config);        session.setPassword(password);        session.connect();        String cmd = &quot;sar -u 3 1|awk &apos;{print $8}&apos;|tail -1&quot;;        channel = session.openChannel(&quot;exec&quot;);        ((ChannelExec) channel).setCommand(cmd);        ((ChannelExec) channel).setErrStream(System.err);        ((ChannelExec) channel).setPty(true);        channel.connect();        InputStream in = channel.getInputStream();        String output = IOUtils.toString(in, StandardCharsets.UTF_8);        cpuPercent = HUNDRED.subtract(BigDecimal.valueOf(Double.valueOf(                .setScale(2, RoundingMode.HALF_UP)                .toString() + &quot;%&quot;;    } catch (Exception e) {        e.printStackTrace();    } finally {        if (channel != null) {            channel.disconnect();        }        if (session != null) {            session.disconnect();        }    }    return cpuPercent;}/** * 磁盘占用率查询 */public static String diskPercent(String ip, String username, String pass    JSch jsch = new JSch();    Session session = null;    Channel channel = null;    String diskPercent = null;    try {        session = jsch.getSession(username, ip, 22);        Properties config = new Properties();        config.put(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);        session.setConfig(config);        session.setPassword(password);        session.connect();          String cmd = &quot;df -hl | grep apps|tail -1|awk &apos;{print $4}&apos;&quot;;        String cmd = &quot;df -hl | grep apps|tail -1|awk &apos;{print $5}&apos;&quot;;        channel = session.openChannel(&quot;exec&quot;);        ((ChannelExec) channel).setCommand(cmd);        ((ChannelExec) channel).setErrStream(System.err);        ((ChannelExec) channel).setPty(true);        channel.connect();        InputStream in = channel.getInputStream();        diskPercent = IOUtils.toString(in, StandardCharsets.UTF_8);    } catch (Exception e) {        e.printStackTrace();    } finally {        if (channel != null) {            channel.disconnect();        }        if (session != null) {            session.disconnect();        }    }    return diskPercent;}</code></pre><p>相信大家可以看出Ssh连接与释放的代码块是相同的，唯独操作是不同的，于是我把相同的代码块写入了一个方法中，操作的代码块作为参数，优化后的完整代码如下：</p><pre><code>public class SshClientUtils {    private static final BigDecimal HUNDRED = BigDecimal.valueOf(100);    private static final String RESULT_FORMAT = &quot;%s\t\t%s\t\t%s\t%s&quot;;    /**     * 执行查询cpu、mem、disk命令并打印各占用率     */    public static void exec(SshConfig sshConfig) {        System.err.println(&quot;cpu%\t\tmem%\t\tdisk\tip&quot;);        String username = sshConfig.getUsername();        String password = sshConfig.getPassword();        List&lt;String&gt; ipList = sshConfig.getIpList();        ipList.forEach(ip -&gt; {            String cpuPercent = cpuPercent(ip, username, password);            String memoryPercent = memoryPercent(ip, username, password);            String diskPercent = diskPercent(ip, username, password);            System.out.println(String.format(RESULT_FORMAT, cpuPercent, memoryPercent, diskPercent, ip)                    .replaceAll(&quot;\n|\r\n&quot;, &quot;&quot;));        });    }    /**     * 查询cpu占用率     */    public static String cpuPercent(String ip, String username, String password) {        String cmd = &quot;sar -u 3 1|awk &apos;{print $8}&apos;|tail -1&quot;;        return exec(ip, username, password, cmd, output -&gt; HUNDRED.subtract(BigDecimal.valueOf(Double.valueOf(output)))                .setScale(2, RoundingMode.HALF_UP)                .toString() + &quot;%&quot;);    }    /**     * 内存占用率查询     */    public static String memoryPercent(String ip, String username, String password) {        String cmd = &quot;free|grep Mem&quot;;        return exec(ip, username, password, cmd, output -&gt; {            String[] memories = output.replaceAll(&quot;\\s+&quot;, &quot;,&quot;)                    .substring(5)                    .split(&quot;,&quot;);            double total = Integer.parseInt(memories[0]);            double free = Integer.parseInt(memories[2]);            double buffers = Integer.parseInt(memories[4]);            double cache = Integer.parseInt(memories[5]);            BigDecimal freePercent = BigDecimal.valueOf((free + buffers + cache) / total)                    .setScale(6, RoundingMode.HALF_UP);            return BigDecimal.ONE.subtract(freePercent)                    .multiply(HUNDRED)                    .setScale(2, RoundingMode.HALF_UP)                    .toString() + &quot;%&quot;;        });    }    /**     * 磁盘占用率查询     */    public static String diskPercent(String ip, String username, String password) {        String cmd = &quot;df -hl | grep apps|tail -1|awk &apos;{print $5}&apos;&quot;;        return exec(ip, username, password, cmd, output -&gt; output);    }    /**     * 直接执行命令     */    public static String exec(String ip, String username, String password, String command, Function&lt;String, String&gt; execFunc) {        JSch jsch = new JSch();        Session session = null;        Channel channel = null;        try {            session = jsch.getSession(username, ip, 22);            Properties config = new Properties();            config.put(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);            session.setConfig(config);            session.setPassword(password);            session.connect();            channel = session.openChannel(&quot;exec&quot;);            ((ChannelExec) channel).setCommand(command);            ((ChannelExec) channel).setErrStream(System.err);            ((ChannelExec) channel).setPty(true);            channel.connect();            InputStream in = channel.getInputStream();            String output = IOUtils.toString(in, StandardCharsets.UTF_8);            return func.apply(execFunc);        } catch (Exception e) {            e.printStackTrace();        } finally {            if (channel != null) {                channel.disconnect();            }            if (session != null) {                session.disconnect();            }        }        return null;    }}</code></pre><p>可以看出优化的代码将Ssh的连接与操作都抽象到exec()方法中了，而实际操作则是由入参的Function实现决定，以上便是一个通过Function优化代码部分不同的例子。</p><p><strong>将if-set对象属性通过函数式接口放到对象内部执行</strong><br>话多不如实例，相信大家都遇到过类似以下这样的情况：</p><pre>if(condition1){    classify.setName("Wilson");}if(condition2){    classify.setLevel(5);}</pre><p>好麻烦，能不能再简单一点(我的简单永远没有上限)，现在先对以上代码块分析一下(简化的核心在于抽离)，相同的部分主要有if、classify，不同的部分为condition的值、set方法、set的值，既然有相同的就作为方法，不同的就作为参数吧(是不是跟ssh的例子想法差别不大吧)，于是我在Classify类中添加了以下方法：</p><pre><code>public &lt;V&gt; Classify set(boolean isSet, V value, BiFunction&lt;Classify, V, Classify&gt; setFunction) {    return isSet ? setFunction.apply(this, value) : this;}</code></pre><p>???<br>唔，这里可能有一些门槛，如果暂时不理解或觉得无法灵活运动的也不用着急，代码都是慢慢磨出来的，调用一下吧：</p><pre><code>Classify classify = new Classify();classify.set(true, &quot;Wilson&quot;, Classify::setName)        .set(false, 5, Classify::setLevel);System.out.println(classify);// 打印出Classify(id=null, name=Wilson, level=null, parentId=null, sonClassifies=null)</code></pre><p>由于Classify在类上添加了Lombok的注解<code>@Accessors(chain = true)</code>，所以每个set方法结果都会返回当前对象方便链式调用(我很喜欢链式)，所以上面的set方法可以直接返回apply(this,setFunction)的结果。BiFunction前面有提过是需要两个参数并返回一个结果的，在该例子中，由于Classify的setProperty()是返回当前对象的，所以不能用Function&lt;T,R&gt;作为set()的函数式参数(否则T与R都是Classify，无法设置属性)，Classify对象作为BiFunction的第一个参数，set()方法的value作为第二个参数，当前classify对象作为返回值，这样就可以保持我的对象可以继续链式调用各set方法。<br>也有会有人疑问set方法设置返回值不会影响程序的正常运行(如框架的调用)吗？这里个人是从反射与Java关键字void的角度思考过后就一直习惯使对象set方法返回当前对象了，这里希望大家也思考一下便不多作讲解了。</p><ul><li><h2 id="使用Supplier再提高一下copyProperties的逼格"><a href="#使用Supplier再提高一下copyProperties的逼格" class="headerlink" title="使用Supplier再提高一下copyProperties的逼格"></a>使用Supplier再提高一下copyProperties的逼格</h2><p>相信接触过Spring的都会使用过其中BeanUtils的<code>copyProperties()</code>方法，个人经常使用该方法进行VO属性到Model属性的设置，Model一般都是现场new所以内部属性都是的，反正都是空的何不再通过Supplier函数式接口扩展一下工具类提高一下逼格呢？于是便有了以下代码：</p><p>  @NoArgsConstructor<br>  public class ObjectUtils {</p><pre><code>public static &lt;S, T&gt; T copyProperties(S source, T target) {    BeanUtils.copyProperties(source, target);    return target;}public static &lt;S, T&gt; T copyProperties(S source, Supplier&lt;T&gt; targetSupplier) {    T target = targetSupplier.get();    BeanUtils.copyProperties(source, target);    return target;}</code></pre><p>  }</p></li></ul><p>再以一段Controller的伪代码演示一下:<br><code>Long id = classifyService.insert(ObjectUtils.copyProperties(classifyVO,Classify::new));</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;该文章主要介绍JDK中各种常见的函数式接口，并会附上一些个人对函数式编程的一些扩展思考与实际用法。&lt;/p&gt;
&lt;h1 id=&quot;常见的函数式接口
      
    
    </summary>
    
    
      <category term="Java基础" scheme="https://wilson-he.gitee.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://wilson-he.gitee.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList与LinkedList区别与源码分析</title>
    <link href="https://wilson-he.gitee.io/list/"/>
    <id>https://wilson-he.gitee.io/list/</id>
    <published>2020-05-14T02:32:26.699Z</published>
    <updated>2020-05-14T02:32:26.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构在计算机中的存储方式(线性表的物理结构)主要分为以下两种：</p><ul><li><strong>顺序存储结构</strong>：数据存储在连续的存储单元中，如数组<ul><li>优点<ul><li>存储密度大（＝1），存储空间利用率高，不需要为元素之间的逻辑关系而增加额外存储空间</li><li>随机存取表中元素</li></ul></li><li>缺点<ul><li>插入和删除操作需要移动元素，效率低</li><li>当线性表变化较大的时候，难以确定存储空间的容量<br><img src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/hexo-blog/Java%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84.png" alt="%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84.png"></li></ul></li></ul></li><li><strong>链式存储结构</strong>：数据存放在任意的存储单元中，如链表<ul><li>优点：<ul><li>逻辑相邻的节点物理上不必相邻，插入、删除灵活，只需改变节点中的指针指向</li></ul></li><li>缺点：<ul><li>存储密度小（&lt;1），存储空间利用率低，需为元素之间的逻辑关而增加额外存储空间</li><li>查找节点时需遍历元素节点，效率比顺序存储慢<br><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2132913655,2932434764&fm=11&gp=0.jpg" alt="u=2132913655,2932434764&amp;fm=11&amp;gp=0.jpg"></li></ul></li></ul></li></ul><p><code>ArrayList</code>是基于数组结构(顺序存储)的列表，<code>LinkedList</code>是基于双向链表(链表存储)的列表，在介绍了以上两种存储结构后，相信即使不了解<code>LinkedList</code>和<code>ArrayList</code>的源码也知道这两个列表的核心区别了，但作为开发者，一定的源码了解还是需要的。</p><h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><h2 id="核心结构-类图分析"><a href="#核心结构-类图分析" class="headerlink" title="核心结构(类图分析)"></a>核心结构(类图分析)</h2><p><img src="http://www.plantuml.com/plantuml/png/XPBXQi8m58N_zoakx8yoz0baCzGC19sY7SoDKTBqEZBI19hhS6vxzzMk6cDbAxG_pldkwMrpXev4IPj2HyeGbciX4IRAqUVtYR0G9hS5anAT2unOMuCYqnYgLckKfAm9v2MMIcYrQtYfXNF0CaUba1JCX5QzJWJLTGMLO9n2Gw2gkx1vR3U6ekD8MOeFp_V0aI0bOQsCqFN8YD-nXqcIncpEud6okiJDiZUKzFm2V3fFLYcVy2c_JqOiON_IJVGXEVrdskyqPOyfMopOAbsEdtX3xGsdTdZ-uVvzgB6eX94WKKFNa5chKHWGUTxXWDsspBJk-5yzk0NS4fhS0Ry1USwNMDXt39C2HzNdaEFsu7DuHMhBHs6sxlok3xPR7LhaLu71Lxz_eGrHA3LehnUq8ze_wWJV0A-5w6cNQzjFUAwTTcpwkU5RtVQ6QF9DeNy0" alt="ArrayList Class Diagram"></p><ul><li><p><code>List</code>：声明是一个有序的集合，可以控制元素位置并索引访问。</p></li><li><p><code>RandomAccess</code>：声明支持快速随机访问的标记接口，常用于列表类实现。该接口的主要目的是允许通用算法更改其行为，即必要时选择更好的算法进行性能上的提高，实现了该接口的列表使用for遍历比迭代器<code>Iterator</code>遍历效率高。<br><img src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/hexo-blog/Java%E5%9F%BA%E7%A1%80/RandomAccess.png" alt="RandomAccess.png"></p></li><li><p><code>Serializable</code>：启用类的可序列化特性。</p></li><li><p><code>Cloneable</code>：声明类是可克隆的，且调用<code>clone()</code>方法时不会抛出<code>CloneNotSupportedException</code></p></li><li><p><code>AbstractList</code>：提供了<code>List</code>接口的基本实现，并尽可能的减少<code>List</code>接口”随机访问”数据存储支持的工作</p></li></ul><h2 id="属性解析"><a href="#属性解析" class="headerlink" title="属性解析"></a>属性解析</h2><p><code>DEFAULT_CAPACITY</code>：默认容量10，用于构造函数初始化与容量运算。<br><code>EMPTY_ELEMENTDATA</code>：共享的空数组，调用<code>ArrayList</code>有参构造函数参数容量值为0(即一般考虑不再进行容量扩展)时赋给<code>elementData</code>。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    elementData &#x3D; c.toArray();</span><br><span class="line">    if ((size &#x3D; elementData.length) !&#x3D; 0) &#123;</span><br><span class="line">        if (elementData.getClass() !&#x3D; Object[].class)</span><br><span class="line">            elementData &#x3D; Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>：共享的空数组，与<code>EMPTY_ELEMENTDATA</code>区别在于该数组是用来容量运算的，调用<code>ArrayList</code>无参构造函数时会把该对象赋给<code>elementData</code>,添加元素时再重新计算扩容，所以一般建议使用有参构造函数赋予原始容量。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123;</span><br><span class="line">  this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>elementData</code>：存储ArrayList的元素的数组缓冲区。<br><code>size</code>：<code>ArrayList</code>包含的元素数量，<code>elementData</code>数组的元素数量。<br><code>MAX_ARRAY_SIZE</code>：分配的最大数组大小,值为Integer.MAX-8</p><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="add-E-添加元素"><a href="#add-E-添加元素" class="headerlink" title="add(E)添加元素"></a>add(E)添加元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * (1) 数组末尾添加元素 </span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">    &#x2F;&#x2F; 容量值自增并将元素附加到数组末尾</span><br><span class="line">    elementData[size++] &#x3D; e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * (2) 确保内部的容量能满足所需最小容量minCapacity</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * (3) 根据数组所需的最小容量minCapacity进行容量计算</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; 若元素数组为引用的空数组，则返回默认容量(10)与minCapacity之间的最大值，不为空则返回minCapacity</span><br><span class="line">    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    return minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * (4) 根据数组所需的最小容量minCapacity确保精确的容量</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    &#x2F;&#x2F; 判断添加元素后的元素数目是否大于数组长度，true则进行数组扩容，false则完成元素添加</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * (5) 根据数组所需的最小容量minCapacity判断是否扩容</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    &#x2F;&#x2F; 判断添加元素后的元素数目是否大于数组长度，true则进行扩容，false则完成元素添加</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * (6) 重新建一个至少可以容纳最小容量minCapacity的数组并进行数组元素拷贝，消耗大</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    &#x2F;&#x2F; 若所需最小容量minCapacity大于旧容量oldCapacity+oldCapacity右移1值，则新容量为minCapacity，反正新容量为旧容量运算值</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    &#x2F;&#x2F; 大容量数组，一般不会调用到</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    &#x2F;&#x2F; 新建一个长度为newCapacity的数组并将旧数组元素负责过来</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 大容量计算，一般不会调用到</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">        throw new OutOfMemoryError();</span><br><span class="line">    return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下重新整理一下新增的的步骤：</p><ol><li>add()数组末尾添加元素 </li><li>ensureCapacityInternal()确保内部的容量能满足所需最小容量minCapacity</li><li>calculateCapacity()根据数组所需的最小容量minCapacity进行容量计算</li><li>ensureExplicitCapacity()根据数组所需的最小容量minCapacity确保精确的容量</li><li>ensureExplicitCapacity()根据数组所需的最小容量minCapacity判断是否扩容,若需要则进行步骤6</li><li>grow()重新建一个至少可以容纳最小容量minCapacity的数组并进行数组元素拷贝，消耗大，所以建议一般使用有参构建函数创建列表时设置好容量</li></ol><p>由上述流程可以看出，<code>ArrayList</code>的<code>add(E e)</code>方法在容量足以确保的情况下效率是很高的，直接将新元素赋予数组元素的末尾下标+1即可，复杂度仅为O(1)。</p><h3 id="add-int-E-增元素"><a href="#add-int-E-增元素" class="headerlink" title="add(int, E)增元素"></a>add(int, E)增元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1, size - index);</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的主要核心在<code>System.arraycopy()</code>方法，该方法把elementData数组中的index位置起的size-index个元素(即index下标后的元素)复制到下标index+1，然后再把新的元素element赋到index下标位置。由于需要进行元素的位置逐个后移，所以性能耗费大，时间复杂度为O(n)，n为指定位置后的元素数目。<br>如在非末尾位置插入元素的操作较多，选择<code>LinkedList</code>效果会比<code>ArrayList</code>更好。</p><h3 id="addAll-Collection-lt-extends-E-gt-添加元素"><a href="#addAll-Collection-lt-extends-E-gt-添加元素" class="headerlink" title="addAll(Collection&lt;? extends E&gt;)添加元素"></a>addAll(Collection&lt;? extends E&gt;)添加元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    Object[] a &#x3D; c.toArray();</span><br><span class="line">    int numNew &#x3D; a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  &#x2F;&#x2F; Increments modCount</span><br><span class="line">    System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">    size +&#x3D; numNew;</span><br><span class="line">    return numNew !&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上源码可以看到当添加集合元素时，也是需要进行数组拷贝的，不过是直接拷贝到列表数组末尾，时间复杂度由集合元素数目而定，即为O(n)。</p><h3 id="remove-Object-删元素"><a href="#remove-Object-删元素" class="headerlink" title="remove(Object)删元素"></a>remove(Object)删元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">            if (elementData[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">            if (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    int numMoved &#x3D; size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然删除元素的主要方面命名为<code>fastRemove()</code>，但从其代码依然可以看出这方法并不fast，指定位置删除元素后还要进行元素前移，性能耗费与指定位置添加差别不大，时间复杂度为O(n)，n为指定位置后的元素数目。<br>如删除元素的操作较多，选择<code>LinkedList</code>效果会比<code>ArrayList</code>更好。</p><h3 id="set-int-E-改元素"><a href="#set-int-E-改元素" class="headerlink" title="set(int, E)改元素"></a>set(int, E)改元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换指定下标数组元素，复杂度为O(1)，效率高。</p><h3 id="get-int-查元素"><a href="#get-int-查元素" class="headerlink" title="get(int)查元素"></a>get(int)查元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据下标获取数组元素，复杂度为O(1)，效率高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ArrayList有以下特点：</p><ul><li>添加元素性能因参数有所区别，但都需注意数组容量不足时ArrayList会进行扩容产生性能消耗<ul><li>add(E)在数组末尾添加元素，复杂度O(1)</li><li>add(int, E)在数组指定位置添加元素，复杂度O(n),n为下标后的元素数目</li><li>addAll(Collection)在数组末尾添加集合元素，复杂度O(n),n为集合中的元素数目</li></ul></li><li>删除元素慢，remove()删除元素，后面元素需逐个移动，复杂度O(n),n为下标后的元素数目</li><li>更改效率高，set(index, E)直接根据下标替换数组元素，复杂度O(1)</li><li>查询效率高，get(index)直接根据下标获取数组元素，复杂度O(1)</li></ul><h1 id="LinkedList源码解析"><a href="#LinkedList源码解析" class="headerlink" title="LinkedList源码解析"></a><code>LinkedList</code>源码解析</h1><h2 id="核心结构-类图分析-1"><a href="#核心结构-类图分析-1" class="headerlink" title="核心结构(类图分析)"></a>核心结构(类图分析)</h2><p><code>LinkedList</code>是基于双向链表数据结构的列表，链表中的每个节点对应内部类<code>Node</code>。<br><img src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/hexo-blog/Java%E5%9F%BA%E7%A1%80/LinkedList-Queue.png" alt="Linked-Queue"></p><p><code>LinkedList</code>实现了<code>List</code>和<code>Deque</code>(双向队列)接口，即该类包含了列表与双向队列的操作方法，其类图如下：<br><img src="http://www.plantuml.com/plantuml/png/TPD1Rl8m48NtFiKiWu2S0Fq_g4rNgAZY14uyL6uTkxKd245xzzfE80uMI4JnzzvunY_osX6trBMAIKre3xn1s4f7bzy4F2cZaTSA9tIFLd8bpuFGAEuSl1g15mPGWIHi6KImglw1nXCboo-Bns5Pf6pXAr5XYveMazePIti_utSN-noD5C25U97MKU5hPmdSyf5LOB4rH-oDAOck0CgoBAPjtZhiS1g5KGeRaaPx76LO_IoN_K1iL7iQ3KCoMwa_KSHi6VZV4iXoxIHg0kd_Jfun4wu97CBK3rN51t4EjJ4AkGwdZoVFyKQfOfnpzHzykAY50xzHS-_l4yfs6XKPfnTukkeLl2Fb-0PsXs9NV_ZcO4BMB0GNCYpB9A4io0Z38tDkQkS3QMWVzj4akGfugCfje_YWyEPCCahjTvFaRdQzBVcfqXkJYUChp7s_y6tP6hNeMlK7" alt="LinkedList类图"></p><ul><li><code>AbstractSequentialList</code>：提供<code>List</code>接口的基本实现，以最小化实现<code>List</code>接口类顺序访问数据存储所需要提供的支持(实现)。</li></ul><p>从类的继承与接口实现角度看，<code>LinkedList</code>与<code>ArrayList</code>的区别在于<code>LinkedList</code>继承了<code>AbstractSequentialList</code>列表类与实现了<code>Deque</code>双向队列接口，少实现了一个快速访问接口<code>RandomAccess</code>，因而相比于<code>ArrayList</code>访问效率会有所不及，但多了双向队列的特性(从这个角度看挺有意思的)。</p><h1 id="LinkedList常用源码解析"><a href="#LinkedList常用源码解析" class="headerlink" title="LinkedList常用源码解析"></a><code>LinkedList</code>常用源码解析</h1><p>由于<code>LinkedList</code>是链表结构列表，所以访问该列表中的元素只能通过第一个节点或最后一个节点遍历获取，因此查询的效率比使用数组根据下标获取元素的<code>ArrayList</code>慢。</p><h2 id="属性解析-1"><a href="#属性解析-1" class="headerlink" title="属性解析"></a>属性解析</h2><p><code>size</code>：列表元素数目<br><code>first</code>：第一个节点<br><code>last</code>：最后一个节点</p><h2 id="方法解析-1"><a href="#方法解析-1" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="add-E-添加元素-1"><a href="#add-E-添加元素-1" class="headerlink" title="add(E)添加元素"></a>add(E)添加元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;   &#x2F;&#x2F;  1</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null); &#x2F;&#x2F;  2</span><br><span class="line">    last &#x3D; newNode; &#x2F;&#x2F;  3</span><br><span class="line">    if (l &#x3D;&#x3D; null) &#x2F;&#x2F;  4</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;</span><br><span class="line">    size++;  &#x2F;&#x2F;  5</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码看出，<code>LinkedList</code>添加元素的流程如下：</p><ol><li>将当前列表的最后一个节点引用赋予临时变量l</li><li>创建一个新的节点存放新元素e，并把最后一个节点的引用l赋予新节点e</li><li>将最后一个节点的last指向新节点newNode</li><li>判断列表之前的最后一个节点是否为空(即列表是否为空)，空则将第一个节点first指向新节点newNode，非空则将之前最后一个节点的下一节点指向新节点</li></ol><p><code>LinkedList</code>的add(E)与addLast(E)的调用与效果是一样的，都是新建一个<code>Node</code>节点并更改最后一个节点的指向，消耗也不大，时间复杂度为O(1)。</p><h3 id="add-int-E-添加元素"><a href="#add-int-E-添加元素" class="headerlink" title="add(int,E)添加元素"></a>add(int,E)添加元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index);  &#x2F;&#x2F; 1. 校验索引是否超出列表范围</span><br><span class="line">    if (index &#x3D;&#x3D; size)</span><br><span class="line">        linkLast(element);  &#x2F;&#x2F; 2. 下标为元素数目则直接末尾添加</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index)); &#x2F;&#x2F; 3. 获取链表中指定索引的节点，为新元素创建节点并插入到指定节点之前</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void checkPositionIndex(int index) &#123;</span><br><span class="line">    if (!isPositionIndex(index))</span><br><span class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean isPositionIndex(int index) &#123;</span><br><span class="line">    return index &gt;&#x3D; 0 &amp;&amp; index &lt;&#x3D; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 3.1 遍历节点以获取指定下标节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; 若index &lt; size &#x2F; 2. 则从第一个节点开始遍历，否则从最后一个节点开始遍历</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 3.2 为新元素创建节点并插入到指定节点之前</span><br><span class="line"> *&#x2F;</span><br><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">    final Node&lt;E&gt; pred &#x3D; succ.prev;</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev &#x3D; newNode;</span><br><span class="line">    if (pred &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        pred.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新梳理一下<code>LinkedList</code>指定位置添加元素流程：</p><ol><li>校验位置索引是否超出列表范围</li><li>若index &lt; size / 2. 则从第一个节点开始遍历，否则从最后一个节点开始遍历</li><li>获取链表中指定索引index的节点，为新元素创建节点并插入到指定节点之前<br>3-1. 若index &lt; size / 2. 则从第一个节点开始遍历，否则从最后一个节点开始遍历，并返回指定索引节点<br>3-2. 为新元素创建节点并插入到指定节点之前</li></ol><p><code>LinkedList</code>虽然要遍历才能获取到指定位置节点，但插入元素时只需新建一个节点并更改相应的引用而已，并没有更多的更改操作，相比<code>ArrayList</code>的列表元素后移性能自然要好上不少，所以当对列表位置添加元素操作较多时选择<code>LinkedList</code>比<code>ArrayList</code>更好。</p><p><img src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/hexo-blog/Java%E5%9F%BA%E7%A1%80/LinkedList-add.png" alt="add(E,index)"></p><h3 id="remove-Object-删除元素"><a href="#remove-Object-删除元素" class="headerlink" title="remove(Object)删除元素"></a>remove(Object)删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 删除节点链接</span><br><span class="line"> *&#x2F;</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next;</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev;</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除节点流程：</p><ol><li>遍历获取目标元素节点</li><li>更改目标节点的上一节点与下一节点引用，更改元素数目</li></ol><p>删除节点与添加节点的操作区别不大，都是遍历更改节点的链接，效率比<code>ArrayList</code>的删除操作效率高。</p><h2 id="get-int-获取节点"><a href="#get-int-获取节点" class="headerlink" title="get(int)获取节点"></a>get(int)获取节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; 若index &lt; size &#x2F; 2. 则从第一个节点开始遍历，否则从最后一个节点开始遍历</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>LinkedList</code>是基于双向链表的数据结构，所以查询时也是按照双向链表的查询方式，需要从头部或尾部开始遍历查找，故查询的性能比基于数组结构的<code>ArrayList</code>要差。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>LinkedList有以下特点：</p><ul><li>增删元素快，遍历到指定节点后只需更改”指针”指向</li><li>查询效率慢，每次查询都需遍历链表</li><li>相比<code>ArrayList</code>需更多的存储空间来存储指向</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;数据结构在计算机中的存储方式(线性表的物理结构)主要分为以下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序存储结构&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="Java基础" scheme="https://wilson-he.gitee.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java集合" scheme="https://wilson-he.gitee.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>基础操作指令</title>
    <link href="https://wilson-he.gitee.io/MongoDB/basic-operate/"/>
    <id>https://wilson-he.gitee.io/MongoDB/basic-operate/</id>
    <published>2020-04-29T01:20:35.437Z</published>
    <updated>2020-04-29T01:20:35.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><p>创建数据库  use {dbName}<br>查看所有数据库 show dbs</p><h1 id="Mongo文档操作"><a href="#Mongo文档操作" class="headerlink" title="Mongo文档操作"></a>Mongo文档操作</h1><h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><h3 id="OR-条件"><a href="#OR-条件" class="headerlink" title="OR 条件"></a>OR 条件</h3><p>or条件语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$or: [</span><br><span class="line">    JSON criteria1,</span><br><span class="line">    JSON criteria2</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>操作条件即为criteria1 or criteria2,如查找age&lt;20与age&gt;20的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.user_base.find(</span><br><span class="line">&#123;</span><br><span class="line">    $or:[</span><br><span class="line">        &#123;age:&#123;$gt:30&#125;&#125;,&#123;age:&#123;$lt:20&#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="大小比较条件操作"><a href="#大小比较条件操作" class="headerlink" title="大小比较条件操作"></a>大小比较条件操作</h3><table><thead><tr><th>操作</th><th>操作符</th></tr></thead><tbody><tr><td>大于</td><td>$gt</td></tr><tr><td>大于等于</td><td>$gte</td></tr><tr><td>小于</td><td>$lt</td></tr><tr><td>小于等于</td><td>$lte</td></tr></tbody></table><h2 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h2><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档，区别在于insert()若以存在相同_id则报duplicate key，save()若指定了_id且_id对应数据存在，则执行更新，反正执行保存。插入语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.&#123;collectionName&#125;.insert(&#123;</span><br><span class="line">    name:&#39;Wilson&#39;,</span><br><span class="line">    age:15</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>数组插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.user_base.insert(&#123;</span><br><span class="line">    name:&#39;Wilson&#39;,</span><br><span class="line">    age:15,</span><br><span class="line">    hobby:[&#39;eat&#39;,&#39;drink&#39;,&#39;play&#39;,&#39;sleep&#39;]   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><p>MongoDB条件更新使用update()函数，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.&#123;collectionName&#125;.update(JSON criteria, JSON objNew, boolean upsert,boolean multi )</span><br></pre></td></tr></table></figure><ul><li>criteria: 更新条件，类似sql的where条件,JSON类型属性值</li><li>objNew: 更新值，类似于sql的set属性值,JSON类型属性值</li><li>upsert: 默认false,如果不存在criteria的条件，是否插入新的记录(objNew,criteria)</li><li>multi: 默认false,是否更新所有找到的记录，默认只更新第一条</li></ul><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.user_base.update(</span><br><span class="line">    &#123;&#39;name&#39;:&#39;Wilson&#39;&#125;,</span><br><span class="line">    &#123;&#39;name&#39;:&#39;Wilson&#39;,&#39;age&#39;:33&#125;,</span><br><span class="line">    false,</span><br><span class="line">    false</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.&#123;collectionName&#125;.remove(</span><br><span class="line">   JSON criteria,</span><br><span class="line">   &#123;</span><br><span class="line">      justOne: &lt;boolean&gt;,</span><br><span class="line">      writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>criteria :必须，删除的文档的条件，空({})则删除全部。</li><li>justOne : （可选）若为true 或 1，则只删除一个文档。</li><li>writeConcern :（可选）抛出异常的级别。</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 清空user_base数据库所有文档</span><br><span class="line">db.user_base.remove(); </span><br><span class="line"></span><br><span class="line"># 删除第一条 age &gt;&#x3D; 20 的数据</span><br><span class="line">db.user_base.remove(</span><br><span class="line">    &#123;age: &#123; $gte:20 &#125;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      justOne: true</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.&#123;collectionName&#125;.find(</span><br><span class="line">   JSON criteria,  </span><br><span class="line">   JSON optionalFields</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure><ul><li>criteria：可选，查询条件，空则查询全部数据</li><li>optionalFields：可选，显示选定字段,如{name:0}则查询结果不包含name字段</li></ul><h3 id="只查询指定字段"><a href="#只查询指定字段" class="headerlink" title="只查询指定字段"></a>只查询指定字段</h3><h3 id="limit-限制返回数量"><a href="#limit-限制返回数量" class="headerlink" title="limit()限制返回数量"></a>limit()限制返回数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.&#123;collectionName&#125;.find().limit(NUMBER)</span><br></pre></td></tr></table></figure><h3 id="skip-跳过指定数量"><a href="#skip-跳过指定数量" class="headerlink" title="skip()跳过指定数量"></a>skip()跳过指定数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.&#123;collectionName&#125;.find().limit(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure><h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort()排序"></a>sort()排序</h3><p>sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，1为升序，-1为降序，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.&#123;collectionName&#125;.find().limit(NUMBER).sort(&#123;&quot;key&quot;: 1&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库操作&quot;&gt;&lt;a href=&quot;#数据库操作&quot; class=&quot;headerlink&quot; title=&quot;数据库操作&quot;&gt;&lt;/a&gt;数据库操作&lt;/h1&gt;&lt;p&gt;创建数据库  use {dbName}&lt;br&gt;查看所有数据库 show dbs&lt;/p&gt;
&lt;h1 id=&quot;Mongo文
      
    
    </summary>
    
    
      <category term="MongoDB" scheme="https://wilson-he.gitee.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://wilson-he.gitee.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Docker搭建基于binlog的Mysql主从同步</title>
    <link href="https://wilson-he.gitee.io/mysql/sync-master-slave/"/>
    <id>https://wilson-he.gitee.io/mysql/sync-master-slave/</id>
    <published>2020-04-28T09:09:37.113Z</published>
    <updated>2020-04-28T09:09:37.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-binlog主从同步简介"><a href="#MySQL-binlog主从同步简介" class="headerlink" title="MySQL binlog主从同步简介"></a>MySQL binlog主从同步简介</h1><p>传统的MySQL提供了一种简单的主从同步方法，主机数据库执行并提交事务，然后将事务异步发送到从数据库，使从机数据库执行相同的语句(如DDL、DML)，默认情况下所有服务器均具有数据的完整副本。主要流程图如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9rbm93bGVkZ2UtcGljdHVyZXMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL215c3FsL2FzeW5jLXJlcGxpY2F0aW9uLWRpYWdyYW0ucG5n?x-oss-process=image/format,png" alt="async-replication-diagram.png"></p><ul><li>主机Mysql通过Binlog Dump线程将日志发送到从机Mysql的IO线程</li><li>I/O线程获取到事件数据后更新到从库的中继日志(relay log)中</li><li>从机Mysql的SQL线程从relay log中获取所有事件并执行(Apply)，SQL线程在执行每个中继日志文件中的所有事件并且不再需要它之后，会自动删除该文件</li></ul><p>目前官方文档提供的主从复制含<a href="https://dev.mysql.com/doc/refman/8.0/en/replication-gtids.html" target="_blank" rel="noopener">使用全局事务标识符(GTID)进行复制</a>与<a href="https://dev.mysql.com/doc/refman/8.0/en/replication-howto.html" target="_blank" rel="noopener">基于二进制日志文件位置(Binary Log File Position)的复制</a>两种，本文主要介绍如何通过Docker+Docker Compose简便搭建基于bin log的Mysql主从复制环境。</p><h1 id="前置环境-安装参考"><a href="#前置环境-安装参考" class="headerlink" title="前置环境(安装参考)"></a>前置环境(<a href="https://mp.csdn.net/postedit/103989245" target="_blank" rel="noopener">安装参考</a>)</h1><ul><li><a href="https://linuxize.com/post/how-to-install-and-use-docker-on-centos-7/" target="_blank" rel="noopener">Docker</a></li><li><a href="https://linuxize.com/post/how-to-install-and-use-docker-compose-on-centos-7/" target="_blank" rel="noopener">Docker Compose</a></li></ul><h1 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h1><ul><li><h5 id="环境配置树"><a href="#环境配置树" class="headerlink" title="环境配置树"></a>环境配置树</h5><p><img src="https://img-blog.csdnimg.cn/20200115145707395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oyODEyNjMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-docker-compose-yml配置容器"><a href="#1-docker-compose-yml配置容器" class="headerlink" title="1. docker-compose.yml配置容器"></a>1. docker-compose.yml配置容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  db-master:</span><br><span class="line">    image: mysql:5.7.28</span><br><span class="line">    container_name: mysql-master1</span><br><span class="line">    command: --default-authentication-plugin&#x3D;mysql_native_password</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      # root用户密码</span><br><span class="line">      MYSQL_ROOT_PASSWORD: tiger</span><br><span class="line">      TZ: Asia&#x2F;Shanghai</span><br><span class="line">    # 设置容器hostname，使从机可通过hostname连接主机而不必使用ip</span><br><span class="line">    hostname: mysql-master1</span><br><span class="line">    ports:</span><br><span class="line">      - 3306:3306</span><br><span class="line">    volumes:</span><br><span class="line">    # 当前目录下的mysql&#x2F;master&#x2F;*挂载(共享)到容器中的对应目录&#x2F;文件</span><br><span class="line">      - .&#x2F;mysql&#x2F;master&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">      - .&#x2F;mysql&#x2F;master&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql</span><br><span class="line">      - .&#x2F;mysql&#x2F;master&#x2F;conf:&#x2F;etc&#x2F;mysql</span><br><span class="line">      # mysql容器初始化执行的指令文件，用于创建同步用户</span><br><span class="line">      - .&#x2F;mysql&#x2F;master&#x2F;init.sql:&#x2F;docker-entrypoint-initdb.d&#x2F;init.sql</span><br><span class="line">  db-slave:</span><br><span class="line">    image: mysql:5.7.28</span><br><span class="line">    container_name: mysql-master1-slave1</span><br><span class="line">    command: --default-authentication-plugin&#x3D;mysql_native_password</span><br><span class="line">    restart: always</span><br><span class="line">    hostname: mysql-master1-slave1</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: tiger</span><br><span class="line">      TZ: Asia&#x2F;Shanghai</span><br><span class="line">    ports:</span><br><span class="line">      - 3307:3306</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;mysql&#x2F;slave&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">      - .&#x2F;mysql&#x2F;slave&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql</span><br><span class="line">      - .&#x2F;mysql&#x2F;slave&#x2F;conf:&#x2F;etc&#x2F;mysql</span><br></pre></td></tr></table></figure><h3 id="2-master文件配置"><a href="#2-master文件配置" class="headerlink" title="2. master文件配置"></a>2. master文件配置</h3></li><li><p>./mysql/master/conf/my.cnf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 局域网唯一</span><br><span class="line">server_id&#x3D;1</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db&#x3D;master</span><br><span class="line">## 开启二进制日志功能</span><br><span class="line">log-bin&#x3D;master1-bin</span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size&#x3D;1M</span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format&#x3D;mixed</span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><br><span class="line">expire_logs_days&#x3D;7</span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors&#x3D;1062</span><br></pre></td></tr></table></figure></li><li><p>./mysql/master/conf/init.sql(创建从机同步用户)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#39;slave&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure><h3 id="3-slave文件配置"><a href="#3-slave文件配置" class="headerlink" title="3. slave文件配置"></a>3. slave文件配置</h3></li><li><p>./slave/conf/my.cnf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 局域网唯一</span><br><span class="line">server_id&#x3D;2</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db&#x3D;mysql</span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span><br><span class="line">log-bin&#x3D;master1-slave1-bin</span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size&#x3D;1M</span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format&#x3D;mixed</span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><br><span class="line">expire_logs_days&#x3D;7</span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors&#x3D;1062</span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log&#x3D;mall-mysql-relay-bin</span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates&#x3D;1</span><br><span class="line">## slave设置为只读（具有super权限的用户除外）</span><br><span class="line">read_only&#x3D;1</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-容器运行并进行同步配置测试"><a href="#4-容器运行并进行同步配置测试" class="headerlink" title="4. 容器运行并进行同步配置测试"></a>4. 容器运行并进行同步配置测试</h3><ul><li>启动容器：进入docker-compose.yml所在文件夹执行<code>docker-compose up -d</code><br><img src="https://img-blog.csdnimg.cn/20200115151151377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oyODEyNjMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><ul><li>查看master容器mysql binary log文件(File)与位置(Position)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql-master1 &#x2F;bin&#x2F;bash</span><br><span class="line">mysql -uroot -ptiger</span><br><span class="line">show master status;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20200115151628451.png" alt="在这里插入图片描述"></li><li>slave容器mysql master连接配置并进行同步<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql-master1-slave1 &#x2F;bin&#x2F;bash</span><br><span class="line">mysql -uroot -ptiger</span><br><span class="line"># master_host可设为ip或容器hostname，使用用户为slave连接主机并通过log同步</span><br><span class="line">change master to master_host&#x3D;&#39;mysql-master1&#39;, master_user&#x3D;&#39;slave&#39;, master_password&#x3D;&#39;123456&#39;, master_port&#x3D;3306, master_log_file&#x3D;&#39;master1-bin.000005&#39;, master_log_pos&#x3D;154, master_connect_retry&#x3D;30;</span><br><span class="line"># 开启同步</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>查看同步信息<code>show slave status \G</code>：<br><img src="https://img-blog.csdnimg.cn/20200115152651396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oyODEyNjMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当从机的IO线程Slave_IO_RUNNING(负责获取主机SQL日志,YES时即为成功连接到主机)与SQL线程Slave_SQL_Running(负责执行同步的语句)显示都为YES时，则主从同步搭建成功。</li></ul></li><li>校验<ul><li>在master上创建数据库后到slave上查看是否有master上创建的数据库</li><li>在master上创建数据表后到slave上查看是否有master上创建的数据表</li><li>在master上插入数据后到slave上查看是否有master上插入的数据</li></ul></li></ul><h1 id="奇难杂症"><a href="#奇难杂症" class="headerlink" title="奇难杂症"></a>奇难杂症</h1><ul><li><strong>IO连接一直为Connecting</strong>，建议检查<code>change master</code>的host、端口号、log_pos等是否配置错误，或将host改为ip而非hostname，重新执行<code>change master</code>前需执行<code>stop slave;</code>指令停止IO线程。</li><li>Slave_IO_Runnin为YES，Slave_SQL_Running为NO<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stop slave;                                                      </span><br><span class="line">SET GLOBAL SQL_SLAVE_SKIP_COUNTER&#x3D;1;     </span><br><span class="line">start slave;                                                      </span><br><span class="line">show slave status\G</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-binlog主从同步简介&quot;&gt;&lt;a href=&quot;#MySQL-binlog主从同步简介&quot; class=&quot;headerlink&quot; title=&quot;MySQL binlog主从同步简介&quot;&gt;&lt;/a&gt;MySQL binlog主从同步简介&lt;/h1&gt;&lt;p&gt;传统的MyS
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://wilson-he.gitee.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://wilson-he.gitee.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>实战：RocketMQ削峰，这一篇就够了</title>
    <link href="https://wilson-he.gitee.io/rocketmq/clap-peak/"/>
    <id>https://wilson-he.gitee.io/rocketmq/clap-peak/</id>
    <published>2020-04-24T01:18:53.804Z</published>
    <updated>2020-04-24T01:18:53.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MQ的主要特点为<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>，该文章主要记录与分享个人在实际项目中的RocketMQ<strong>削峰</strong>用法，用于减少数据库压力的业务场景，其中RocketMQ的核心组件概念如下：</p><ul><li>Producer：生产发送消息</li><li>Broker：存储Producer发送过来的消息</li><li>Consumer：从Broker拉取消息并进行消费</li><li>NameServer：为Producer或Consumer路由到Broker<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzIzLzE3MWE2NGJmNDJhYzdlYTk?x-oss-process=image/format,png" alt="Model.png"></li></ul><p>其中消费流程有以下几点是必须注意的：</p><ul><li>RocketMQ的Consumer获取消息是通过向Broker发送拉取请求获取的，而不是由Broker发送Consumer接收的方式。</li><li>Consumer每次拉取消息时消息都会被均匀分发到消息队列再进行传输，所以RocketMQ中的很多参数都是针对队列而不是Topic的(这个是重点，顺便吐槽下源码的文档讲的真不清晰，很多都需要自己试错，但Dashboard做得很好)，其中每个Broker消息队列(ConsumeQueue)的数量都可以通过RocketMQ DashBoard实时更改调整。</li></ul><h1 id="rocketmq-spring-boot-starter-用法简介"><a href="#rocketmq-spring-boot-starter-用法简介" class="headerlink" title="rocketmq-spring-boot-starter 用法简介"></a><a href="https://github.com/apache/rocketmq-spring" target="_blank" rel="noopener">rocketmq-spring-boot-starter</a> 用法简介</h1><p>当开发中需要快速集成RocketMQ时可以考虑使用 <a href="https://github.com/apache/rocketmq-spring" target="_blank" rel="noopener">rocketmq-spring-boot-starter</a> 搭建RocketMQ的集成环境，但该框架并不完全具备RocketMQ所有的配置简化，如需批量消费消息便需要自定义一个DefaultMQPushConsumer bean去消费了。<br>个人在开发中常用的<code>rocketmq-spring-boot-starter</code>相关类：</p><ul><li><code>RocketMQListener</code>接口：消费者都需实现该接口的消费方法<code>onMessage(msg)</code>。</li><li><code>RocketMQPushConsumerLifecycleListener</code>接口：当<code>@RocketMQMessageListener</code>中的配置不足以满足我们的需求时，可以实现该接口直接更改消费者类<code>DefaultMQPushConsumer</code>配置</li><li><code>@RocketMQMessageListener</code>：被该注解标注并实现了接口<code>RocketMQListener</code>的bean为一个消费者并监听指定topic队列中的消息，该注解中包含消费者的一些常用配置(大部分按默认即可)，一般只需更改consumerGroup(消费组)与topic。<code>RocketMQMessageListener</code>中的属性配置是可以使用Placeholder(占位符)从配置文件或配置中心获取的，如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzIzLzE3MWE2NGJmNDI3MDBkZmE?x-oss-process=image/format,png" alt="RocketMQMessageListener.png"></li></ul><h1 id="业务案例"><a href="#业务案例" class="headerlink" title="业务案例"></a>业务案例</h1><p>有一个点赞业务，不限制用户的点赞数只需进行记录(产品需求，开发提议无效)，当每个用户都进行x连击享受数量猛增的快感时如果数据库都需要进行x个点赞数据的插入，数据库毫无疑问会塞死导致崩溃。于是想到可以尝试下MQ削峰，比如每秒来了5000消息但数据库只能承受2000，那我消费时每次只拉取消费1600就好了，剩下的放在Broker堆积慢慢消费就好。由于之前的消息中心也在用RocketMQ，于是确认使用RocketMQ来进行削峰。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzIzLzE3MWE2NGJmNDMzN2Q1NWU?x-oss-process=image/format,png" alt="praise-clap-peak.png"></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><blockquote><p>文章例子环境：1NameServer + 2Broker + 1Consumer</p></blockquote><h3 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="application-yml配置"><a href="#application-yml配置" class="headerlink" title="application.yml配置"></a>application.yml配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rocketmq:</span><br><span class="line">  name-server: 127.0.0.1:9876</span><br><span class="line">  producer:</span><br><span class="line">    group: praise-group</span><br><span class="line">server:</span><br><span class="line">  port: 10000</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    username: root</span><br><span class="line">    password: tiger</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;wilson</span><br><span class="line">swagger:</span><br><span class="line">  docket:</span><br><span class="line">    base-package: io.rocket.consumer.controller</span><br></pre></td></tr></table></figure><h2 id="点赞接口"><a href="#点赞接口" class="headerlink" title="点赞接口"></a>点赞接口</h2><p><strong>PraiseRecord(点赞记录):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class PraiseRecord implements Serializable &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private Long uid;</span><br><span class="line">    private Long liveId;</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MessageController(简单的测试接口):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;message&quot;)</span><br><span class="line">public class MessageController &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;praise&quot;)</span><br><span class="line">    public ServerResponse praise(@RequestBody PraiseRecordVO vo) &#123;</span><br><span class="line">        rocketMQTemplate.sendOneWay(RocketConstant.Topic.PRAISE_TOPIC, MessageBuilder.withPayload(vo).build());</span><br><span class="line">        return ServerResponse.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于用户可以连续点赞，所以考虑可以在点赞消息的处理上宽松一点(容许消息丢失)以追求更高的性能，因此选择使用<code>sendOneyWay()</code>进行消息发送。</p><blockquote><p>RocketMQ的消息发送方式主要含syncSend()同步发送、asyncSend()异步发送、sendOneWay()三种方式，sendOneWay()也是异步发送，区别在于不需等待Broker返回确认，所以可能会存在信息丢失的状况，但吞吐量更高，具体需根据业务情况选用。性能：sendOneWay &gt; asyncSend &gt; syncSend<br>RocketMQTemplate的send()方法默认是同步(syncSend)的,更多可看源码实现。</p></blockquote><h2 id="PraiseListener：点赞消息消费者"><a href="#PraiseListener：点赞消息消费者" class="headerlink" title="PraiseListener：点赞消息消费者"></a>PraiseListener：点赞消息消费者</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@RocketMQMessageListener(topic &#x3D; RocketConstant.Topic.PRAISE_TOPIC, consumerGroup &#x3D; RocketConstant.ConsumerGroup.PRAISE_CONSUMER)</span><br><span class="line">@Slf4j</span><br><span class="line">public class PraiseListener implements RocketMQListener&lt;PraiseRecordVO&gt;, RocketMQPushConsumerLifecycleListener &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PraiseRecordService praiseRecordService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(PraiseRecordVO vo) &#123;</span><br><span class="line">        praiseRecordService.insert(vo.copyProperties(PraiseRecord::new));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void prepareStart(DefaultMQPushConsumer consumer) &#123;</span><br><span class="line">        &#x2F;&#x2F; 每次拉取的间隔，单位为毫秒</span><br><span class="line">        consumer.setPullInterval(2000);</span><br><span class="line">        &#x2F;&#x2F; 设置每次从队列中拉取的消息数为16</span><br><span class="line">        consumer.setPullBatchSize(16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单次pull消息的最大数目受broker存储的<code>MessageStoreConfig.maxTransferCountOnMessageInMemory</code>(默认为32)值限制，即若想要消费者从队列拉取的消息数大于32有效(pullBatchSize&gt;32)则需更改Broker的启动参数<code>maxTransferCountOnMessageInMemory</code>值。在MQ削峰的配置参数里，以下几个<code>DefaultMQPushConsumer</code>的参数是需要注意一下的：</p><ul><li>pullInterval：每次从Broker拉取消息的间隔，单位为毫秒</li><li>pullBatchSize：每次从Broker队列拉取到的消息数，该参数很容易让人误解，一开始我以为是每次拉取的消息总数，但测试过几次后确认了实质上是从每个队列的拉取数(源码上的注释文档真的很差，跟没有一样)，即Consume每次拉取的消息总数如下：<br><code>EachPullTotal=所有Broker上的写队列数和(writeQueueNums=readQueueNums) * pullBatchSize</code></li><li>consumeMessageBatchMaxSize：每次消费(即将多条消息合并为List消费)的最大消息数目，默认值为1，<a href="https://github.com/apache/rocketmq-spring" target="_blank" rel="noopener">rocketmq-spring-boot-starter</a> 目前不支持批量消费(2.1.0版本)</li></ul><p>在消费者开始消息消费时会先从各队列中拉取一条消息进行消费，消费成功后再以每次pullBatchSize的数目进行拉取。</p><p>PraiseListener中设置了每次拉取的间隔为2s，每次从队列拉取的消息数为16，在搭建了2master broker且broker上writeQueueNums=readQueueNums=4的环境下每次拉取的消息理论数值为16 * 2 * 4 = 128，在第一次从各队列拉取1条消息(即共8条)后消费成功后会每次就会拉取最多128条消息进行消费，想验证下的可以把onMessage()的insert()改为log.info(“1”)然后统计单位秒内打印的日志数是否为128。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzIzLzE3MWE2NGJmNDM4ZTc4MzE?x-oss-process=image/format,png" alt="praise-topic.png"></p><p>根据以上配置单Conumer情况下每2s理论消费为128，即每2秒数据库新增的点赞数据大概为128条左右，有20%偏差都在个人可接受范围内，然后对点赞接口进行简单压测1s 2000请求校验MQ效果，根据消费配置理论上需要16次拉取即需32s才能消费完，压测后查看数据库校验效果：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzIzLzE3MWE2NGJmNDQxYzBhY2Y?x-oss-process=image/format,png" alt="praise-jmeter.png"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzIzLzE3MWE2NGJmNDQzYWY5YmQ?x-oss-process=image/format,png" alt="praise-jmeter-db.png"><br>由上图可以看出除第一次2s和最后一次2s外数据库每2s的插入数据数和一般都在128附近波动，也用了34s(因第一次拉取数较少所以比理论多花费一次拉取)消费的偏差大小可能会受每次拉取数pullBatchSize、Broker上的消息队列数、网络波动等情况影响，但需要的目的已经达到了，我只想把单位时间内过多的数据库操作交给MQ做分隔成多个单位时间内的小批量操作，消息过多就堆积，当请求峰值过了后直到MQ堆积的消息消费完前数据库的插入数依旧会与峰值期的插入数相差不大，达到了MQ削峰填谷的效果。</p><h3 id="上线了但消费效率预估失误如何动态更改消费效率-？"><a href="#上线了但消费效率预估失误如何动态更改消费效率-？" class="headerlink" title="上线了但消费效率预估失误如何动态更改消费效率 ？"></a>上线了但消费效率预估失误如何动态更改消费效率 ？</h3><p>当把拉取数pullBatchSize设置Broker的默认最大传输值32了，线上又不想重启Broker更改maxTransferCountOnMessageInMemory参数，如有2个Broker且queue都为4，那么拉取消费效率才为32 * 2 * 4 = 256，如果想要动态调整，可以从Broker数或Broker队列数下手，可以将Broker的writeQueueNums、readQueueNums增大，如都改为8，那么效率就成了32 * 2 * 8 = 512。需要注意的是更改完queues后必须去Dashboard的Topic下的CONSUMER MANAGER查看新增的队列上是否都有Consumer成功注册上去了，因为遇到了在测试与生产上使用rocketmq-spring-boot-starter @RocketMQListener标注消费者不会自动注册到新队列上的情况，但没排除是不是RocketMQ版本的原因(个人本地的版本比环境上的高了一个小版本0.0.1，本地没出现没消费者注册到新队列上的问题)，而是使用了自定义DefaultMQPushConsumer bean(原生的方式都是没有问题的)的备用方案。当再启动新的消费者应用时CONSUMER MANAGER(下图)中就会出现 新Consumer数 * 各Broker队列数和的队列行。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzIzLzE3MWE2NGJmYjFhOTk1OTY?x-oss-process=image/format,png" alt="praise-topic-consumer.png"></p><h3 id="如何使用RocketMQ批量消费-？"><a href="#如何使用RocketMQ批量消费-？" class="headerlink" title="如何使用RocketMQ批量消费 ？"></a>如何使用RocketMQ批量消费 ？</h3><p>虽然点赞业务使用MQ单条插入后TPS已经达到当前业务指标要求了，但考虑到如果后续要求在不添加机器数的情况下增加TPS，且数据量还没到分库分表的程度，个人就打算从批量消费下手，由一次插入一条点赞记录改为一次性插入多条(insertBatch)。当然能满足现有需求能不做肯定不做的，过度优化过分碍事，但想多点方案不会坏事。rocketmq-spring-boot-starter并没有提供批量消费的功能，所以要批量消费消息需要自定义<code>DefaultMQPushConsumer</code>并配置其<code>consumeMessageBatchMaxSize</code>属性。<code>consumeMessageBatchMaxSize</code>属性默认值为1，即每次只消费一条消息，需要注意的是该属性也会受<code>pullBatchSize</code>影响，如果<code>consumeMessageBatchMaxSize</code>为32但<code>pullBatchSize</code>只为12，那么每次批量消费的最大消息数也就只有12。<br>如下为个人测试批量消费Consumer的测试bean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DefaultMQPushConsumer userMQPushConsumer() throws MQClientException &#123;</span><br><span class="line">    DefaultMQPushConsumer consumer &#x3D; new DefaultMQPushConsumer(RocketConstant.ConsumerGroup.SPRING_BOOT_USER_CONSUMER);</span><br><span class="line">    consumer.setNamesrvAddr(nameServer);</span><br><span class="line">    consumer.subscribe(RocketConstant.Topic.SPRING_BOOT_USER_TOPIC, &quot;*&quot;);</span><br><span class="line">    &#x2F;&#x2F; 设置每次消息拉取的时间间隔，单位毫秒</span><br><span class="line">    consumer.setPullInterval(1000);</span><br><span class="line">    &#x2F;&#x2F; 设置每个队列每次拉取的最大消息数</span><br><span class="line">    consumer.setPullBatchSize(24);</span><br><span class="line">    &#x2F;&#x2F; 设置消费者单次批量消费的消息数目上限</span><br><span class="line">    consumer.setConsumeMessageBatchMaxSize(12);</span><br><span class="line">    consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context)</span><br><span class="line">            -&gt; &#123;</span><br><span class="line">        List&lt;UserInfo&gt; userInfos &#x3D; new ArrayList&lt;&gt;(msgs.size());</span><br><span class="line">        Map&lt;Integer, Integer&gt; queueMsgMap &#x3D; new HashMap&lt;&gt;(8);</span><br><span class="line">        msgs.forEach(msg -&gt; &#123;</span><br><span class="line">            userInfos.add(JSONObject.parseObject(msg.getBody(), UserInfo.class));</span><br><span class="line">            queueMsgMap.compute(msg.getQueueId(), (key, val) -&gt; val &#x3D;&#x3D; null ? 1 : ++val);</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(&quot;userInfo size: &#123;&#125;, content: &#123;&#125;&quot;, userInfos.size(), userInfos);</span><br><span class="line">        &#x2F;*</span><br><span class="line">          处理批量消息，如批量插入：userInfoMapper.insertBatch(userInfos);</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.start();</span><br><span class="line">    return consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果默认配置情况下log打印出的userInfo size恒为1，但由于设置了<code>consumeMessageBatchMaxSize</code>与<code>pullBatchSize</code>，且<code>pullBatchSize</code>较小，所以每次消费的消息数最大值为12，如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzIzLzE3MWE2NGJmYjI4MTdhMGY?x-oss-process=image/format,png" alt="consume-batch.png"></p><h1 id="附本文相关信息"><a href="#附本文相关信息" class="headerlink" title="附本文相关信息"></a>附本文相关信息</h1><ul><li>确保mqnamesrv与mqbroker已启动成功，如该文章环境的启动：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mqnamesrv -n 127.0.0.1:9876</span><br><span class="line">mqbroker -c E:\RocketMQ\rocketmq-all-4.5.2-bin-release\bin\2m-noslave\broker-a.properties</span><br><span class="line">mqbroker -c E:\RocketMQ\rocketmq-all-4.5.2-bin-release\bin\2m-noslave\broker-b.properties</span><br></pre></td></tr></table></figure></li><li>RocketMQ DashBoard启动流程可参考<a href="https://github.com/apache/rocketmq-externals/tree/master/rocketmq-console" target="_blank" rel="noopener">官方github文档</a>或到<a href="https://download.csdn.net/download/z28126308/12355342" target="_blank" rel="noopener">我的资源</a>里下载jar包运行</li><li><a href="https://github.com/Wilson-He/spring-boot-series/tree/master/spring-rocketmq" target="_blank" rel="noopener">源码地址</a>，2m-noslave目录是该文章中例子中的2master broker配置与启动脚本，spring-boot-consumer-peak目录为包含该文章相关代码的实际例子</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MQ的主要特点为&lt;strong&gt;解耦&lt;/strong&gt;、&lt;strong&gt;异步&lt;/strong&gt;、&lt;strong&gt;削峰&lt;/strong&gt;，该文
      
    
    </summary>
    
    
      <category term="RocketMQ" scheme="https://wilson-he.gitee.io/categories/RocketMQ/"/>
    
    
      <category term="RocketMQ" scheme="https://wilson-he.gitee.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>聊聊MQ与如何基于Spring Boot RocketMQ搭建一个消息中心</title>
    <link href="https://wilson-he.gitee.io/rocketmq/message-center/"/>
    <id>https://wilson-he.gitee.io/rocketmq/message-center/</id>
    <published>2020-04-23T09:24:31.768Z</published>
    <updated>2020-04-23T09:24:31.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>在引入一项技术之前，首先必须清楚的是该技术可以为项目解决什么问题。个人在了解消息队列(Message Queue)之前，以为消息队列主是用于发送短信、邮件等消息发送(异步解耦)，但深入理解才发现自己的理解错了，MQ的作用不止体现在一些用户接收到的具体消息里，还可用于其它应用的数据发送、通用的业务处理等。<br>消息队列从字面上意思解读就是将消息存放到队列里，根据队列FIFO(先入先出)的特性进行消息消费。在实际开发中，是一种跨进程的通信机制，用于应用间的消息传递。 </p><h2 id="在引入MQ之前，需要了解的优缺点与应用场景"><a href="#在引入MQ之前，需要了解的优缺点与应用场景" class="headerlink" title="在引入MQ之前，需要了解的优缺点与应用场景"></a>在引入MQ之前，需要了解的优缺点与应用场景</h2><hr><p>MQ的主要优点为<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>，以下举一个简单的场景来反应这几个特性。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9rbm93bGVkZ2UtcGljdHVyZXMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL1JvY2tldE1RL01RJUU4JUFFJUEyJUU1JThEJTk1JUU0JUI4JTlBJUU1JThBJUExJUU2JUExJTg4JUU0JUJFJThCLnBuZw?x-oss-process=image/format,png" alt="MQ%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1%E6%A1%88%E4%BE%8B.png"></p><p>在微服务项目中，一般会根据核心业务进行系统的垂直拆分再进行单独部署。在上图中，各系统在下单业务里主要负责的内容如下：</p><ul><li>订单系统：创建订单，将下单消息(如订单id、用户数据)发送到MQ</li><li>MQ：限制每秒的订单请求处理数(如每秒接收2000个请求但数据库只能处理1000个则只处理1000个，处理不过来的先在消息队列里堆积)</li><li>物流系统：创建订单物流信息</li><li>积分系统：用户购物积分信息更新</li></ul><p>想象下以上场景没有MQ的的存在时创建订单流程中存在的问题：</p><ul><li>订单系统创建完订单信息后要去调用物流系统、积分系统上的业务接口，系统严重的<strong>耦合</strong>在一起(解耦)</li><li>订单系统若非通过线程去调用其它系统的接口，还需同步等待返回浪费不少时间(异步，避免创建线程调用的麻烦)</li><li>用户高峰期请求过多数据库处理不过来进而导致应用崩溃(削峰)</li></ul><p>任何事物都有两面性，虽然MQ可以给系统解决不少问题，但也会引入一些问题，如：</p><ul><li>系统复杂度提高，需要考虑消息重复消费、消息丢失等问题</li><li>数据一致性问题，如上例中的物流或库存系统写库出现异常如何回滚补偿</li></ul><p>了解了MQ的一些特性后，再讨论下几个适合使用MQ的场景：</p><ul><li>上游系统不关心下游的执行结果(如用户注册成功后用户系统通过MQ向用户发送邮件，但发送成不成功用户系统根本不在意)</li><li>依赖于数据的定时任务(如下单后24小时内不支付则取消订单，申请退款72小时内商家不处理则自动退款)</li></ul><h2 id="引入MQ后的一些问题解决思路"><a href="#引入MQ后的一些问题解决思路" class="headerlink" title="引入MQ后的一些问题解决思路"></a>引入MQ后的一些问题解决思路</h2><hr><ul><li><h3 id="消息重复消费-保证消息的幂等性"><a href="#消息重复消费-保证消息的幂等性" class="headerlink" title="消息重复消费(保证消息的幂等性)"></a>消息重复消费(保证消息的幂等性)</h3><blockquote><p>幂等性：对于同一操作的请求无论请求多少次结果都是一致的，在MQ中的具体体现为同一条消息无论发送都少次都会被消费一次。</p></blockquote><p>  由于网络抖动(延迟)的原因消息重复发送的问题是不可避免的，如果在消费端消费时没有做好消息的幂等性保证就有可能出现重复消费，导致同一条消息被多次消费、写库多次的情况。比较常见的做法是为消息添加一个唯一标识(ID)，在消费时根据ID查询数据库是否存在该消息记录，如果不存在再插入消息，存在则不进行插入消费。当生成与消费时间间隔不长时，可使用Redis提高消息幂等性的效率，如：</p><ol><li><p>消费者消费前根据ID去查询redis是否存在该消息</p></li><li><p>不存在该消息则消费并写入redis，存在该消息则不消费返回</p><p>关于消息ID：</p></li><li><p>RocketMQ的每条消息都会配有全局唯一的ID</p></li><li><p>如果消息中间件不会生成ID，可考虑一些ID服务(如雪花算法)生成全局唯一ID</p></li><li><p>建议ID不与实际业务关联</p></li></ol></li></ul><p>如目前个人工作中负责的消息中心应用是基于MongoDB+RocketMQ的技术架构，MongoDB负责存储各个应用发送过来的消息(主要为Sms、Email等)，每次消费前通过RocketMQ的Message ID查询Mongo保证消息幂等性避免重复消费，消费成功后更新DB中的消息状态。</p><ul><li><h3 id="消息丢失-消息的可靠性"><a href="#消息丢失-消息的可靠性" class="headerlink" title="消息丢失(消息的可靠性)"></a>消息丢失(消息的可靠性)</h3>  MQ各组件的消息丢失含义都有所不同，导致与解决方案也不一定相同，以kafka、rocket的消息传递模型(Producer-&gt;Broker-&gt;Consumer)为例：<ul><li>Producer：消息未持久化到Broker中，或消费者未能成功消费到消息。Kafka可通过更改ack配置解决，rocketMQ中会返回消息发送状态码。</li><li>Broker：消息成功传到到我这里了，可我因为某些原因(不同的MQ可能因机制问题有不同原因)弄丢了，如果是硬件原因(如宕机、磁盘损坏)建议你copy(集群部署)几个我</li><li>Consumer：我拿到了消息，但消费失败了或中途挂掉了没告诉Broker。可通过各MQ中间件的ACK机制解决。</li></ul></li></ul><h2 id="基于RocketMQ的简单例子技术框架与业务模型"><a href="#基于RocketMQ的简单例子技术框架与业务模型" class="headerlink" title="基于RocketMQ的简单例子技术框架与业务模型"></a>基于RocketMQ的简单例子技术框架与业务模型</h2><hr><p>以下便以一个基于MongoDB+RocketMQ+Eureka+Spring Cloud Config的技术框架并结合使用MQ中的问题搭建一个简单的消息中心项目案例，其中各组件在项目中的主要作用如下：</p><ul><li>Spring Cloud Config：消息配置(如topic、ConsumerGroup、ProducerGroup)中心。</li><li>Eureka：应用服务注册中心，负责项目中各服务的发现与提供调用。</li><li>MongoDB：由于消息的事务关系不强且Mongodb格式文档自由(json存储，随意增删字段)，所以使用Mongodb存储各个应用发送过来的消息(主要为Sms、Email等)，每次消费前通过RocketMQ的Message ID查询Mongo保证消息幂等性避免重复消费，消费成功后保存消息。</li><li>RocketMQ：消息接收、存储、发送。</li></ul><p>下图为该项目的应用关系模型：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9rbm93bGVkZ2UtcGljdHVyZXMub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL1JvY2tldE1RL01RJUU2JUI2JTg4JUU2JTgxJUFGJUU1JUJBJTk0JUU3JTk0JUE4JUU2JUExJTg4JUU0JUJFJThCLnBuZw?x-oss-process=image/format,png" alt="MQ%E6%B6%88%E6%81%AF%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B.png"></p><p>消息中心应用：统一通用消息的业务处理应用，如短信发送、邮件发送、员工服务号推送等消息的处理<br>问卷应用：负责员工调查问卷的分发，在该例子中只是一个简单的消息发送测试应用<br>common：存放各应用通用类，如短信消息类(SmsMessage)、消息常量类<br>config-server-properties：配置中心的配置存放目录<br>由于该项目主要用于演示一些MQ的功能与使用中的问题解决方式，所以编码部分比较简单。</p><h2 id="应用例子编码"><a href="#应用例子编码" class="headerlink" title="应用例子编码"></a>应用例子编码</h2><ul><li><h3 id="通用模块编码-common"><a href="#通用模块编码-common" class="headerlink" title="通用模块编码(common)"></a>通用模块编码(common)</h3><p>通用模块主要存放各应用通用类(如实体、常量、配置、功能等)。<br>  <strong>MessageConstant：维护消息常量</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageConstant &#123;</span><br><span class="line"></span><br><span class="line">    interface System &#123;</span><br><span class="line">        String QUESTION &#x3D; &quot;QUESTION&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Topic &#123;</span><br><span class="line">        String SMS_TOPIC &#x3D; &quot;rocketmq.topic.sms&quot;;</span><br><span class="line">        String SMS_TOPIC_TEMPLATE &#x3D; &quot;$&#123;rocketmq.topic.sms&#125;&quot;;</span><br><span class="line">        String MAIL_TOPIC &#x3D; &quot;rocketmq.topic.mail&quot;;</span><br><span class="line">        String MAIL_TOPIC_TEMPLATE &#x3D; &quot;$&#123;rocketmq.topic.mail&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Producer &#123;</span><br><span class="line">        String SMS_GROUP_TEMPLATE &#x3D; &quot;$&#123;rocketmq.producer.group.sms&#125;&quot;;</span><br><span class="line">        String MAIL_GROUP_TEMPLATE &#x3D; &quot;$&#123;rocketmq.producer.group.mail&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Consumer &#123;</span><br><span class="line">        String SMS_GROUP_TEMPLATE &#x3D; &quot;$&#123;rocketmq.consumer.group.sms&#125;&quot;;</span><br><span class="line">        String MAIL_GROUP_TEMPLATE &#x3D; &quot;$&#123;rocketmq.consumer.group.mail&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>BaseMessage：基础消息类，所用的通用消息都需继承此类方便统一信息的管理</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Accessors(chain &#x3D; true)</span><br><span class="line">public abstract class BaseMessage implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 消息源系统:&#123;@link io.wilson.common.message.constant.MessageConstant.System&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String system;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>SmsMessage：通用短信消息类，短信内容数据载体</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@EqualsAndHashCode(callSuper &#x3D; true)</span><br><span class="line">@Data</span><br><span class="line">@Accessors(chain &#x3D; true)</span><br><span class="line">@ToString(callSuper &#x3D; true)</span><br><span class="line">public class SmsMessage extends BaseMessage &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 短信创建用户</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String createUserId;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 接收短信用户</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String toUserId;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 手机号码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String mobile;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 短信内容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="消息中心应用-message-center"><a href="#消息中心应用-message-center" class="headerlink" title="消息中心应用(message-center)"></a>消息中心应用(message-center)</h3><p>  消息中心在进行编码之前，需确认消息中心该如何进行消息的处理。该项目所处的业务环境是各应用可能都需要发送一些短信消息、邮件、服务号消息等，相同消息的业务处理是一致的，所以消息中心对消息接收消费的主要流程如下：</p><ul><li>保证消息幂等性(查询数据库使用已有消息记录避免重复消费)</li><li>消息业务处理</li><li>消息日志入库</li></ul><p>在该项目中，不同的消息类型存储在不同的Mongodb collection(同Mysql table概念)，但共用一个消息日志类MessageLog：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Accessors(chain &#x3D; true)</span><br><span class="line">public class MessageLog implements Serializable &#123;</span><br><span class="line">    private String msgId;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送方系统名称 &#123;@link io.wilson.common.message.constant.MessageConstant&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String system;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 消息对象json字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String msgContent;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 业务执行结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Boolean success;</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 初始化消息记录</span><br><span class="line">     *</span><br><span class="line">     * @param message       消息</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;T extends BaseMessage&gt; MessageLog convertFromMessage(T message) &#123;</span><br><span class="line">        LocalDateTime now &#x3D; LocalDateTime.now();</span><br><span class="line">        return new MessageLog()</span><br><span class="line">                .setSystem(message.getSystem())</span><br><span class="line">                .setSuccess(false)</span><br><span class="line">                .setCreateTime(now)</span><br><span class="line">                .setUpdateTime(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在该消费流程设计与开发编码过程中个人考虑的核心点如下：</p><ol><li>如果使用普通消息类(如SmsMessage)作为db存储的映射对象，会导致消息类掺杂不必要的属性(如createTime、updateTime、success)，且作为一个通用的消息数据载体，普通消息类更适于作为一个VO而非DO使用，所以消息的处理结果、消息的创建更新时间这些作为原消息上的附加内容，更适合放到其它数据库映射对象中维护，所以定义了MessageLog作为消息记录的实体类</li><li>既然是作为各应用都可使用的通用消息所以肯定都会有一定数据量，虽然映射实体都一样，但存放到不同的collection可以提高操作的便捷性和获得更好的性能，系统编码可以更好地根据系统进行消息筛选</li><li>在消息消费流程中，保证消息幂等性和消息日志入库这两步只有数据库名是不同的，所以可定义一个父Listener进行消息监听消费的方法抽象，不同消息的业务处理交给不同的消息Service，同一类消息的消费可能会再细分调用不同的消息业务方法消费(如发送单条短信、批量发送短信)，所以可以对各service抽象出一个consume()方法根据参数调用具体的service业务方法进行消息消费</li></ol><ul><li><h4 id="消息中心类图与消费流程图"><a href="#消息中心类图与消费流程图" class="headerlink" title="消息中心类图与消费流程图"></a>消息中心类图与消费流程图</h4><p>为了更好地展示消息中心中类之间的关系，描绘以下类图：<br> <img src="https://img-blog.csdnimg.cn/20200309131427286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oyODEyNjMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">      </p><p>当一条短信消息发送到消息中心时，其消费流程如下图：<br><img src="https://img-blog.csdnimg.cn/20200309131600757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oyODEyNjMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><h4 id="消息业务处理编码"><a href="#消息业务处理编码" class="headerlink" title="消息业务处理编码"></a>消息业务处理编码</h4><p>  <strong>BaseMessageService：消息业务消费抽象接口，抽象每个消费者(Listener)调用的业务消费方法</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface BaseMessageService&lt;T extends BaseMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 消费消息</span><br><span class="line">     *</span><br><span class="line">     * @param message         消息</span><br><span class="line">     * @param consumeFunction 消费方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    default boolean consume(T message, Function&lt;T, Boolean&gt; consumeFunction) &#123;</span><br><span class="line">        return consumeFunction.apply(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>BaseMessageService：短信消息业务抽象接口</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public interface SmsMessageService extends BaseMessageService&lt;SmsMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送单条短信消息</span><br><span class="line">     *</span><br><span class="line">     * @param smsMessage</span><br><span class="line">     * @return 业务处理结果</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean sendSingle(SmsMessage smsMessage);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>SmsMessageServiceImpl：短信消息业务实现类</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class SmsMessageServiceImpl implements SmsMessageService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean sendSingle(SmsMessage smsMessage) &#123;</span><br><span class="line">        &#x2F;&#x2F; 短信业务操作结果</span><br><span class="line">        boolean isSuccess &#x3D; true;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 短信业务操作并把操作结果设到isSuccess中</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (Objects.equals(smsMessage.getToUserId(), &quot;Wilson&quot;)) &#123;</span><br><span class="line">            isSuccess &#x3D; false;</span><br><span class="line">            log.info(&quot;短信发送失败,消息内容:&#123;&#125;&quot;, smsMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        return isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="消息业务处理编码-1"><a href="#消息业务处理编码-1" class="headerlink" title="消息业务处理编码"></a>消息业务处理编码</h4><p>  <strong>MessageLogConstant：维护MessageLog的相关常量(如不同消息的collection名)</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageLogConstant &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 各消息日志Mongo集合名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    interface CollectionName &#123;</span><br><span class="line">        String SMS &#x3D; &quot;sms_message_log&quot;;</span><br><span class="line">        String MAIL &#x3D; &quot;mail_message_log&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>AbstractMQStoreListener：保证消息幂等性、消息日志入库操作的抽象Listener类方法中</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public abstract class AbstractMQStoreListener &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    protected MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断消息是否已被消费</span><br><span class="line">     *</span><br><span class="line">     * @param msgId</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean isConsumed(String msgId) &#123;</span><br><span class="line">        long count &#x3D; mongoTemplate.count(new Query(Criteria.where(&quot;msg_id&quot;).is(msgId)), collection());</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            log.info(&quot;消息&#123;&#125;已成功消费过，请勿重复投递!&quot;, msgId);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前消息的mongo collection名:&#123;@link io.wilson.message.domain.constant.MessageLogConstant.CollectionName&#125;</span><br><span class="line">     *</span><br><span class="line">     * @return 当前消息存储的collection名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected abstract String collection();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 保存消息消费记录</span><br><span class="line">     *</span><br><span class="line">     * @param success 业务执行结果</span><br><span class="line">     * @param msgId   消息id</span><br><span class="line">     * @param message</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void store(boolean success, String msgId, BaseMessage message) &#123;</span><br><span class="line">        MessageLog messageLog &#x3D; MessageLog.convertFromMessage(message)</span><br><span class="line">                .setMsgId(msgId)</span><br><span class="line">                .setMsgContent(JSONObject.toJSONString(message))</span><br><span class="line">                .setSuccess(success);</span><br><span class="line">        mongoTemplate.insert(messageLog, collection());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>SmsMessageListener:短信消息监听器(消费者)，如在消费过程中抛出异常，RocketMQ会以一定的时间间隔进行重新投递消费</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">@ConditionalOnProperty(MessageConstant.Topic.SMS_TOPIC)</span><br><span class="line">@RocketMQMessageListener(topic &#x3D; MessageConstant.Topic.SMS_TOPIC_TEMPLATE, consumerGroup &#x3D; MessageConstant.Consumer.SMS_GROUP_TEMPLATE)</span><br><span class="line">public class SmsMessageListener extends AbstractMQStoreListener implements RocketMQListener&lt;MessageExt&gt; &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private SmsMessageService smsMessageService;</span><br><span class="line">    private static final String EXCEPTION_FORMAT &#x3D; &quot;短信消息消费失败，消息内容：%s&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(MessageExt message) &#123;</span><br><span class="line">        String msgId &#x3D; message.getMsgId();</span><br><span class="line">        if (isConsumed(msgId)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        SmsMessage smsMessage &#x3D; JSONObject.parseObject(message.getBody(), SmsMessage.class);</span><br><span class="line">        log.info(&quot;接收到短信消息&#123;&#125;：&#123;&#125;&quot;, msgId, smsMessage);</span><br><span class="line">        &#x2F;*if (Objects.equals(smsMessage.getToUserId(), &quot;2020&quot;)) &#123;</span><br><span class="line">            log.error(&quot;消息&#123;&#125;消费失败&quot;, message.getMsgId());</span><br><span class="line">            &#x2F;&#x2F; 抛出异常让RocketMQ重新投递消息重新消费</span><br><span class="line">            throw new MQConsumeException(String.format(EXCEPTION_FORMAT, smsMessage));</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line">        boolean isSuccess &#x3D; smsMessageService.consume(smsMessage, smsMessageService::sendSingle);</span><br><span class="line">        if (!isSuccess) &#123;</span><br><span class="line">            log.info(&quot;短信消息业务操作失败,消息id: &#123;&#125;&quot;, msgId);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 保存消息消费记录</span><br><span class="line">        store(isSuccess, msgId, smsMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String collection() &#123;</span><br><span class="line">        return MessageLogConstant.CollectionName.SMS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>MessageCenterApplication:主程序</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class MessageCenterApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MessageCenterApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>Spring Cloud配置文件bootstrap.yml</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8000&#x2F;eureka</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: config-center</span><br><span class="line">      #     资源文件名</span><br><span class="line">      profile: dev</span><br><span class="line">      name: rocketmq</span><br></pre></td></tr></table></figure><p>  <strong>SmsSendTest：单元测试类</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(classes &#x3D; MessageCenterApplication.class)</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">public class SmsSendTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line">    @Value(MessageConstant.Topic.SMS_TOPIC_TEMPLATE)</span><br><span class="line">    private String smsTopic;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void sendSms() &#123;</span><br><span class="line">        SmsMessage smsMessage &#x3D; new SmsMessage();</span><br><span class="line">        smsMessage.setToUserId(&quot;13211&quot;)</span><br><span class="line">                .setMobile(&quot;173333222&quot;)</span><br><span class="line">                .setContent(&quot;测试短信消息&quot;)</span><br><span class="line">                .setSystem(MessageConstant.System.QUESTION);</span><br><span class="line">        rocketMQTemplate.send(smsTopic, MessageBuilder.withPayload(smsMessage).build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h3 id="配置中心-config-server"><a href="#配置中心-config-server" class="headerlink" title="配置中心(config-server)"></a>配置中心(config-server)</h3><p>主程序ConfigServerApplication</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableConfigServer</span><br><span class="line">public class ConfigServerApplication &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Cloud配置文件bootstrap.yml:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:&#x2F;&#x2F;gitee.com&#x2F;Wilson-He&#x2F;rocketmq-message-center-demo.git</span><br><span class="line">          username: Wilson-He</span><br><span class="line">          force-pull: true</span><br><span class="line">          password:</span><br><span class="line">          # 配置文件在uri下的目录</span><br><span class="line">          search-paths: &#x2F;config-server-properties</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8000&#x2F;eureka</span><br></pre></td></tr></table></figure><p>配置文件configs-server-properties/rocketmq-dev.properties:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.name-server&#x3D;127.0.0.1:9876</span><br><span class="line">rocketmq.topic.sms&#x3D;sms-topic</span><br><span class="line">rocketmq.producer.group.sms&#x3D;sms-group</span><br><span class="line">rocketmq.consumer.group.sms&#x3D;sms-group</span><br><span class="line">rocketmq.topic.mail&#x3D;mail-topic</span><br><span class="line">rocketmq.producer.group.mail&#x3D;mail-group</span><br><span class="line">rocketmq.consumer.group.mail&#x3D;mail-group</span><br></pre></td></tr></table></figure></li></ul><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><ol><li>运行RocketMQ name-server与broker,如<code>mqnamesrv -n 127.0.0.1:9876</code>,<code>mqbroker -n 127.0.0.1:9876</code></li><li>运行eureka应用</li><li>运行配置中心config-server</li><li>运行消息中心message-center</li><li>运行message-center单元测试类(SmsSendTest)或运行question-app访问<code>localhost:8080/question/toUser?userId=xxx</code>进行消费测试，消息中心控制台打印出日志信息与Mongo sms_message_log成功新增了数据即项目搭建完成<br><img src="https://img-blog.csdnimg.cn/20200309131857721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oyODEyNjMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200309131930100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oyODEyNjMwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><p><strong>(待)扩展点：</strong></p><ol><li>RocketMQ的发送者应用可在配置文件中设置rocketmq.producer.retry-times-when-send-failed/retry-times-when-send-async-failed属性配置rocketmq同步/异步发送消息失败后的重试次数，不设置则默认都为2</li><li>当业务执行操作结果失败时仍然入库的原因是有时业务执行过程中可能会包含调用第三方的操作，当第三方报错时会导致业务操作结果失败，而第三方的操作是不可控的，所以先把报错结果保存便于追溯，且有业务需要时也可通过定时任务查库重新执行业务</li><li>该例子中只用了一个消息配置文件，实际开发中消息配置需根据项目所需配置到对应的项目配置文件，如question-app的消息配置(如topc、producerGroup)应在其项目中的配置文件(如application.yml、apollo的namespace)中配置</li><li>该项目中的NameServer、Broker并没有集群部署，Broker集群部署后配置同步双写避免主机写入后尚未同步到从机就宕机导致消息丢失的情况(有意向的自行百度：RocketMQ 同步双写)</li></ol><h2 id="末"><a href="#末" class="headerlink" title="末"></a>末</h2><p>该文章通过一个简单的项目例子演示了使用Spring Boot RocketMQ处理MQ常见问题的一些方式：</p><ul><li>消息重复消费问题可通过数据库存储来保证幂等性</li><li>若消息消费业务操作失败时可通过Listener抛出异常让RocketMQ重新投递消息进行消费</li></ul><p><a href="https://github.com/Wilson-He/rocketmq-message-center-demo" target="_blank" rel="noopener">项目源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在引入一项技术之前，首先必须清楚的是该技术可以为项目解决什么问题。个人在了解消息队列(Message Queue)之前，以为消息队
      
    
    </summary>
    
    
      <category term="RocketMQ" scheme="https://wilson-he.gitee.io/categories/RocketMQ/"/>
    
      <category term="Spring Boot" scheme="https://wilson-he.gitee.io/categories/RocketMQ/Spring-Boot/"/>
    
    
      <category term="RocketMQ" scheme="https://wilson-he.gitee.io/tags/RocketMQ/"/>
    
      <category term="Spring Boot" scheme="https://wilson-he.gitee.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ概念模型</title>
    <link href="https://wilson-he.gitee.io/RocketMQ-Model/"/>
    <id>https://wilson-he.gitee.io/RocketMQ-Model/</id>
    <published>2020-04-22T02:07:46.953Z</published>
    <updated>2020-04-22T02:07:46.954Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h5 id="RocketMQ主要由-Producer、Broker、Consumer、NameServer四部分组成"><a href="#RocketMQ主要由-Producer、Broker、Consumer、NameServer四部分组成" class="headerlink" title="RocketMQ主要由 Producer、Broker、Consumer、NameServer四部分组成"></a>RocketMQ主要由 Producer、Broker、Consumer、NameServer四部分组成</h5><ul><li>Producer 生产消息</li><li>Consumer 从Broker读取消费消息</li><li>Broker 存储Producer发送过来的消息</li><li>NameServer 为Producer或Consumer路由消息到Broker<br>Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。RocketMQ启动顺序为先NameServer，再Broker。</li></ul></blockquote><p><img src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/RocketMQ/Model.png" alt="Model.png"></p><ul><li><h3 id="Topic与Queue"><a href="#Topic与Queue" class="headerlink" title="Topic与Queue"></a>Topic与Queue</h3><p>Topic是一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。<br>在RocketMQ中Queue是组成Topic的更小单元，集群消费模式下一个消费者只消费该Topic中部分Queue中的消息，当一个消费者开启广播模式时则会消费该Topic下所有Queue中的消息。</p></li><li><h3 id="Broker-Server-代理服务器"><a href="#Broker-Server-代理服务器" class="headerlink" title="Broker Server(代理服务器)"></a>Broker Server(代理服务器)</h3><p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移(offset)和主题(Topic)和队列消息等。</p></li><li><h3 id="Name-Server-名字服务"><a href="#Name-Server-名字服务" class="headerlink" title="Name Server(名字服务)"></a>Name Server(名字服务)</h3><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p></li><li><h3 id="Producer-Group-生产者组"><a href="#Producer-Group-生产者组" class="headerlink" title="Producer Group(生产者组)"></a>Producer Group(生产者组)</h3><p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事物消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p></li><li><h3 id="Consumer-Group-消费者组"><a href="#Consumer-Group-消费者组" class="headerlink" title="Consumer Group(消费者组)"></a>Consumer Group(消费者组)</h3><p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：<em>集群消费（Clustering）</em> 和<em>广播消费（Broadcasting）</em>。</p></li><li><h3 id="Offset-Message-Queue下的offset"><a href="#Offset-Message-Queue下的offset" class="headerlink" title="Offset(Message Queue下的offset)"></a>Offset(Message Queue下的offset)</h3><ul><li>max offset<br>MessageQueue中的max offset在源码中表示指消息的最大offset+1，即下条消息入队的位置。</li><li>min offset<br>标识当前队列的最小offset。由于消息存储一段时间后，消费了的消息会从从磁盘物理删除，message queue的min offset也就对应增长，即比minOffset小的消息不存在broker上了。</li><li>consumer offset<br>Consumer Group在MessageQueue上的消息消费进度，其实际值为队列中消费了的消息数+1，即表示下次拉取消息的位置。<br>DefaultMQPushConsumer.setConsumeFromWhere(ConsumerFromWhere)可设置从哪开始消费消息，但该设置的优先级在offset store后，当从offset store中读取不到offset的时候，ConsumerFromWhere的设置才生效。大部分该设置在ConsumerGroup初次启动时才有效(启动会一般会存储offset)，即使Consumer正常运行时重启，依旧会接着上次的offset(从offset store中获取)开始消费，ConsumeFromWhere的设置无效。</li></ul></li><li><h3 id="Clustering-集群消费"><a href="#Clustering-集群消费" class="headerlink" title="Clustering(集群消费)"></a>Clustering(集群消费)</h3><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p></li><li><h3 id="广播消费-Broadcasting"><a href="#广播消费-Broadcasting" class="headerlink" title="广播消费(Broadcasting)"></a>广播消费(Broadcasting)</h3><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p></li><li><h3 id="Normal-Ordered-Message-普通顺序消息"><a href="#Normal-Ordered-Message-普通顺序消息" class="headerlink" title="Normal Ordered Message(普通顺序消息)"></a>Normal Ordered Message(普通顺序消息)</h3><p>普通顺序消费模式下，消费者通过同一个消费队列收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。<br>如Broker Server将消息Msg_A、Msg_B、Msg_C按顺序发送到Topic_A主题上的队列Q_A、Q_B、Q_A，Consumer_A从订阅的Topic_A拉去消息的顺序可能为下：</p><ul><li>Msg_A-&gt;Msg_B-&gt;Msg_C</li><li>Msg_B-&gt;Msg_A-&gt;Msg_C</li><li>Msg_A-&gt;Msg_C-&gt;Msg_B<br>Msg_B进入队列Q_A在Msg_A之后，所以Msg_B必然在接收到Msg_A后才被发送</li></ul></li><li><h3 id="Strictly-Ordered-Message-严格顺序消息"><a href="#Strictly-Ordered-Message-严格顺序消息" class="headerlink" title="Strictly Ordered Message(严格顺序消息)"></a>Strictly Ordered Message(严格顺序消息)</h3><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。如上例中Consumer_A收到的顺序只会是Msg_A-&gt;Msg_B-&gt;Msg_C</p></li><li><h3 id="Message-消息"><a href="#Message-消息" class="headerlink" title="Message(消息)"></a>Message(消息)</h3><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。常用属性：</p><ul><li>topic: 所属topic</li><li>tags: 消息标签，用来做服务端消息过滤。一个topic下可以有很多tags，一般都通过topic+tags来消费自己想要的结果。</li><li>keys: 消息关键词，查询消息使用</li><li>body: 消息内容</li></ul></li><li><h3 id="Tag-标签"><a href="#Tag-标签" class="headerlink" title="Tag(标签)"></a>Tag(标签)</h3><p>可理解为二级Topic，用于同一Topic下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一Topic下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子Topic的不同消费逻辑，实现更好的扩展性。</p></li><li><h2 id="各MQ产品对比（译自RocketMQ官方对比）"><a href="#各MQ产品对比（译自RocketMQ官方对比）" class="headerlink" title="各MQ产品对比（译自RocketMQ官方对比）"></a>各MQ产品对比（译自RocketMQ官方对比）</h2></li></ul><table><thead><tr><th></th><th>RocketMQ</th><th>Kafka</th><th>ActiveMQ</th></tr></thead><tbody><tr><td>客户端SDK</td><td>Java，C ++，Go</td><td>Java，Scala等</td><td>Java，.NET，C ++等</td></tr><tr><td>协议规范</td><td>拉模型，支持TCP，JMS，OpenMessaging</td><td>拉模型，支持TCP</td><td>推送模型，支持OpenWire，STOMP，AMQP，MQTT，JMS</td></tr><tr><td>消息排序</td><td>确保对消息进行严格排序，并可以正常扩展</td><td>确保分区内消息的顺序</td><td>排他消费者或排他队列可确保顺序</td></tr><tr><td>定时消息</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td>批量消息</td><td>支持，具有同步模式，可避免消息丢失</td><td>支持，带异步Producer</td><td>不支持</td></tr><tr><td>广播消息</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td>消息过滤器</td><td>支持，基于SQL92的属性过滤器表达式过滤</td><td>支持，使用kafka stream过滤</td><td>支持</td></tr><tr><td>服务器触发重新交付</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>消息存储</td><td>高性能和低延迟文件存储</td><td>高性能文件存储</td><td>使用JDBC和高性能日志（例如levelDB，kahaDB）存储支持非常快速持久性</td></tr><tr><td>消息追溯</td><td>支持时间戳和偏移量追溯</td><td>支持的偏移量追溯</td><td>支持</td></tr><tr><td>消息优先级</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>高可用与故障切换</td><td>支持主从模式</td><td>支持，需额外配置ZooKeeper服务器</td><td>支持，取决于存储，如果使用kahadb，则需要ZooKeeper服务器</td></tr><tr><td>消息追踪</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>配置特点</td><td>开箱即用，用户只需要注意一些配置</td><td>使用键值对格式进行配置，这些值可以从文件或以编程方式提供</td><td>默认配置为低级别，用户需要优化配置参数</td></tr><tr><td>操作管理工具</td><td>支持，Web控制台和终端命令都可操作管理</td><td>支持，使用终端命令管理</td><td>支持</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h5 id=&quot;RocketMQ主要由-Producer、Broker、Consumer、NameServer四部分组成&quot;&gt;&lt;a href=&quot;#RocketMQ主要由-Producer、Broker、Consumer、NameServer四部分组成&quot; c
      
    
    </summary>
    
    
      <category term="RocketMQ" scheme="https://wilson-he.gitee.io/categories/RocketMQ/"/>
    
    
      <category term="RocketMQ" scheme="https://wilson-he.gitee.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法大全</title>
    <link href="https://wilson-he.gitee.io/Markdown/"/>
    <id>https://wilson-he.gitee.io/Markdown/</id>
    <published>2020-04-20T07:27:02.254Z</published>
    <updated>2020-04-20T07:27:02.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h1><p>#标识1-6级标题  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>换行：段落末尾添加两个或以上空格<br><em>字体样式</em>：</p><ul><li>斜体：<code>_斜体_</code>或<code>*斜体*</code></li><li>粗体：<code>__加粗__</code>或<code>**加粗**</code></li><li>斜体加粗：<code>***斜体加粗***</code>或<code>___斜体加粗___</code>  </li><li>删除线： <code>~~删除线~~</code></li><li>下划线： <code>&lt;u&gt;下划线&lt;/u&gt;</code></li><li>脚注：  <code>文本[^脚注名]</code><br>列表(3种语法)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* 元素1</span><br><span class="line">* 元素2</span><br><span class="line"> </span><br><span class="line">- 元素1</span><br><span class="line">- 元素2</span><br><span class="line"> </span><br><span class="line">+ 元素1</span><br><span class="line">+ 元素2</span><br><span class="line"></span><br><span class="line">多级列表：</span><br><span class="line">- 一级列表1</span><br><span class="line">  - 二级列表1.1  </span><br><span class="line">    这里是二级列表  </span><br><span class="line">    - 三级列表1.1.1  </span><br><span class="line">    这里是三级列表</span><br><span class="line">  - 二级列表1.2</span><br></pre></td></tr></table></figure></li></ul><p>分割线：<code>---</code>、<code>- - -</code>、<code>&lt;hr&gt;</code>、<code>***</code>、<code>* * *</code><br>区块：<code>&gt; 文本内容</code>,区块可以有多级，根据 <code>&gt;</code> 个数确认级数，可以与列表语法互相嵌套，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">列表嵌套区块：</span><br><span class="line">- 元素1</span><br><span class="line">  &gt; 一级区块</span><br><span class="line">  &gt;&gt; 二级区块</span><br><span class="line">  - 元素1.1</span><br><span class="line">- 元素2</span><br><span class="line">  - 元素2.1</span><br><span class="line">  &gt; 一级区块</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">代码块(纯文本,&#96;&#96;&#96;后可选择语言,如java、javascript)： </span><br><span class="line">&lt;pre&gt;</span><br></pre></td></tr></table></figure><p>// code or text</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;pre&gt;</span><br><span class="line">或</span><br></pre></td></tr></table></figure><pre>code or text</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">超链接： &#96;[个人blog](http:&#x2F;&#x2F;wilson-he.gitee.io&#x2F;)&#96;  </span><br><span class="line">插入图片：&#96;![description](url)&#96;,也可使用img标签&#96;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;www.editplus.com&#x2F;ss&#x2F;editplus680x340.png&quot; width&#x3D;&quot;50%&quot; height&#x3D;&quot;30%&quot;&#x2F;&gt;&#96;  </span><br><span class="line">表格：</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td></td></tr><tr><td>单元格</td><td>单元格</td></tr><tr><td>```</td><td></td></tr><tr><td>`</td><td></td></tr><tr><td>内容缩略：</td><td></td></tr><tr><td><details></td><td></td></tr><tr><td><summary>概况</summary></td><td></td></tr><tr><td>详细内容</td><td></td></tr><tr><td></details></td><td></td></tr></tbody></table><table>    <caption>标题</caption>    <tr>        <td>1</td>        <td>2</td>    </tr>    <tr>        <td>11</td>        <td>22</td>    </tr>    <tr>        <td>111</td>    </tr></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown基础语法&quot;&gt;&lt;a href=&quot;#Markdown基础语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown基础语法&quot;&gt;&lt;/a&gt;Markdown基础语法&lt;/h1&gt;&lt;p&gt;#标识1-6级标题  &lt;/p&gt;
&lt;figure class=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring面试题集</title>
    <link href="https://wilson-he.gitee.io/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <id>https://wilson-he.gitee.io/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/</id>
    <published>2020-04-20T07:27:02.228Z</published>
    <updated>2020-04-20T07:27:02.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring的事务隔离级别"><a href="#Spring的事务隔离级别" class="headerlink" title="Spring的事务隔离级别"></a>Spring的事务隔离级别</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring的事务隔离级别&quot;&gt;&lt;a href=&quot;#Spring的事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;Spring的事务隔离级别&quot;&gt;&lt;/a&gt;Spring的事务隔离级别&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://wilson-he.gitee.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo+gitee/github搭建个人博客的流程</title>
    <link href="https://wilson-he.gitee.io/undefined/"/>
    <id>https://wilson-he.gitee.io/undefined/</id>
    <published>2020-04-20T07:27:02.160Z</published>
    <updated>2020-04-20T07:27:02.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择该方式搭建的理由和要做的准备"><a href="#选择该方式搭建的理由和要做的准备" class="headerlink" title="选择该方式搭建的理由和要做的准备"></a>选择该方式搭建的理由和要做的准备</h2><p>每个项目在开始之前，都需要先清楚项目的目的、主要的需求和核心点在哪。我在选择搭建的方式之前，根据个人状况确认了博客的搭建需要满足以下需求：</p><ol><li>无需自备服务器，静态网站也没关系</li><li>不错的分类归档</li><li>方便文章追溯</li><li>简洁的排版</li><li>不用了解或使用太多前端知识(排版是我的痛)</li></ol><p>根据自行百度了解，在github/gitee上搭建的Pages博客最起码是满足第1点要求的，选用哪种方式在github上搭建便打算先简单使用下搭建的技术了解后再做确认。下图为gitee支持搭建静态网站的技术：<br><img src="https://user-gold-cdn.xitu.io/2020/3/13/170d2c32245710c7?w=426&h=24&f=png&s=4150" alt="gitee-pages.png"><br>第一个选用的是hexo(庆幸不用选第二个了)，理由是文章多，有足够的参考，官方网站也提供中文文档。在开始之前需要做以下的准备：</p><ul><li>nodejs安装(百度官网下载安装即可)</li><li>github/gitee账号</li><li>git安装</li></ul><p>虽然gitee/github都可以部署，但还是要提下两者之间的细微区别：</p><ul><li>gitee是国内站点，网络稳定高速，github访问有时不稳定</li><li>站点项目更新部署到github/gitee后，github会自动重新部署更新，失败后还会给你发邮件，gitee则需要到respository里手动更新(除非你升级会员)<br><img src="https://user-gold-cdn.xitu.io/2020/3/13/170d2c322274bd8c?w=1096&h=492&f=jpeg&s=58000" alt="git-page-email.jpg"></li></ul><p>在部署到gitee/github之前可以先在本地调试样式添加文章，调好了后再部署到github上。</p><h2 id="搭建hexo本地环境"><a href="#搭建hexo本地环境" class="headerlink" title="搭建hexo本地环境"></a>搭建hexo本地环境</h2><ol><li>确认nodejs已安装：node -v</li><li>安装hexo:npm install -g hexo</li><li>环境初始化：hexo init 目录名(目录不存在则自动创建),出现Start blogging with Hexo!则完成</li><li>进入初始化的项目目录后运行：hexo server [-p 端口号],默认端口为4000,访问localhost:port出现下图则本地基础环境搭建完成<br><img src="https://user-gold-cdn.xitu.io/2020/3/13/170d2c322475969c?w=1176&h=596&f=png&s=237753" alt="theme-landscape.png"></li></ol><h2 id="个人了解到的hexo与next主题配置"><a href="#个人了解到的hexo与next主题配置" class="headerlink" title="个人了解到的hexo与next主题配置"></a>个人了解到的hexo与next主题配置</h2><p>项目目录下的核心目录/文件如下：</p><ul><li>scaffolds:模板、脚架目录</li><li>source：源文件夹(内容核心)，所有的文章和分类、标签等都是通过该文件夹下的内容进行发布的</li><li>source/_post：所有发布的文章都在该文件夹中</li><li>source/xxx：菜单xxx页面，如分类source/categories用于存放分类页，但分类页md文件是无需内容的，hexo会自动索引</li><li>themes：当前hexo项目的各类主题存放文件夹，把所需的主题目录添加到该文件夹中并更改项目_config.yml相应配置即可更换主题</li><li>themes/{themeName}/_config.yml：主题配置文件，主题的各种样式、配置都可在该文件中更改</li><li>_config.yml：项目配置文件，设置项目的通用配置(主题外的配置，如标题、分页、搜索、作者、发布地址等)<br>由于landscape的排版与样式不太符合自己的style，所以选择了next，足够简洁，一目了然(作为最多人选择的主题不是没有原因的)。使用next主题只需将该主题目录下载存放到项目的themes下并更改/_config.yml的theme配置值为相应主题名。<blockquote><p>下载next主题(如果慢的话可以同步到gitee再从gitee下载)：git clone <a href="https://github.com/theme-next/hexo-theme-next.git" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next.git</a></p></blockquote></li></ul><p>以next为例，hexo的页面都是通过_config.yml与/themes/next/_config.yml配置的，明显的配置如下图(c:为_config.yml中的配置,tc:themes/next/_config.yml中的配置)：<br><img src="https://user-gold-cdn.xitu.io/2020/3/13/170d2c3224b4225c?w=1341&h=787&f=png&s=85865" alt="next-homepage.png"></p><h3 id="菜单栏menu配置"><a href="#菜单栏menu配置" class="headerlink" title="菜单栏menu配置"></a>菜单栏menu配置</h3><p>hexo菜单栏可以在项目目录下通过<code>hexo new page {menuName}</code>指令创建，也可直接创建/source/{menuName}/index.md文件,并在themes\next_config.yml添加<code>menu:{menuName}</code>配置，如一个自定义菜单的局部配置(next/_config.yml)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  # || 后面是图标名，可在https:&#x2F;&#x2F;fontawesome.com&#x2F;icons中查询所需图片</span><br><span class="line">  home: &#x2F;index || home</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  temp: &#x2F;temp&#x2F; || calendar</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br></pre></td></tr></table></figure><p>文件与效果图：<br><img src="https://user-gold-cdn.xitu.io/2020/3/13/170d2c322c06e40e?w=1046&h=712&f=png&s=75456" alt="temp-menu.png"></p><p>需要注意的是在fontawesome中搜到的图标不一定都有，还需要根据图标名查询<code>themes/next/source/lib/font-awesome/css/font-awesome.css</code>下有没有该图标样式，如stack-overflow则在css文件下先搜索下有没有该样式，有的话才会显示fontawesome中对应的图标，没有的话会显示一个矩形。有些图标fontawesome有但css中没有的原因是版本不同，目前我在网上搜的最新fontawesome最新的css是4.7.0的，但fontawesome上的一些图标版本是新的版本才有(如blog)的，所以个人猜测是版本原因导致网站上搜到的一些图标不可用。仔细点观察其实可以发现css中的样式content是与fontawesome上的图标Unicode是一样的：<br><img src="https://user-gold-cdn.xitu.io/2020/3/13/170d2c322cd46ccf?w=1066&h=760&f=png&s=57984" alt="blog-icon.png"></p><h3 id="文章创建、添加标签、分类"><a href="#文章创建、添加标签、分类" class="headerlink" title="文章创建、添加标签、分类"></a>文章创建、添加标签、分类</h3><p>文章创建可通过在/source/_posts下创建”文章.md”文件就可，也可通过命令行<code>hexo new {article}</code>来创建。<br>hexo里的文章都可通过添加文章头进行文章归档，以下为一篇个人文章头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 聊聊MQ与如何基于Spring Boot RocketMQ搭建一个消息中心</span><br><span class="line">date: 2020-03-09 16:54:18</span><br><span class="line">tags: [RocketMQ, Spring Boot]</span><br><span class="line">categories: [RocketMQ, Spring Boot]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在文章头中添加了tags和categories后即可完成标签与分类，无需额外的操作，前提是source目录下已存在categories与tags。</p><h3 id="个人-config-yml主要更改的配置"><a href="#个人-config-yml主要更改的配置" class="headerlink" title="个人_config.yml主要更改的配置"></a>个人_config.yml主要更改的配置</h3><p>比较细的细节觉得前面都讲了，请容我偷下懒吧，以下为个人的配置文件主要更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Site 站点配置</span><br><span class="line">title: Wilson Blog</span><br><span class="line">subtitle: &#39;一名普通的搬砖工&#39;</span><br><span class="line">description: &#39;一名普通的搬砖工&#39;</span><br><span class="line">keywords:</span><br><span class="line">author: Wilson He</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line"></span><br><span class="line">index_generator:</span><br><span class="line">  path: &#39;&#39;</span><br><span class="line">  # 每页只显示一篇文章</span><br><span class="line">  per_page: 1</span><br><span class="line">  # 根据创建时间排序，如果文章有设置top值，则先按top由高到低排，目前个人是在索引文章上加了top值设为首页文章的</span><br><span class="line">  order_by: -date</span><br><span class="line">theme: next</span><br><span class="line"># 添加搜索功能，需先安装搜索插件：npm install hexo-generator-searchdb并将themes的_config.yml中local_search:enable设为true</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line"># 部署的项目地址，为私有仓库</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;Wilson-He&#x2F;wilson-he.github.io</span><br><span class="line">#  repo: https:&#x2F;&#x2F;gitee.com&#x2F;Wilson-He&#x2F;Wilson-He</span><br></pre></td></tr></table></figure><p>启用搜索服务需要安装搜索插件：<code>npm install hexo-generator-searchdb</code></p><h3 id="个人themes-next-config-yml主要更改的配置"><a href="#个人themes-next-config-yml主要更改的配置" class="headerlink" title="个人themes/next/_config.yml主要更改的配置"></a>个人themes/next/_config.yml主要更改的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;favicon-16x16-next.png</span><br><span class="line">  # 这里的&#x2F;images路径是themes&#x2F;next&#x2F;source下的images</span><br><span class="line">  medium: &#x2F;images&#x2F;piano-icon.png</span><br><span class="line">  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: &#x2F;images&#x2F;logo.svg</span><br><span class="line">footer:</span><br><span class="line">  # 不显示next原有的powered和version footer</span><br><span class="line">  powered:</span><br><span class="line">    enable: false</span><br><span class="line">    version: false</span><br><span class="line"># 首页信息与菜单显示样式，Pisces为网站信息显示在左侧，Mist在顶部，更多的自行尝试</span><br><span class="line">scheme: Pisces</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F;index || home</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  temp: &#x2F;temp&#x2F; || calendar</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">sidebar:</span><br><span class="line">  # 边栏位置设置</span><br><span class="line">  position: left</span><br><span class="line"># 头像设置</span><br><span class="line">avatar:</span><br><span class="line">  url: https:&#x2F;&#x2F;xxx.aliyuncs.com&#x2F;atavar&#x2F;xxx.jpg</span><br><span class="line"># 头像下显示的社交图标与链接，||后为fontawesome上的图标名</span><br><span class="line">social:</span><br><span class="line">  gitee: https:&#x2F;&#x2F;gitee.com&#x2F;Wilson-He || gg</span><br><span class="line">  github: https:&#x2F;&#x2F;github.com&#x2F;Wilson-He || github</span><br><span class="line">  csdn: https:&#x2F;&#x2F;blog.csdn.net&#x2F;z28126308 || creative-commons</span><br><span class="line">  Email: mailto:845023508@qq.com || envelope</span><br><span class="line"># 奖赏设置，true则每篇文章末尾会新增捐赠按钮，点击会显示收款图片(如果是直接显示我肯定会直接enable false的[doge])</span><br><span class="line">reward_settings:</span><br><span class="line">  # If true, reward will be displayed in every article by default.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  #comment: Donate comment here.</span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.jpg</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.jpg</span><br><span class="line">&#x2F;&#x2F; 头部显示github banner</span><br><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https:&#x2F;&#x2F;github.com&#x2F;Wilson-He</span><br><span class="line">&#x2F;&#x2F; 启用本地搜索</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>配置完后去看下文章，这阅读体验已经比预想的好很多。<br><img src="https://user-gold-cdn.xitu.io/2020/3/13/170d2c326af3c3ea?w=1073&h=597&f=png&s=77364" alt="article-demo.png"><br>将目标文章置顶需安装插件:<code>npm install hexo-generator-index-pin-top --save</code><br>然后在文章添加<code>top: true</code>即可。</p><h2 id="部署到github-gitee"><a href="#部署到github-gitee" class="headerlink" title="部署到github/gitee"></a>部署到github/gitee</h2><p>部署流程十分简单，安装hexo git插件后在github/gitee建立仓库，再在项目目录命令行部署即可。</p><p>安装hexo git插件：<code>npm install hexo-deployer-git --save</code><br>github:</p><ol><li>创建命名为username.github.io的页面仓库(小知识：个人开源的项目命名规则都是io.github.projectName，这里纯粹是顺序调转了)</li><li>在项目目录命令行执行<code>hexo deploy</code> deploy指令即可部署到页面仓库(如果没配置好git则需要输入github账号密码)<br>每次有部署时github都会为我们重新部署运行静态博客，失败会发送邮件，这一点很方便。博客页面仓库配置成功时查看仓库Settings下的Github Pages会显示以下图片内容，访问该地址即可显示你的博客页面(没事不用来闲逛，目前没啥内容可给大家看)：<img src="https://user-gold-cdn.xitu.io/2020/3/13/170d2c32757dd24a?w=700&h=543&f=png&s=38014" alt="github-success.png"></li></ol><p>gitee:</p><ol><li>创建博客发布仓库(命名无要求)</li><li>执行<code>hexo deploy</code></li><li>点击仓库“服务”-&gt;”Gitee Pages”，配置成功后会显示网站地址，<br>非会员版gitee部署后要重新更新，有时还会有样式显示问题，唯一的优点就是比github快</li></ol><h2 id="搭建过程使用到的文档"><a href="#搭建过程使用到的文档" class="headerlink" title="搭建过程使用到的文档"></a>搭建过程使用到的文档</h2><ol><li>hexo官方文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li><li>next主题官方文档(很详细)：<a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">https://theme-next.org/docs/getting-started/</a> ，next主题的所有设置、第三方服务(评论、搜索、统计等)、插件都有详细的文档</li><li>fontawesome图标网站：<a href="https://fontawesome.com/?from=io" target="_blank" rel="noopener">https://fontawesome.com/?from=io</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择该方式搭建的理由和要做的准备&quot;&gt;&lt;a href=&quot;#选择该方式搭建的理由和要做的准备&quot; class=&quot;headerlink&quot; title=&quot;选择该方式搭建的理由和要做的准备&quot;&gt;&lt;/a&gt;选择该方式搭建的理由和要做的准备&lt;/h2&gt;&lt;p&gt;每个项目在开始之前，都需要先
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
