<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/piano-icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wilson-he.gitee.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言该文章主要介绍JDK中各种常见的函数式接口，并会附上一些个人对函数式编程的一些扩展思考与实际用法。 常见的函数式接口介绍jdk1.8的函数式接口都在rt.jar中java.util.function包下，以下以jdk集合类与个人常用的接口进行介绍：  Function&lt;T,R&gt;：传入类型为T的对象并执行含返回值(返回值为R-return类型)的指定方法，方法可临时实现。常见于类Op">
<meta property="og:type" content="article">
<meta property="og:title" content="谈谈个人对JDK函数式编程的认知与使用">
<meta property="og:url" content="https://wilson-he.gitee.io/undefined/index.html">
<meta property="og:site_name" content="Wilson Blog">
<meta property="og:description" content="前言该文章主要介绍JDK中各种常见的函数式接口，并会附上一些个人对函数式编程的一些扩展思考与实际用法。 常见的函数式接口介绍jdk1.8的函数式接口都在rt.jar中java.util.function包下，以下以jdk集合类与个人常用的接口进行介绍：  Function&lt;T,R&gt;：传入类型为T的对象并执行含返回值(返回值为R-return类型)的指定方法，方法可临时实现。常见于类Op">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-04-20T07:02:26.665Z">
<meta property="article:modified_time" content="2020-04-20T07:02:26.665Z">
<meta property="article:author" content="Wilson He">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wilson-he.gitee.io/undefined/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>谈谈个人对JDK函数式编程的认知与使用 | Wilson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wilson Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wilson Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">一名普通的搬砖工</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/index/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Wilson-He" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-he.gitee.io/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/atavar/wingsOfPiano.jpg">
      <meta itemprop="name" content="Wilson He">
      <meta itemprop="description" content="一名普通的搬砖工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wilson Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          谈谈个人对JDK函数式编程的认知与使用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>该文章主要介绍JDK中各种常见的函数式接口，并会附上一些个人对函数式编程的一些扩展思考与实际用法。</p>
<h1 id="常见的函数式接口介绍"><a href="#常见的函数式接口介绍" class="headerlink" title="常见的函数式接口介绍"></a>常见的函数式接口介绍</h1><p>jdk1.8的函数式接口都在rt.jar中<code>java.util.function</code>包下，以下以jdk集合类与个人常用的接口进行介绍：</p>
<ul>
<li><p><code>Function&lt;T,R&gt;</code>：传入类型为T的对象并执行含返回值(返回值为R-return类型)的指定方法，方法可临时实现。常见于类Optional<code>{map();flatMap();}</code>、Stream<code>{map();flatMap();}</code>、Comparator<code>{thenComparing();}</code>等，MybatisPlus 3.0版本之后的<code>SFunction</code>接口与该接口作用相同，区别在于添加了序列化，使开发者可通过传入getter Function匹配对应字段而无需再写字段名进行匹配，免除字段名写错的问题。</p>
</li>
<li><p><code>BiFunction&lt;T,U,R&gt;</code>：传入类型为T、U类型(T、U可以相同)的两个对象并执行含返回值的指定方法，方法可临时实现。常见于类Stream<code>{reduce();}</code>、Map<code>{replaceAll();computeIfPresent();compute();merge();}</code>等。</p>
</li>
<li><p><code>Consumer&lt;T&gt;</code>：传入单个对象并执行对象中无返回值的指定方法，方法可临时实现。常见于类List<code>{foreach();}</code>、Stream<code>{foreach();}</code>、Optional<code>{ifPresent();}</code>等。</p>
</li>
<li><p><code>BiConsumer&lt;T, U&gt;</code>：传入两个对象并执行对象中无返回值的指定方法，方法可临时实现。常见于类Stream<code>{collect();}</code>、Map<code>{foreach();}</code>等。</p>
</li>
<li><p><code>Supplier&lt;T&gt;</code>：供应商接口，可理解为对象的无参构造函数代理接口，每次调用其get()方法都会产生一个新的对象。常见于类Stream<code>{generate();collect();}</code>Objects<code>{requireNonNull();}</code>、ThreadLocal<code>{withInitial();}</code></p>
</li>
<li><p><code>Predicate&lt;T&gt;</code>：传入一个对象返回其指定行为方法执行结果布尔值，方法可临时实现。常见于类Optional<code>{filter();}</code>、Stream<code>{filter();anyMatch();allMatch();noneMatch();}</code>、ArrayList<code>{removeIf();}</code>等</p>
</li>
<li><p><code>BiPredicate&lt;T, U&gt;</code>：可根据前面的Bi接口与<code>Predicate</code>推断，不再多作阐述</p>
</li>
</ul>
<h1 id="常见的函数式接口用法"><a href="#常见的函数式接口用法" class="headerlink" title="常见的函数式接口用法"></a>常见的函数式接口用法</h1><p><strong>Stream中的函数式编程</strong></p>
<p>以下先以一段代码简单的介绍jdk中的函数式用法：</p>
<pre><code>List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);
String result = list.stream()
                .filter(str -&gt; !StringUtils.equals(str, &quot;c&quot;))   // ① 参数为Predicate&lt;? super String&gt;,返回值为Stream&lt;String&gt;
                .map(str -&gt; str + &quot;,&quot;)   // ② 参数为Function&lt;? super String, ? extends String&gt;,返回值为Stream&lt;String&gt;
                .reduce((current, next) -&gt; current + next) // ③ 参数为BinaryOperator&lt;String&gt;,返回值为Optional&lt;String&gt;
                .orElse(&quot;&quot;);</code></pre><p>List转为Stream后Stream中的泛型都会对应为List元素的类型，以下为上面几个stream对象方法的简单讲解：<br>①：实现了一个<code>Predicate&lt;String&gt;</code>接口，并让Stream对象调用该接口的实现操作去过滤获取列表中元素值不为<code>&quot;c&quot;</code>的元素<br>②:  实现了一个<code>Function&lt;String,String&gt;</code>接口，在每个元素末尾添加字符串”,”，并返回添加后的结果<br>③： 实现了一个<code>BinaryOperator&lt;String&gt;</code>接口，将stream的当前元素与下一个元素进行拼接并返回拼接结果。<code>BinaryOperator&lt;T&gt;</code>是<code>BiFunction&lt;T,U,R&gt;</code>的子接口，在2个参数类型与返回类型都相同的情况下可使用BinaryOperator接口替代<code>BiFunction</code>接口，但两个接口实质上都需要实现apply()方法进行操作并返回结果，并无太大区别，可把<code>BinaryOperator</code>当<code>成BiFunction</code>的一个子集，其定义如下：</p>
<pre><code>@FunctionalInterface
public interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; {
    ......
}</code></pre><p>单看以上代码可能还无法体现出为什么叫函数式编程的原因，现在把以上代码还原为为函数实现显示样式：</p>
<pre><code>String result = list.stream()
        .filter(new Predicate&lt;String&gt;() {
            @Override
            public boolean test(String s) {
                return !StringUtils.equals(s, &quot;c&quot;);
            }
        })
        .map(new Function&lt;String, String&gt;() {
            @Override
            public String apply(String s) {
                return s + &quot;,&quot;;
            }
        })
        .reduce(new BinaryOperator&lt;String&gt;() {
            @Override
            public String apply(String current, String next) {
                return current + next;
            }
        })
        .orElse(&quot;&quot;);</code></pre><p>两段的执行代码都可编译执行，对比可知第一段代码只是对第二段代码的简化，第二段代码中详细的显示了对列表转stream后的操作实现了哪些接口与实现的函数操作，显得十分臃肿，而第一段代码只显示了实现的函数操作，故个人认为将重点放在函数实现操作便是函数式编程的核心。<br>相信各个读者都发现了所有函数式接口所需实现的函数都有且仅有一个，个人认为目的除了更优雅的显示以外，还可以让程序知道即使我传入的是一个函数式接口实现类，程序依然会清楚它还要再去执行该类型的指定函数。</p>
<p><strong>List中的函数式编程</strong><br>List中含函数式接口参数的方法主要为foreach(Consumer)，遍历元素时将元素作为参数传入Consumer执行，最简单的例子为<code>list.forEach(System.out::println);</code>，调用System.out对象的println方法打印遍历的当前元素。</p>
<p><strong>Map中的函数式编程</strong><br>Map中个人常用的含函数式接口参数的方法主要为<code>foreach(BiConsumer&lt;? super K, ? super V&gt;)</code>和<code>compute(K,
            BiFunction&lt;? super K, ? super V, ? extends V&gt;)</code>，其余的相信大家可以触类旁及。foreach为遍历当前map中的元素，前面介绍BiConsumer需要传入两个参数，而map.foreach()执行时每个key、value则作为参数传入到BiConsumer。虽然说需要传两个参数给BiConsumer，但不代表每个参数都必须用到，如下例中的BiConsumer只对每个val参数列表添加<code>“z”</code>字符串而没有用到key参数：</p>
<pre><code>Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();
map.put(&quot;0&quot;, Lists.newArrayList(&quot;&quot;));
map.put(&quot;1&quot;, Lists.newArrayList(&quot;a&quot;));
map.put(&quot;2&quot;, Lists.newArrayList(&quot;a&quot;, &quot;b&quot;));
map.put(&quot;3&quot;, Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
map.forEach((k,v) -&gt; v.add(&quot;z&quot;)); // ① 每个val列表末尾添加z字符串</code></pre><p>如果觉得有点难理解的可看以下函数还原代码：</p>
<pre><code>map.forEach(new BiConsumer&lt;String, List&lt;String&gt;&gt;() {
   @Override
    public void accept(String key, List&lt;String&gt; list) {
        list.add(&quot;z&quot;);
     }
});</code></pre><p>Map的compute()方法根据名称大家也可以估到该方法是进行某些计算后再去设计key的值，可用于Map中指定key的值计算，在实际开发中个人常用于该情况：map的val为列表，map需要为指定key的val添加元素，添加前需判断val列表是否为空，为空则初始化后再添加，不为空则直接添加。</p>
<pre><code>map.compute(&quot;4&quot;,(key, list) -&gt; list == null ? Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) : ListUtils.add(list,&quot;z&quot;));</code></pre><p>以上代码判断map中key为4的列表是否为空，若为空则将map中key为4的val设为元素为<code>&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;</code>的列表，不为空则在原val列表中添加字符串<code>&quot;z&quot;</code>。其中ListUtils为自定义工具类，其add方法返回参数列表，便于一行代码实现目的，实现如下：</p>
<pre><code>public static &lt;T&gt; List&lt;T&gt; add(List&lt;T&gt; list, T t) {
    list.add(t);
    return list;
}</code></pre><p>看了map.compute()的都知道该函数可以替代在操作map一些情况下的if判断，若把上面的<code>compute()</code>方法使用<code>if</code>执行，则将变成以下代码块：</p>
<pre><code>if(map.containsKey(&quot;4&quot;)){
    map.get(&quot;4&quot;).add(&quot;z&quot;);
}else {
    map.put(&quot;4&quot;,Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));
}</code></pre><p>可以看出适当的使用函数式编程可以为我们减少代码行。</p>
<p><strong>Optional简化if</strong><br>JDK1.8新增了Optional类使开发者可以减少if的语句块，类也含不少参数为函数式接口的方法，以下以一个简单的代码块进行介绍：</p>
<pre><code>Classify classify = new Classify();
Optional.ofNullable(classify)
        .map(Classify::getName)
        .orElse(&quot;null&quot;);</code></pre><p>上例中把classify对象交给Optional代理，如果classify对象为空或classify对象中的name属性为空则返回字符串“null”，其中map的参数为Function。</p>
<p>看到这相信大家都了解到JDK中的函数式方法都是异曲同工，区别只在于在实际使用时泛型对应的实际类型。</p>
<h1 id="个人扩展用法"><a href="#个人扩展用法" class="headerlink" title="个人扩展用法"></a>个人扩展用法</h1><p>前面基本都是谈个人对函数式的认知与JDK原生类函数式参数方法的用法，而此处开始，是时候展现真正的技术了[doge]。函数式接口运用得当可以省略不少，下文将以几个个人实际开发中思考或使用过的例子进行函数式使用的思维拓展。</p>
<p>分类例子实体Classify：</p>
<pre><code>@Data
@Accessors(chain = true)
public class Classify {
    private Long id;
    private String name;
    private Integer level;
    private Long parentId;
    private transient List&lt;Classify&gt; sonClassifies;
}</code></pre><ul>
<li><h2 id="自定义ListUtils替代Stream的简单操作"><a href="#自定义ListUtils替代Stream的简单操作" class="headerlink" title="自定义ListUtils替代Stream的简单操作"></a>自定义ListUtils替代Stream的简单操作</h2></li>
</ul>
<p>现有一个<code>List&lt;Classify&gt;</code>的列表对象，现在需要将列表中所有分类的名字重新提取为一个列表，了解Stream会这样写：</p>
<pre><code>List&lt;String&gt; names = list.stream()
        .map(Classify::getName)
        .collect(Collectors.toList());</code></pre><p>又有一个需求需要将列表元素转化成key为id，value为name的映射，这时会写成如下：</p>
<pre><code>Map&lt;Long,String&gt; idNameMap =   list.stream()
        .collect(Collectors.toMap(Classify::getId, Classify::getName));</code></pre><p>又又有一个需求需要将所有分类转换成key为parentId，value为子分类元素列表的映射，这时会写成如下：</p>
<pre><code>Map&lt;Long, List&lt;Classify&gt;&gt; parentSonsMap = list.stream()
        .collect(Collectors.groupingBy(Classify::getParentId));</code></pre><p>以上写法都是比较普通的写法，应该任何人都可以接受，但我想这么简单的操作可不可以一行解决呢？也有部分开发者认为把所有stream方法调用放到同一行就可以了，但对我而言这会影响代码的可读性(虽然影响可能不大)。在开发者以上List转换的状况虽然不多，但也不算少，为了可一行代码取代Stream的简单操作，个人撸了一个List工具类放到了自己的通用框架中，通过Function作为参数取代Stream的简单操作，完整如下：</p>
<pre><code>public class ListUtils {
    private ListUtils() {
    }

    public static &lt;T&gt; List&lt;T&gt; add(List&lt;T&gt; list, T t) {
        list.add(t);
        return list;
    }

    public static boolean isEmpty(Collection collection) {
        return collection == null || collection.isEmpty();
    }

    public static boolean isNotEmpty(Collection collection) {
        return !isEmpty(collection);
    }

    public static &lt;T&gt; ArrayList&lt;T&gt; newArrayList(T... elements) {
        ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(elements.length + elements.length &gt;&gt; 1 + 5);
        Collections.addAll(list, elements);
        return list;
    }

    /**
     * 条件为true时才添加元素
     *
     * @param condition  条件
     * @param collection 集合
     * @param val
     * @return 添加结果
     */
    public static &lt;T&gt; boolean addIf(boolean condition, Collection&lt;T&gt; collection, T val) {
        return condition &amp;&amp; collection.add(val);
    }

    /**
     * 从对象列表中提取对象属性
     *
     * @param list      对象列表
     * @param valGetter 对象属性get方法
     * @param &lt;T&gt;       对象
     * @param &lt;V&gt;       对象属性
     * @return 对象属性列表
     */
    public static &lt;T, V&gt; List&lt;V&gt; collectToList(Collection&lt;T&gt; list, Function&lt;T, V&gt; valGetter) {
        List&lt;V&gt; properties = new ArrayList&lt;&gt;(list.size());
        list.forEach(e -&gt; properties.add(valGetter.apply(e)));
        return properties;
    }

    /**
     * 从对象列表中提取指定属性为key,当前对象为value转为map
     *
     * @param list
     * @param keyGetter
     * @param &lt;T&gt;
     * @param &lt;K&gt;
     * @return
     */
    public static &lt;T, K&gt; Map&lt;K, T&gt; collectToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter) {
        Map&lt;K, T&gt; propertiesMap = new HashMap&lt;&gt;(list.size());
        list.forEach(e -&gt; propertiesMap.put(keyGetter.apply(e), e));
        return propertiesMap;
    }

    /**
     * 从对象列表中提取指定属性T为key,属性V为value转为map
     *
     * @param list      对象列表
     * @param keyGetter
     * @param valGetter
     * @param &lt;T&gt;
     * @param &lt;K&gt;
     * @param &lt;V&gt;
     * @return
     */
    public static &lt;T, K, V&gt; Map&lt;K, V&gt; collectToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter, Function&lt;T, V&gt; valGetter) {
        Map&lt;K, V&gt; propertiesMap = new HashMap&lt;&gt;(list.size());
        list.forEach(e -&gt; propertiesMap.put(keyGetter.apply(e), valGetter.apply(e)));
        return propertiesMap;
    }

    /**
     * 根据列表对象中的某属性值为key划分列表,value为key的属性值相同的对象列表,
     * 功能同stream().collect(Collectors.groupingBy())
     *
     * @param list
     * @param keyGetter
     * @param &lt;T&gt;
     * @param &lt;K&gt;
     * @return
     */
    public static &lt;T, K&gt; Map&lt;K, List&lt;T&gt;&gt; groupToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter) {
        Map&lt;K, List&lt;T&gt;&gt; propertiesMap = new HashMap&lt;&gt;(list.size());
        for (T each : list) {
            propertiesMap.compute(keyGetter.apply(each),
                    (key, valueList) -&gt; isEmpty(valueList) ? add(new ArrayList&lt;&gt;(list.size()), each) : add(valueList, each));
        }
        return propertiesMap;
    }

    /**
     * 根据列表对象中的某属性值为key划分列表,value为key的属性值相同的对象列表,value为key的属性值相同的对象中指定属性的值列表,
     * 功能同stream().collect(Collectors.groupingBy())
     *
     * @param list
     * @param keyGetter
     * @param valGetter
     * @param &lt;T&gt;
     * @param &lt;K&gt;
     * @param &lt;V&gt;
     * @return
     */
    public static &lt;T, K, V&gt; Map&lt;K, List&lt;V&gt;&gt; groupToMap(Collection&lt;T&gt; list, Function&lt;T, K&gt; keyGetter, Function&lt;T, V&gt; valGetter) {
        Map&lt;K, List&lt;V&gt;&gt; propertiesMap = new HashMap&lt;&gt;(list.size());
        for (T each : list) {
            K key = keyGetter.apply(each);
            List&lt;V&gt; values = Optional.ofNullable(propertiesMap.get(key)).orElse(new ArrayList&lt;&gt;());
            values.add(valGetter.apply(each));
            propertiesMap.put(key, values);
        }
        return propertiesMap;
    }

    /**
     * 获取列表中重复的值
     *
     * @param list
     * @param &lt;T&gt;
     * @return
     */
    public static &lt;T&gt; Set&lt;T&gt; collectRepeats(Collection&lt;T&gt; list) {
        Set&lt;T&gt; set = new HashSet&lt;&gt;(list.size());
        return list.stream()
                .filter(e -&gt; !set.add(e))
                .collect(Collectors.toSet());
    }

    /**
     * 按指定大小，分隔集合，将集合按规定个数分为n个部分
     *
     * @param &lt;T&gt;
     * @param list
     * @param len
     * @return
     */
    public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; splitList(List&lt;T&gt; list, int len) {
        if (list == null || list.isEmpty() || len &lt; 1) {
            return Collections.emptyList();
        }
        List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();

        int size = list.size();
        int count = (size + len - 1) / len;
        for (int i = 0; i &lt; count; i++) {
            List&lt;T&gt; subList = list.subList(i * len, ((i + 1) * len &gt; size ? size : len * (i + 1)));
            result.add(subList);
        }
        return result;
    }

}</code></pre><p>看看使用该工具类替代Stream简单操作后的效果吧：</p>
<pre><code>List&lt;String&gt; namess = ListUtils.collectToList(list,Classify::getName);
Map&lt;Long, String&gt; idMap = ListUtils.collectToMap(list,Classify::getId,Classify::getName);
Map&lt;Long, List&lt;Classify&gt;&gt; parentSonsMap = ListUtils.groupToMap(list,Classify::getParentId);
// 将List转化成key为parentId,value为子分类name列表的映射
Map&lt;Long, List&lt;String&gt;&gt; parentSonNamesMap = ListUtils.groupToMap(list,Classify::getId,Classify::getName);</code></pre><p>可以看出通过函数式接口作为参数传递，不仅可以增加程序的可读性，还可以为我们的编码开发添加不少扩展性。</p>
<ul>
<li><h2 id="简化局部不同多处相同的代码块"><a href="#简化局部不同多处相同的代码块" class="headerlink" title="简化局部不同多处相同的代码块"></a>简化局部不同多处相同的代码块</h2></li>
</ul>
<p>局部不同多出相同的代码块重复出现的状况总会遇到，如一些业务代码前后都相同唯独中间不同，如DB连接-操作-释放、Ssh连接-操作-释放，以下将以一个ssh连接-操作-释放的代码来扩展函数式编程简化代码的用法。<br>可能会有人疑问ssh连接-操作-释放这样的实际操作业务不多吧？就在一段时间之前，上级让我去Zabbix查看各服务器的CPU、内存、磁盘使用率然后写入文档。看到机器数的我内心是拒接的，于是想出了使用java ssh连接到服务器执行相应的查看指令然后提取占用率打印到控制台上，再copy到文档中（反正得到了默许了）。以下是未优化前的两个查询方法：</p>
<pre><code>/**
 * 查询cpu占用率
 */
public static String cpuPercent(String ip, String username, String passw
    JSch jsch = new JSch();
    Session session = null;
    Channel channel = null;
    String cpuPercent = null;
    try {
        session = jsch.getSession(username, ip, 22);
        Properties config = new Properties();
        config.put(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);
        session.setConfig(config);
        session.setPassword(password);
        session.connect();
        String cmd = &quot;sar -u 3 1|awk &apos;{print $8}&apos;|tail -1&quot;;
        channel = session.openChannel(&quot;exec&quot;);
        ((ChannelExec) channel).setCommand(cmd);
        ((ChannelExec) channel).setErrStream(System.err);
        ((ChannelExec) channel).setPty(true);
        channel.connect();
        InputStream in = channel.getInputStream();
        String output = IOUtils.toString(in, StandardCharsets.UTF_8);
        cpuPercent = HUNDRED.subtract(BigDecimal.valueOf(Double.valueOf(
                .setScale(2, RoundingMode.HALF_UP)
                .toString() + &quot;%&quot;;
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (channel != null) {
            channel.disconnect();
        }
        if (session != null) {
            session.disconnect();
        }
    }
    return cpuPercent;
}

/**
 * 磁盘占用率查询
 */
public static String diskPercent(String ip, String username, String pass
    JSch jsch = new JSch();
    Session session = null;
    Channel channel = null;
    String diskPercent = null;
    try {
        session = jsch.getSession(username, ip, 22);
        Properties config = new Properties();
        config.put(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);
        session.setConfig(config);
        session.setPassword(password);
        session.connect();
          String cmd = &quot;df -hl | grep apps|tail -1|awk &apos;{print $4}&apos;&quot;;
        String cmd = &quot;df -hl | grep apps|tail -1|awk &apos;{print $5}&apos;&quot;;
        channel = session.openChannel(&quot;exec&quot;);
        ((ChannelExec) channel).setCommand(cmd);
        ((ChannelExec) channel).setErrStream(System.err);
        ((ChannelExec) channel).setPty(true);
        channel.connect();
        InputStream in = channel.getInputStream();
        diskPercent = IOUtils.toString(in, StandardCharsets.UTF_8);
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (channel != null) {
            channel.disconnect();
        }
        if (session != null) {
            session.disconnect();
        }
    }
    return diskPercent;
}</code></pre><p>相信大家可以看出Ssh连接与释放的代码块是相同的，唯独操作是不同的，于是我把相同的代码块写入了一个方法中，操作的代码块作为参数，优化后的完整代码如下：</p>
<pre><code>public class SshClientUtils {
    private static final BigDecimal HUNDRED = BigDecimal.valueOf(100);
    private static final String RESULT_FORMAT = &quot;%s\t\t%s\t\t%s\t%s&quot;;

    /**
     * 执行查询cpu、mem、disk命令并打印各占用率
     */
    public static void exec(SshConfig sshConfig) {
        System.err.println(&quot;cpu%\t\tmem%\t\tdisk\tip&quot;);
        String username = sshConfig.getUsername();
        String password = sshConfig.getPassword();
        List&lt;String&gt; ipList = sshConfig.getIpList();
        ipList.forEach(ip -&gt; {
            String cpuPercent = cpuPercent(ip, username, password);
            String memoryPercent = memoryPercent(ip, username, password);
            String diskPercent = diskPercent(ip, username, password);
            System.out.println(String.format(RESULT_FORMAT, cpuPercent, memoryPercent, diskPercent, ip)
                    .replaceAll(&quot;\n|\r\n&quot;, &quot;&quot;));
        });
    }

    /**
     * 查询cpu占用率
     */
    public static String cpuPercent(String ip, String username, String password) {
        String cmd = &quot;sar -u 3 1|awk &apos;{print $8}&apos;|tail -1&quot;;
        return exec(ip, username, password, cmd, output -&gt; HUNDRED.subtract(BigDecimal.valueOf(Double.valueOf(output)))
                .setScale(2, RoundingMode.HALF_UP)
                .toString() + &quot;%&quot;);
    }

    /**
     * 内存占用率查询
     */
    public static String memoryPercent(String ip, String username, String password) {
        String cmd = &quot;free|grep Mem&quot;;
        return exec(ip, username, password, cmd, output -&gt; {
            String[] memories = output.replaceAll(&quot;\\s+&quot;, &quot;,&quot;)
                    .substring(5)
                    .split(&quot;,&quot;);
            double total = Integer.parseInt(memories[0]);
            double free = Integer.parseInt(memories[2]);
            double buffers = Integer.parseInt(memories[4]);
            double cache = Integer.parseInt(memories[5]);
            BigDecimal freePercent = BigDecimal.valueOf((free + buffers + cache) / total)
                    .setScale(6, RoundingMode.HALF_UP);
            return BigDecimal.ONE.subtract(freePercent)
                    .multiply(HUNDRED)
                    .setScale(2, RoundingMode.HALF_UP)
                    .toString() + &quot;%&quot;;
        });
    }


    /**
     * 磁盘占用率查询
     */
    public static String diskPercent(String ip, String username, String password) {
        String cmd = &quot;df -hl | grep apps|tail -1|awk &apos;{print $5}&apos;&quot;;
        return exec(ip, username, password, cmd, output -&gt; output);
    }

    /**
     * 直接执行命令
     */
    public static String exec(String ip, String username, String password, String command, Function&lt;String, String&gt; execFunc) {
        JSch jsch = new JSch();
        Session session = null;
        Channel channel = null;
        try {
            session = jsch.getSession(username, ip, 22);
            Properties config = new Properties();
            config.put(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);
            session.setConfig(config);
            session.setPassword(password);
            session.connect();
            channel = session.openChannel(&quot;exec&quot;);
            ((ChannelExec) channel).setCommand(command);
            ((ChannelExec) channel).setErrStream(System.err);
            ((ChannelExec) channel).setPty(true);
            channel.connect();
            InputStream in = channel.getInputStream();
            String output = IOUtils.toString(in, StandardCharsets.UTF_8);
            return func.apply(execFunc);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (channel != null) {
                channel.disconnect();
            }
            if (session != null) {
                session.disconnect();
            }
        }
        return null;
    }
}</code></pre><p>可以看出优化的代码将Ssh的连接与操作都抽象到exec()方法中了，而实际操作则是由入参的Function实现决定，以上便是一个通过Function优化代码部分不同的例子。</p>
<p><strong>将if-set对象属性通过函数式接口放到对象内部执行</strong><br>话多不如实例，相信大家都遇到过类似以下这样的情况：</p>
<pre>
if(condition1){
    classify.setName("Wilson");
}
if(condition2){
    classify.setLevel(5);
}
</pre>
<p>好麻烦，能不能再简单一点(我的简单永远没有上限)，现在先对以上代码块分析一下(简化的核心在于抽离)，相同的部分主要有if、classify，不同的部分为condition的值、set方法、set的值，既然有相同的就作为方法，不同的就作为参数吧(是不是跟ssh的例子想法差别不大吧)，于是我在Classify类中添加了以下方法：</p>
<pre><code>public &lt;V&gt; Classify set(boolean isSet, V value, BiFunction&lt;Classify, V, Classify&gt; setFunction) {
    return isSet ? setFunction.apply(this, value) : this;
}</code></pre><p>???<br>唔，这里可能有一些门槛，如果暂时不理解或觉得无法灵活运动的也不用着急，代码都是慢慢磨出来的，调用一下吧：</p>
<pre><code>Classify classify = new Classify();
classify.set(true, &quot;Wilson&quot;, Classify::setName)
        .set(false, 5, Classify::setLevel);
System.out.println(classify);
// 打印出Classify(id=null, name=Wilson, level=null, parentId=null, sonClassifies=null)</code></pre><p>由于Classify在类上添加了Lombok的注解<code>@Accessors(chain = true)</code>，所以每个set方法结果都会返回当前对象方便链式调用(我很喜欢链式)，所以上面的set方法可以直接返回apply(this,setFunction)的结果。BiFunction前面有提过是需要两个参数并返回一个结果的，在该例子中，由于Classify的setProperty()是返回当前对象的，所以不能用Function&lt;T,R&gt;作为set()的函数式参数(否则T与R都是Classify，无法设置属性)，Classify对象作为BiFunction的第一个参数，set()方法的value作为第二个参数，当前classify对象作为返回值，这样就可以保持我的对象可以继续链式调用各set方法。<br>也有会有人疑问set方法设置返回值不会影响程序的正常运行(如框架的调用)吗？这里个人是从反射与Java关键字void的角度思考过后就一直习惯使对象set方法返回当前对象了，这里希望大家也思考一下便不多作讲解了。</p>
<ul>
<li><h2 id="使用Supplier再提高一下copyProperties的逼格"><a href="#使用Supplier再提高一下copyProperties的逼格" class="headerlink" title="使用Supplier再提高一下copyProperties的逼格"></a>使用Supplier再提高一下copyProperties的逼格</h2><p>相信接触过Spring的都会使用过其中BeanUtils的<code>copyProperties()</code>方法，个人经常使用该方法进行VO属性到Model属性的设置，Model一般都是现场new所以内部属性都是的，反正都是空的何不再通过Supplier函数式接口扩展一下工具类提高一下逼格呢？于是便有了以下代码：</p>
<p>  @NoArgsConstructor<br>  public class ObjectUtils {</p>
<pre><code>public static &lt;S, T&gt; T copyProperties(S source, T target) {
    BeanUtils.copyProperties(source, target);
    return target;
}

public static &lt;S, T&gt; T copyProperties(S source, Supplier&lt;T&gt; targetSupplier) {
    T target = targetSupplier.get();
    BeanUtils.copyProperties(source, target);
    return target;
}</code></pre><p>  }</p>
</li>
</ul>
<p>再以一段Controller的伪代码演示一下:<br><code>Long id = classifyService.insert(ObjectUtils.copyProperties(classifyVO,Classify::new));</code></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Wilson He 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Wilson He 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/list/" rel="next" title="ArrayList与LinkedList区别与源码分析">
      ArrayList与LinkedList区别与源码分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见的函数式接口介绍"><span class="nav-number">2.</span> <span class="nav-text">常见的函数式接口介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见的函数式接口用法"><span class="nav-number">3.</span> <span class="nav-text">常见的函数式接口用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#个人扩展用法"><span class="nav-number">4.</span> <span class="nav-text">个人扩展用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义ListUtils替代Stream的简单操作"><span class="nav-number">4.1.</span> <span class="nav-text">自定义ListUtils替代Stream的简单操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简化局部不同多处相同的代码块"><span class="nav-number">4.2.</span> <span class="nav-text">简化局部不同多处相同的代码块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Supplier再提高一下copyProperties的逼格"><span class="nav-number">4.3.</span> <span class="nav-text">使用Supplier再提高一下copyProperties的逼格</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wilson He"
      src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/atavar/wingsOfPiano.jpg">
  <p class="site-author-name" itemprop="name">Wilson He</p>
  <div class="site-description" itemprop="description">一名普通的搬砖工</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://gitee.com/Wilson-He" title="gitee → https:&#x2F;&#x2F;gitee.com&#x2F;Wilson-He" rel="noopener" target="_blank"><i class="fa fa-fw fa-gg"></i>gitee</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Wilson-He" title="github → https:&#x2F;&#x2F;github.com&#x2F;Wilson-He" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>github</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/z28126308" title="csdn → https:&#x2F;&#x2F;blog.csdn.net&#x2F;z28126308" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>csdn</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:845023508@qq.com" title="Email → mailto:845023508@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>Email</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wilson He</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
