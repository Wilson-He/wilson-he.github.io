<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/piano-icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wilson-he.gitee.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="简介HashMap在1.8之后通过数组(table)属性使用单向链表 + 红黑树的结构组合提高查找效率，于是我大致的画了下图：后来写着写着发现我还是太年轻了，有什么比亲手实践更值得让人信服呢？ 类图分析(只标注主要属性方法)  Map&lt;K,V&gt;:键值映射的基础接口，提供常用的键值映射操作方法的抽象 Map.Entry&lt;K,V&gt;:键值对条目(单个键值)抽象接口 Abstrac">
<meta property="og:type" content="article">
<meta property="og:title" content="透析HashMap">
<meta property="og:url" content="https://wilson-he.gitee.io/HashMap/index.html">
<meta property="og:site_name" content="Wilson Blog">
<meta property="og:description" content="简介HashMap在1.8之后通过数组(table)属性使用单向链表 + 红黑树的结构组合提高查找效率，于是我大致的画了下图：后来写着写着发现我还是太年轻了，有什么比亲手实践更值得让人信服呢？ 类图分析(只标注主要属性方法)  Map&lt;K,V&gt;:键值映射的基础接口，提供常用的键值映射操作方法的抽象 Map.Entry&lt;K,V&gt;:键值对条目(单个键值)抽象接口 Abstrac">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/26/1724ecb73148242e?w=1090&h=610&f=png&s=53123">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/26/1724ecb7bd7d7b52?w=700&h=685&f=png&s=53359">
<meta property="og:image" content="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/hexo-blog/Java%E5%9F%BA%E7%A1%80/HashMap-tree.png">
<meta property="article:published_time" content="2020-06-02T12:24:04.986Z">
<meta property="article:modified_time" content="2020-06-02T12:24:04.987Z">
<meta property="article:author" content="Wilson He">
<meta property="article:tag" content="Java集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2020/5/26/1724ecb73148242e?w=1090&h=610&f=png&s=53123">

<link rel="canonical" href="https://wilson-he.gitee.io/HashMap/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>透析HashMap | Wilson Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wilson Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wilson Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">一名普通的搬砖工</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/index/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Wilson-He" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wilson-he.gitee.io/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/atavar/wingsOfPiano.jpg">
      <meta itemprop="name" content="Wilson He">
      <meta itemprop="description" content="一名普通的搬砖工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wilson Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          透析HashMap
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>HashMap在1.8之后通过数组(table)属性使用单向链表 + 红黑树的结构组合提高查找效率，于是我大致的画了下图：<br><img src="https://user-gold-cdn.xitu.io/2020/5/26/1724ecb73148242e?w=1090&h=610&f=png&s=53123" alt="faker-hashmap-tree.png"><br>后来写着写着发现我还是太年轻了，有什么比亲手实践更值得让人信服呢？</p>
<h1 id="类图分析-只标注主要属性方法"><a href="#类图分析-只标注主要属性方法" class="headerlink" title="类图分析(只标注主要属性方法)"></a>类图分析(只标注主要属性方法)</h1><p><img src="https://user-gold-cdn.xitu.io/2020/5/26/1724ecb7bd7d7b52?w=700&h=685&f=png&s=53359" alt="HashMap类图"></p>
<ul>
<li><code>Map&lt;K,V&gt;</code>:键值映射的基础接口，提供常用的键值映射操作方法的抽象</li>
<li><code>Map.Entry&lt;K,V&gt;</code>:键值对条目(单个键值)抽象接口</li>
<li><code>AbstractMap&lt;K,V&gt;</code>: 简单实现了<code>Map</code>接口的部分方法</li>
<li><code>HashMap&lt;K,V&gt;</code>: 基于<code>Map</code>接口的哈希实现</li>
<li><code>HashMap.Node&lt;K,V&gt;</code>:<code>HashMap</code>键值对条目链表结构的实现类</li>
<li><code>HashMap.TreeNode&lt;K,V&gt;</code>:<code>HashMap</code>键值对条目红黑树结构的实现类</li>
<li><code>LinkedHashMap&lt;K,V&gt;</code>:基于<code>Map</code>接口的哈希表和链表结构实现，与<code>HashMap</code>的主要区别在于键值对都是有序的</li>
<li><code>LinkedHashMap.Entry&lt;K,V&gt;</code>:<code>LinkedHashMap</code>键值条目链表结构的实现类</li>
</ul>
<h1 id="属性解析"><a href="#属性解析" class="headerlink" title="属性解析"></a>属性解析</h1><ul>
<li><code>DEFAULT_INITIAL_CAPACITY</code>：默认16，默认初始容量，必须为2的幂值</li>
<li><code>MAXIMUM_CAPACITY</code>：默认1&lt;&lt;30(即2^29)，最大容量值，如果有参构造函数容量值比该值高，则使用该值作为容量值</li>
<li><code>DEFAULT_LOAD_FACTOR</code>：默认0.75f，构造函数中未指定时使用的负载因子</li>
<li><code>TREEIFY_THRESHOLD</code>：默认8，容器树化阈值，达到阈值(8)后容器将使用红黑树结果存储数据</li>
<li><code>UNTREEIFY_THRESHOLD</code>：默认6，非树化阈值，应小于<code>TREEIFY_THRESHOLD</code>。</li>
<li><code>MIN_TREEIFY_CAPACITY</code>：默认64，表中节点链表结构被树化的最小表容量值，实际会根据容器大小判断是只进行扩容还是进行树化。</li>
<li><code>loadFactor</code>：哈希表的负载因子</li>
<li><code>threshold</code>：下一次调整大小的容量阈值(capacity * load factor)</li>
<li><code>modCount</code>：对该HashMap进行结构修改的次数。结构修改是指更改HashMap中的映射数目或以其他方式修改其内部结构的修改（如重新哈希）。</li>
<li><code>size</code>：包含的键-值映射数</li>
<li><code>table</code>：该表(节点Node数组)在首次使用时初始化，并根据需要调整大小，分配后的长度始终是2的幂。</li>
<li><code>entrySet</code>：用于获取key-value映射集合<code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code>，在首次调用<code>entrySet()</code>方法时被初始化</li>
</ul>
<p>文章使用的术语掺杂了一些个人根据源码与文档的理解，需了解注意的如下：</p>
<ul>
<li>表(table数组) = 容器</li>
<li>table.length = 容量 != 映射数目</li>
<li>table中的节点Node元素 = 桶bin</li>
<li>table中的键值对节点Node以外的元素都以null填充</li>
</ul>
<h1 id="方法解析，窥遍HashMap"><a href="#方法解析，窥遍HashMap" class="headerlink" title="方法解析，窥遍HashMap"></a>方法解析，窥遍<code>HashMap</code></h1><h2 id="HashMap的三个构造函数"><a href="#HashMap的三个构造函数" class="headerlink" title="HashMap的三个构造函数"></a><code>HashMap</code>的三个构造函数</h2><ol>
<li>无参构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用默认的初始容量（16）和默认的加载因子（0.75）构造一个空的HashMap。</span><br><span class="line"> * 注：该方法没有初始化阈值threshold</span><br><span class="line"> *&#x2F;</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>带初始容量的构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化容量initialCapacity、负载因子loadFactor&#x3D;DEFAULT_LOAD_FACTOR(0.75)、阈值threshold</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>带初始容量与f负载因子的构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 以特定的容量与负载系数构建一个空的HashMap</span><br><span class="line"> *</span><br><span class="line"> * @param  initialCapacity 初始容量</span><br><span class="line"> * @param  loadFactor      负载因子</span><br><span class="line"> * @throws IllegalArgumentException initialCapacity为负数、负载因子为负数或非数字时抛错</span><br><span class="line"> *&#x2F;</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;   &#x2F;&#x2F; MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 该方法主要用于设置阈值threshold，返回大于或等于参数容量cap的的2次幂，如cap&#x3D;9、11、12、15、16时都会返回16，cap&#x3D;5、6、7、8时返回8</span><br><span class="line"> * @param cap 容量参数</span><br><span class="line"> * @return 返回大于或等于参数容量cap的的2次幂</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n &#x3D; cap - 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="put-K-V-添加键值"><a href="#put-K-V-添加键值" class="headerlink" title="put(K, V)添加键值"></a>put(K, V)添加键值</h2><p>由<code>HashMap</code>的三个构造函数可以看出构造<code>HashMap</code>时主要初始化了负载因子loadFactor、table扩容阈值threshold,若是无参构造函数则只初始化阈值，所以一般table的初始化都是在put第一个键值对时初始化的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  获取键的哈希值</span><br><span class="line"> * </span><br><span class="line"> *  @param key</span><br><span class="line"> *  @return key的哈希值</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  创建链表节点并设置该节点指向的下一节点</span><br><span class="line"> * </span><br><span class="line"> *  @param hash  键哈希值</span><br><span class="line"> *  @param key   键</span><br><span class="line"> *  @param value 值</span><br><span class="line"> *  @param next  新建节点指向的下一节点</span><br><span class="line"> *  @return      链表节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 实现Map.put和相关的方法</span><br><span class="line"> *</span><br><span class="line"> * @param hash key的哈希值</span><br><span class="line"> * @param key</span><br><span class="line"> * @param value </span><br><span class="line"> * @param onlyIfAbsent true则不替换已存在的key值</span><br><span class="line"> * @param evict 标志表是否处于创建模式</span><br><span class="line"> * @return 返回key之前的值，之前值不存在则返回true</span><br><span class="line"> *&#x2F;</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;</span><br><span class="line">    &#x2F;&#x2F; 引用属性table的临时变量</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    &#x2F;&#x2F; table上的节点引用(p &#x3D; pointer &#x3D; 链表指针)</span><br><span class="line">    Node&lt;K,V&gt; p; </span><br><span class="line">    &#x2F;&#x2F; n用于记录Node&lt;K,V&gt;[] table长度的临时变量，i为key哈希与table.length相与后的table索引index</span><br><span class="line">    int n, i;</span><br><span class="line">    &#x2F;&#x2F; 1. 若table为空则初始化键值对数组table</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    &#x2F;&#x2F; 2 </span><br><span class="line">    &#x2F;&#x2F; 2.1 判断key哈希值与长度相与运算获取相应的数组索引值i，判断table数组i节点是否空，空则直接在该索引放置新节点，跳到&#96;3&#96;；不为空则该位置上的节点将会形成桶(链表|红黑树结构)链接多个节点</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    &#x2F;&#x2F; 2.2 table[i]上的元素节点p不为空        </span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; e可看作遍历table的结果节点(e &#x3D; end)，k用于引用p节点的key值</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        &#x2F;&#x2F; 2.2.1 判断节点p与参数的key是否相同，相同即只需执行替换value，e不为null，跳到&#96;2.2&#96;</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        &#x2F;&#x2F; 2.2.2 参数key与table[i]上的key不匹配，若table[i]的节点为TreeNode，则以TreeNode结构存放新节点，e为null,跳到&#96;2&#96;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        &#x2F;&#x2F; 2.2.3 参数key与table[i]上的key不匹配，且该节点并非TreeNode，则以链式节点存储</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; binCount：桶中的元素数目，即Node&lt;K,V&gt;[] table中的Node节点元素内的key-value键值对数目</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F; p下一节点e为空节点，则新建节点赋到当前节点的next</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    &#x2F;&#x2F; 根据桶中节点数目与容量大小判断是进行扩容还是进行树化，若桶中已有的节点数&gt;&#x3D;8且容量&gt;&#x3D;64则进行树化；e为null,跳到&#96;3&#96;</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; p下一节点e不为空</span><br><span class="line">                &#x2F;&#x2F; p下一节点e的key与参数key相同,e不为null，跳到&#96;2.2&#96;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; p下一节点e的hash或key属性与新增的key不同，则把下一节点赋给p继续进行链表遍历，直到遇到空的节点或hash、key相同的节点</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 2.2.4 e不为空，即Node[] table中已含键为参数key的节点，则替换key的旧值</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">           &#x2F;&#x2F; 获取参数key对应节点的旧映射值</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            &#x2F;&#x2F; 设置key新的映射值</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            afterNodeAccess(e); &#x2F;&#x2F; HashMap中为空实现，主要应用在LinkedHashMap中</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 3. 节点新增成功后的容器相关属性更改</span><br><span class="line">    &#x2F;&#x2F; e为空，则有新的键值对节点添加，结构发生改变，结构修改次数自增</span><br><span class="line">    ++modCount;</span><br><span class="line">    &#x2F;&#x2F; 键值对数目自增，并判断自增后若大于扩容阈值，则调整容量大小</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict); &#x2F;&#x2F; HashMap中为空实现，主要应用在LinkedHashMap中</span><br><span class="line">    &#x2F;&#x2F; 不存在旧节点，返回空</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 若表太小，则resize调整表大小；否则将替换bin(桶)中给定哈希值的索引中所有链接的节点Node为TreeNode。</span><br><span class="line"> *&#x2F;</span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    &#x2F;&#x2F; tab为空或tab数组长度 &lt; MIN_TREEIFY_CAPACITY(64)，即元素数量不多，只重新调整tab长度(容量)，节点维持链表结构而无需更改为红黑树结构</span><br><span class="line">    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    &#x2F;&#x2F; 判断参数hash值在tab数组中相应位置的节点是否不为空</span><br><span class="line">    else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 将e与e链表上链接的所有Node节点转换为TreeNode节点</span><br><span class="line">        do &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);</span><br><span class="line">            if (tl &#x3D;&#x3D; null)</span><br><span class="line">                hd &#x3D; p;</span><br><span class="line">            else &#123;</span><br><span class="line">                p.prev &#x3D; tl;</span><br><span class="line">                tl.next &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl &#x3D; p;</span><br><span class="line">        &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        if ((tab[index] &#x3D; hd) !&#x3D; null)</span><br><span class="line">            &#x2F;&#x2F; 将table转为红黑树结构</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>综上，HashMap添加键值对的流程如下：</p>
<ol>
<li>判断table是否为空，空则调用resize()初始化table数组，一般发生在初次添加键值对</li>
<li>参数key哈希值hash与数组table长度相与获取到索引值i，根据table[i]节点是否为空执行不同的操作<ul>
<li>2.1 table[i]节点p为空：在table[i]创建新节点，跳到步骤3</li>
<li>2.2 table[i]节点p不为空，根据以下不同的情况执行相应的操作<ul>
<li>2.2.1 节点p的key、hash与参数的key、hash匹配：即最终操作只需替换原有key的值，将最终节点e设为p，跳到2.2.4</li>
<li>2.2.2 节点p是一个红黑树节点(TreeNode)类型：根据参数创建新的红黑树节点TreeNode，根据红黑树规则把新节点插入到p节点所在的红黑树上</li>
<li>2.2.3 其它情况(即链表结构，头节点key与参数key不同)：创建新节点并链接到链表末尾，若链表节点数大于8个，则调用treeifyBin()根据table.length长度进行不同的操作<ul>
<li>table.length &gt;= 64，将所有的Node链表节点转为TreeNode红黑树节点</li>
<li>table.length &lt; 64,调用resize()将table.length左移一位(原lengh乘2)，即使链表节点数&gt;8依旧保持链表结构</li>
</ul>
</li>
<li>2.2.4 设置e节点key新值，返回key旧值</li>
</ul>
</li>
</ul>
</li>
<li>节点新增成功后的HashMap相关操作属性更新</li>
</ol>
<h3 id="实力-例-验证"><a href="#实力-例-验证" class="headerlink" title="实力(例)验证"></a>实力(例)验证</h3><blockquote>
<p>为了简单直接的显示<code>HashMap</code>结构，这个博主直接的把<code>HashMap</code>实例里的核心属性都print出来了。</p>
</blockquote>
<ol>
<li><p>table容量&lt;64时，key hashCode相同的节点数&gt;8依旧会保持链表结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void stringKey() throws NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;(32);</span><br><span class="line">    &#x2F;&#x2F; 9个hashKey相同的字符串集合，map容量&lt;64时会在添加第9个&quot;20kf&quot;进行扩容而不会树化，即32则左移一位为64,集合删除&quot;20kf&quot;则不会扩容仍为32</span><br><span class="line">    Set&lt;String&gt; sameHashKeys &#x3D; Sets.newHashSet(&quot;30lG&quot;, &quot;31MG&quot;, &quot;31Lf&quot;, &quot;30kf&quot;, &quot;1nlG&quot;, &quot;2PLf&quot;, &quot;1oLf&quot;, &quot;2OlG&quot;, &quot;2Okf&quot;);</span><br><span class="line">    Field thresholdField &#x3D; HashMap.class.getDeclaredField(&quot;threshold&quot;);</span><br><span class="line">    Field tableField &#x3D; HashMap.class.getDeclaredField(&quot;table&quot;);</span><br><span class="line">    thresholdField.setAccessible(true);</span><br><span class="line">    tableField.setAccessible(true);</span><br><span class="line">    Random random &#x3D; new Random();</span><br><span class="line">    IntStream.range(0, 10).forEach(i -&gt; map.put(String.valueOf(i), i));</span><br><span class="line">    sameHashKeys.forEach(key -&gt; map.put(key, random.nextInt(25)));</span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; sets &#x3D; map.entrySet();</span><br><span class="line">    Map.Entry&lt;String, Integer&gt;[] table &#x3D; (Map.Entry&lt;String, Integer&gt;[]) tableField.get(map);</span><br><span class="line">    long notNullCount &#x3D; Arrays.stream(table)</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .count();</span><br><span class="line">    Set&lt;Class&gt; nodeClasses &#x3D; Arrays.stream(table)</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .map(Object::getClass)</span><br><span class="line">            .collect(Collectors.toSet());</span><br><span class="line">    &#x2F;&#x2F; 输出格式化</span><br><span class="line">    String tableString &#x3D; JSONObject.toJSONString(table)</span><br><span class="line">            .replaceAll(&quot;,null&quot;, &quot;&quot;)</span><br><span class="line">            .replaceAll(&quot;null,&quot;, &quot;&quot;)</span><br><span class="line">            .replaceAll(&quot;\\&#123;|&#125;|\&quot;&quot;, &quot;&quot;)</span><br><span class="line">            .replaceAll(&quot;:&quot;, &quot;&#x3D;&quot;)</span><br><span class="line">            .replaceAll(&quot;,&quot;, &quot;, &quot;);</span><br><span class="line">    System.out.println(&quot;map.size():&quot; + map.size() + &quot;, table.length: &quot; + table.length</span><br><span class="line">            + &quot;, table node count: &quot; + notNullCount + &quot;, entrySet size: &quot; + sets.size());</span><br><span class="line">    System.err.println(&quot;node classes: &quot; + nodeClasses);</span><br><span class="line">    map.remove(&quot;30lG&quot;);</span><br><span class="line">    System.out.println(&quot;table:  &quot; + JSONObject.toJSONString(table));</span><br><span class="line">    System.out.println(&quot;evict null table: &quot; + tableString);</span><br><span class="line">    System.out.println(&quot;entrySet: &quot; + sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.size():19, table.length: 64, table node count: 11, entrySet size: 19</span><br><span class="line">node classes: [class java.util.HashMap$Node]</span><br><span class="line">table:  [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,&#123;&quot;31MG&quot;:22&#125;,&#123;&quot;0&quot;:0&#125;,&#123;&quot;1&quot;:1&#125;,&#123;&quot;2&quot;:2&#125;,&#123;&quot;3&quot;:3&#125;,&#123;&quot;4&quot;:4&#125;,&#123;&quot;5&quot;:5&#125;,&#123;&quot;6&quot;:6&#125;,&#123;&quot;7&quot;:7&#125;,&#123;&quot;8&quot;:8&#125;,&#123;&quot;9&quot;:9&#125;,null,null,null,null,null,null]</span><br><span class="line">evict null table: [30lG&#x3D;13, 0&#x3D;0, 1&#x3D;1, 2&#x3D;2, 3&#x3D;3, 4&#x3D;4, 5&#x3D;5, 6&#x3D;6, 7&#x3D;7, 8&#x3D;8, 9&#x3D;9]</span><br><span class="line">entrySet: [31MG&#x3D;22, 31Lf&#x3D;1, 30kf&#x3D;14, 1nlG&#x3D;7, 2PLf&#x3D;13, 1oLf&#x3D;13, 2OlG&#x3D;21, 2Okf&#x3D;16, 0&#x3D;0, 1&#x3D;1, 2&#x3D;2, 3&#x3D;3, 4&#x3D;4, 5&#x3D;5, 6&#x3D;6, 7&#x3D;7, 8&#x3D;8, 9&#x3D;9]</span><br></pre></td></tr></table></figure>
</li>
<li><p>table容量&gt;=64时，key hashCode相同的节点数&gt;8后HashMap会树化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;(33); &#x2F;&#x2F; 有参容量自动调整为64</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.size():19, table.length: 64, table node count: 11, entrySet size: 19</span><br><span class="line">node classes: [class java.util.HashMap$TreeNode, class java.util.HashMap$Node]</span><br><span class="line">table:  [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,&#123;&quot;30kf&quot;:19&#125;,&#123;&quot;0&quot;:0&#125;,&#123;&quot;1&quot;:1&#125;,&#123;&quot;2&quot;:2&#125;,&#123;&quot;3&quot;:3&#125;,&#123;&quot;4&quot;:4&#125;,&#123;&quot;5&quot;:5&#125;,&#123;&quot;6&quot;:6&#125;,&#123;&quot;7&quot;:7&#125;,&#123;&quot;8&quot;:8&#125;,&#123;&quot;9&quot;:9&#125;,null,null,null,null,null,null]</span><br><span class="line">evict null table: [30kf&#x3D;19, 0&#x3D;0, 1&#x3D;1, 2&#x3D;2, 3&#x3D;3, 4&#x3D;4, 5&#x3D;5, 6&#x3D;6, 7&#x3D;7, 8&#x3D;8, 9&#x3D;9]</span><br><span class="line">entrySet: [30kf&#x3D;19, 31MG&#x3D;8, 31Lf&#x3D;16, 1nlG&#x3D;3, 2PLf&#x3D;19, 1oLf&#x3D;20, 2OlG&#x3D;12, 2Okf&#x3D;15, 0&#x3D;0, 1&#x3D;1, 2&#x3D;2, 3&#x3D;3, 4&#x3D;4, 5&#x3D;5, 6&#x3D;6, 7&#x3D;7, 8&#x3D;8, 9&#x3D;9]</span><br></pre></td></tr></table></figure>
<p>可以看到”30kf”是该红黑树上的root。</p>
</li>
</ol>
<p>那么问题来了，添加映射会调整结构(即更改节点Node类型)，那么删除呢？这个博主有点懒，所以不讲源码给答案：<br><code>HashMap</code>删除节点的过程十分简单，获取节点类型-&gt;根据节点类型进行相应的删除操作，若节点是树节点结构，则判断该树的节点数是否较少(源码文档标注一般为2~6)，较少则把树节点TreeNode转换为普通节点Node，如上例中删除最后4个hashCode相同的节点后(即只剩下5个Node)再打印会发现没有TreeNode了。<br>调用链：<code>hashmap.remove() -&gt; hashmap.removeNode() -&gt; treeNode.removeTreeNode() -&gt; treeNode.untreeify(map)</code></p>
<h2 id="reszie-调整table容量"><a href="#reszie-调整table容量" class="headerlink" title="reszie()调整table容量"></a>reszie()调整table容量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    &#x2F;&#x2F; table未初始化则设旧容量为0，构造函数并没有初始化table,即首次put添加元素时oldCap都为0</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; oldCap &gt; 0意味着并未首次添加元素时调用方法，而是键值对数量&gt;阈值(即size&gt;threshold)时需要扩容调用该方法，可能发生在上文put(K,V)步骤3</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 容量大于默认最大容量，一般可忽略该情况</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 将新容量设为旧容量的一倍，新阈值设为旧阈值的一倍</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; oldCap&#x3D;0 &amp; oldThr&gt;0，该条件可能发生在调用了有参构造函数初始化threshold、loadFactor后通过put首次添加键值对,并把此时的threshold赋给newCap(有参构造函数处提及有参初始化后threshold是2的幂值)</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    &#x2F;&#x2F; oldCap&#x3D;0 &amp; oldThr&#x3D;0,该条件发生在调用了&#96;HashMap&#96;的无参构造函数情况下，容量与阈值皆设为默认值</span><br><span class="line">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;  &#x2F;&#x2F; default cap 16</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#x2F;&#x2F; default threshold 12</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; float threshold，计算后的浮点型阈值</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 设置调整后的阈值</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    &#x2F;&#x2F; 创建新的数组进行键值对迁移，所以建议预估好键值对数量调用有参构造函数初始化&#96;HashMap&#96;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F; Node单节点迁移到新的数组</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    &#x2F;&#x2F; 重新哈希</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F; TreeNode拆分为较高树与较低树，若拆分后的树桶节点数&lt; UNTREEIFY_THRESHOLD &#x3D; 6，则取消树化</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    &#x2F;&#x2F; 类似树节点，链表拆分为较高链与较低链</span><br><span class="line">                    &#x2F;&#x2F; loHead &#x3D; Low Head, Lo Tail &#x3D; Low Tail</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F; hiHead &#x3D; High Head, hiTail &#x3D; High Tail</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，<code>HashMap.put(K,V)</code>调用resize()调整大小主要分以下几种情况：</p>
<ul>
<li>扩容：<code>oldCap = table.length &gt; 0</code>，resize()结果：<ul>
<li><code>table.length = oldCap * 2;</code></li>
<li><code>threshold = table.length * loadFactor</code></li>
</ul>
</li>
<li>有参函数初始化：<code>oldCap = table.length = 0 &amp; oldThr = threshold &gt; 0</code>，resize()结果：<ul>
<li><code>table.length = threshold;</code>，此处threshold值为跟有参构造函数运算后的threshold值，运算后的threshold值是比构造函数参数threshold大的最小一个2的幂值</li>
<li><code>threshold = table.length * loadFactor</code></li>
</ul>
</li>
<li>无参函数初始化：<code>oldCap = table.length = 0 &amp; oldThr = threshold = 0</code><ul>
<li><code>table.length = 16;</code></li>
<li><code>threshold = 12</code></li>
</ul>
</li>
</ul>
<p>容量调整后会再根据table中的节点结构进行相应的操作：</p>
<ul>
<li>单节点Node无链接：重新哈希</li>
<li>树节点TreeNode：将树箱中的节点拆分为较高和较低的树箱，如果拆分后的树箱容量&lt;6，则取消树化；拆分后较低的树箱放在新table[旧table原索引]，较高的树箱迁移到新table[原索引+原table.length],详细可看<code>TreeNode.split()</code>源码</li>
<li>链表结构Node：拆分规则迁移与TreeNode类似，低位链表head node放在新table[原索引]，高位链表迁移到新table[原索引+原table.length]</li>
</ul>
<blockquote>
<p><code>table.length=newCap</code>和<code>threshold</code>调整后会创建新的节点数组进行键值对迁移，所以一般建议初始化时配置好容量避免扩容时的迁移损失。</p>
</blockquote>
<h2 id="clear-清空映射"><a href="#clear-清空映射" class="headerlink" title="clear()清空映射"></a>clear()清空映射</h2><p>clear()只是简单的把table数组的所有元素置为null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">        size &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="疑问record-amp-总结"><a href="#疑问record-amp-总结" class="headerlink" title="疑问record &amp; 总结"></a>疑问record &amp; 总结</h1><ol>
<li><p><code>entrySet()</code>方法返回的明明是一个<code>new EntrySet()</code>，为什么却打印出了完整的<code>HashMap</code>映射?<br><code>EntrySet</code>继承了<code>AbstractSet</code>类并实现了<code>iterator()</code>方法，<code>AbstractSet</code>类<code>toString()</code>方法会调用<code>iterator()</code>方法获取迭代器，再通过<code>Iterator.next()</code>进行元素的字符串拼接。<code>EntrySet。iterator()</code>返回一个实现了<code>Iterator</code>接口的类<code>EntryIterator</code>，通过<code>EntryIterator.next()</code>可以遍历获取<code>HasMap</code>中的所有<code>Node</code>，所以即使<code>HashMap</code>的entrySet属性没有初始化但通过<code>entrySet()</code>方法依旧可以获取<code>HashMap</code>的完整映射。</p>
</li>
<li><p>hashCode相同的key映射数超过8个并不一定就会转为红黑树结构<br><code>HashMap</code>当同hashCode的节点Node超过8个且table数组容量&gt;=64才会转为红黑树结构，否则容量&lt;64时只会进行扩容保存链表结构，Result.png:<br><img src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/hexo-blog/Java%E5%9F%BA%E7%A1%80/HashMap-tree.png" alt="HashMap-tree.png"></p>
</li>
<li><p>resize()进行容量调整并不一定会使每个节点进行重新哈希(rehash),重新哈希只会出现在无链接的单节点上</p>
</li>
</ol>
<blockquote>
<p>如有笔误，还请指出</p>
</blockquote>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Wilson He 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Wilson He 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E9%9B%86%E5%90%88/" rel="tag"># Java集合</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/function-programming/" rel="prev" title="谈谈个人对JDK函数式编程的认知与使用">
      <i class="fa fa-chevron-left"></i> 谈谈个人对JDK函数式编程的认知与使用
    </a></div>
      <div class="post-nav-item">
    <a href="/private-nav/" rel="next" title="个人导航页">
      个人导航页 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类图分析-只标注主要属性方法"><span class="nav-number">2.</span> <span class="nav-text">类图分析(只标注主要属性方法)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#属性解析"><span class="nav-number">3.</span> <span class="nav-text">属性解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法解析，窥遍HashMap"><span class="nav-number">4.</span> <span class="nav-text">方法解析，窥遍HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap的三个构造函数"><span class="nav-number">4.1.</span> <span class="nav-text">HashMap的三个构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#put-K-V-添加键值"><span class="nav-number">4.2.</span> <span class="nav-text">put(K, V)添加键值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实力-例-验证"><span class="nav-number">4.2.1.</span> <span class="nav-text">实力(例)验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reszie-调整table容量"><span class="nav-number">4.3.</span> <span class="nav-text">reszie()调整table容量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clear-清空映射"><span class="nav-number">4.4.</span> <span class="nav-text">clear()清空映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#疑问record-amp-总结"><span class="nav-number">5.</span> <span class="nav-text">疑问record &amp; 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wilson He"
      src="https://knowledge-pictures.oss-cn-beijing.aliyuncs.com/atavar/wingsOfPiano.jpg">
  <p class="site-author-name" itemprop="name">Wilson He</p>
  <div class="site-description" itemprop="description">一名普通的搬砖工</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://gitee.com/Wilson-He" title="gitee → https:&#x2F;&#x2F;gitee.com&#x2F;Wilson-He" rel="noopener" target="_blank"><i class="fa fa-fw fa-gg"></i>gitee</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/Wilson-He" title="github → https:&#x2F;&#x2F;github.com&#x2F;Wilson-He" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>github</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/z28126308" title="csdn → https:&#x2F;&#x2F;blog.csdn.net&#x2F;z28126308" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>csdn</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:845023508@qq.com" title="Email → mailto:845023508@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>Email</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wilson He</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
